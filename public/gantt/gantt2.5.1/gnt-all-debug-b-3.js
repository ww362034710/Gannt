Ext.define("Sch.locale.Locale", {
    l10n: null,
    l10nOverrides: {},
    legacyMode: true,
    localeName: null,
    namespaceId: null,
    constructor: function () {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire()
        }
        var b = this.self.getName().split(".");
        var a = this.localeName = b.pop();
        this.namespaceId = b.join(".");
        var c = Sch.locale.Active[this.namespaceId];
        if (!(a == "En" && c && c.localeName != "En")) {
            this.apply()
        }
    },
    bindRequire: function () {
        var a = Ext.ClassManager.triggerCreated;
        Ext.ClassManager.triggerCreated = function (d) {
            a.apply(this, arguments);
            if (d) {
                var c = Ext.ClassManager.get(d);
                for (var b in Sch.locale.Active) {
                    Sch.locale.Active[b].apply(c)
                }
            }
        }
    },
    applyToClass: function (c, b) {
        var d = this, g = d.self.getName();
        b = b || Ext.ClassManager.get(c);
        if (b && (b.activeLocaleId !== g)) {
            var a = d.l10n[c];
            if (typeof a === "function") {
                a(c)
            } else {
                if (b.singleton) {
                    b.l10n = Ext.apply({}, a, b.prototype && b.prototype.l10n)
                } else {
                    Ext.override(b, {l10n: a})
                }
            }
            if (d.legacyMode) {
                var f;
                if (b.prototype) {
                    f = b.prototype
                } else {
                    if (b.singleton) {
                        f = b
                    }
                }
                if (f && f.legacyMode) {
                    if (f.legacyHolderProp) {
                        if (!f[f.legacyHolderProp]) {
                            f[f.legacyHolderProp] = {}
                        }
                        f = f[f.legacyHolderProp]
                    }
                    for (var e in a) {
                        if (typeof f[e] !== "function") {
                            f[e] = a[e]
                        }
                    }
                }
            }
            b.activeLocaleId = g;
            if (b.onLocalized) {
                b.onLocalized()
            }
        }
    },
    apply: function (g) {
        if (this.l10n) {
            var f = this;
            if (g) {
                if (!Ext.isArray(g)) {
                    g = [g]
                }
                var c, b;
                for (var d = 0, a = g.length; d < a; d++) {
                    if (Ext.isObject(g[d])) {
                        if (g[d].singleton) {
                            b = g[d];
                            c = Ext.getClassName(Ext.getClass(b))
                        } else {
                            b = Ext.getClass(g[d]);
                            c = Ext.getClassName(b)
                        }
                    } else {
                        b = null;
                        c = "string" === typeof g[d] ? g[d] : Ext.getClassName(g[d])
                    }
                    if (c) {
                        if (c in this.l10n) {
                            f.applyToClass(c, b)
                        }
                    }
                }
            } else {
                Sch.locale.Active[this.namespaceId] = this;
                for (var e in this.l10n) {
                    f.applyToClass(e)
                }
            }
        }
    }
});
Ext.define("Sch.locale.En", {
    extend: "Sch.locale.Locale", singleton: true, constructor: function (a) {
        Ext.apply(this, {
            l10n: {
                "Sch.util.Date": {
                    unitNames: {
                        YEAR: {single: "year", plural: "years", abbrev: "yr"},
                        QUARTER: {single: "quarter", plural: "quarters", abbrev: "q"},
                        MONTH: {single: "month", plural: "months", abbrev: "mon"},
                        WEEK: {single: "week", plural: "weeks", abbrev: "w"},
                        DAY: {single: "day", plural: "days", abbrev: "d"},
                        HOUR: {single: "hour", plural: "hours", abbrev: "h"},
                        MINUTE: {single: "minute", plural: "minutes", abbrev: "min"},
                        SECOND: {single: "second", plural: "seconds", abbrev: "s"},
                        MILLI: {single: "ms", plural: "ms", abbrev: "ms"}
                    }
                },
                "Sch.panel.TimelineGridPanel": {
                    weekStartDay: 1,
                    loadingText: "Loading, please wait...",
                    savingText: "Saving changes, please wait..."
                },
                "Sch.panel.TimelineTreePanel": {
                    weekStartDay: 1,
                    loadingText: "Loading, please wait...",
                    savingText: "Saving changes, please wait..."
                },
                "Sch.mixin.SchedulerView": {loadingText: "Loading events..."},
                "Sch.plugin.CurrentTimeLine": {tooltipText: "Current time"},
                "Sch.plugin.EventEditor": {saveText: "Save", deleteText: "Delete", cancelText: "Cancel"},
                "Sch.plugin.SimpleEditor": {newEventText: "New booking..."},
                "Sch.widget.ExportDialog": {
                    generalError: "An error occured, try again.",
                    title: "Export Settings",
                    formatFieldLabel: "Paper format",
                    orientationFieldLabel: "Orientation",
                    rangeFieldLabel: "Export range",
                    showHeaderLabel: "Add page number",
                    showFooterLabel: "Add footer",
                    orientationPortraitText: "Portrait",
                    orientationLandscapeText: "Landscape",
                    completeViewText: "Complete schedule",
                    currentViewText: "Current view",
                    dateRangeText: "Date range",
                    dateRangeFromText: "Export from",
                    pickerText: "Resize column/rows to desired value",
                    dateRangeToText: "Export to",
                    exportButtonText: "Export",
                    cancelButtonText: "Cancel",
                    progressBarText: "Exporting...",
                    exportersFieldLabel: "Export mode",
                    adjustCols: "Adjust column width",
                    adjustColsAndRows: "Adjust column width and row height",
                    specifyDateRange: "Specify date range",
                    columnPickerLabel: "Select columns"
                },
                "Sch.plugin.Export": {
                    fetchingRows: "Fetching row {0} of {1}",
                    builtPage: "Built page {0} of {1}",
                    requestingPrintServer: "Please wait..."
                },
                "Sch.plugin.exporter.AbstractExporter": {name: "Exporter"},
                "Sch.plugin.exporter.SinglePage": {name: "Single page"},
                "Sch.plugin.exporter.MultiPageVertical": {name: "Multiple pages (vertically)"},
                "Sch.plugin.exporter.MultiPage": {name: "Multiple pages"},
                "Sch.preset.Manager": {
                    hourAndDay: {displayDateFormat: "G:i", middleDateFormat: "G:i", topDateFormat: "D d/m"},
                    secondAndMinute: {displayDateFormat: "g:i:s", topDateFormat: "D, d g:iA"},
                    dayAndWeek: {displayDateFormat: "m/d h:i A", middleDateFormat: "D d M"},
                    weekAndDay: {displayDateFormat: "m/d", bottomDateFormat: "d M", middleDateFormat: "Y F d"},
                    weekAndMonth: {displayDateFormat: "m/d/Y", middleDateFormat: "m/d", topDateFormat: "m/d/Y"},
                    weekAndDayLetter: {displayDateFormat: "m/d/Y", middleDateFormat: "D d M Y"},
                    weekDateAndMonth: {displayDateFormat: "m/d/Y", middleDateFormat: "d", topDateFormat: "Y F"},
                    monthAndYear: {displayDateFormat: "m/d/Y", middleDateFormat: "M Y", topDateFormat: "Y"},
                    year: {displayDateFormat: "m/d/Y", middleDateFormat: "Y"},
                    manyYears: {displayDateFormat: "m/d/Y", middleDateFormat: "Y"}
                }
            }
        });
        this.callParent(arguments)
    }
});
Ext.define("Sch.util.Patch", {
    target: null,
    minVersion: null,
    maxVersion: null,
    reportUrl: null,
    description: null,
    applyFn: null,
    ieOnly: false,
    macOnly: false,
    overrides: null,
    onClassExtended: function (a, b) {
        if (Sch.disableOverrides) {
            return
        }
        if (b.ieOnly && !Ext.isIE) {
            return
        }
        if (b.macOnly && !Ext.isMac) {
            return
        }
        if ((!b.minVersion || Ext.versions.extjs.equals(b.minVersion) || Ext.versions.extjs.isGreaterThan(b.minVersion)) && (!b.maxVersion || Ext.versions.extjs.equals(b.maxVersion) || Ext.versions.extjs.isLessThan(b.maxVersion))) {
            if (b.applyFn) {
                b.applyFn()
            } else {
                Ext.ClassManager.get(b.target).override(b.overrides)
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.patches.BufferedRenderer")) {
    Ext.define("Sch.patches.BufferedRenderer", {
        extend: "Sch.util.Patch",
        requires: ["Ext.grid.plugin.BufferedRenderer"],
        target: "Ext.grid.plugin.BufferedRenderer",
        overrides: {
            onRangeFetched: function () {
                this.tableTopBorderWidth = this.tableTopBorderWidth || 0;
                return this.callParent(arguments)
            }, refreshSize: function (d, b) {
                var c = this, a = c.view;
                if (a.body.dom) {
                    this.callParent(arguments)
                }
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.patches.NodeStore")) {
    Ext.define("Sch.patches.NodeStore", {
        extend: "Sch.util.Patch",
        requires: ["Ext.data.NodeStore"],
        target: "Ext.data.NodeStore",
        ieOnly: true,
        maxVersion: "5.1.1",
        overrides: {
            afterEdit: function (a, b) {
                if (this.getNode() && b) {
                    if (Ext.Array.indexOf(b, "loaded") !== -1) {
                        return this.add(this.retrieveChildNodes(a))
                    }
                    if (Ext.Array.indexOf(b, "expanded") !== -1) {
                        return this.filter()
                    }
                    if (Ext.Array.indexOf(b, "sorted") !== -1) {
                        return this.sort()
                    }
                }
                Ext.data.Store.prototype.afterEdit.apply(this, arguments)
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.patches.NodeCache")) {
    Ext.define("Sch.patches.NodeCache", {
        extend: "Sch.util.Patch",
        requires: ["Ext.view.NodeCache"],
        target: "Ext.view.NodeCache",
        minVersion: "5.1.0",
        overrides: {
            scroll: function (d, c, b) {
                var a;
                if (d.length === 0) {
                    a = []
                } else {
                    a = this.callParent(arguments)
                }
                return a
            }
        }
    })
}
Ext.define("Sch.patches.ColumnResizeTree", {
    override: "Sch.panel.TimelineTreePanel", afterRender: function () {
        this.callParent(arguments);
        var a = this.lockedGrid.headerCt.findPlugin("gridheaderresizer");
        if (a) {
            a.getConstrainRegion = function () {
                var d = this, b = d.dragHd.el, c;
                if (d.headerCt.forceFit) {
                    c = d.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                    if (!d.headerInSameGrid(c)) {
                        c = null
                    }
                }
                return d.adjustConstrainRegion(Ext.util.Region.getRegion(b), 0, d.headerCt.forceFit ? (c ? c.getWidth() - d.minColWidth : 0) : d.maxColWidth - b.getWidth(), 0, d.minColWidth)
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.patches.RowSynchronizer")) {
    Ext.define("Sch.patches.RowSynchronizer", {
        extend: "Sch.util.Patch",
        requires: ["Ext.grid.locking.RowSynchronizer"],
        target: "Ext.grid.locking.RowSynchronizer",
        minVersion: "5.1.0",
        overrides: Ext.versions.extjs.isGreaterThan("5.1.0") ? {
            finish: function (a) {
                if (!a) {
                    return
                }
                return this.callParent(arguments)
            }
        } : {}
    })
}
Ext.define("Sch.patches.TouchScroll", {
    extend: "Sch.util.Patch",
    requires: ["Ext.scroll.TouchScroller"],
    target: "Ext.scroll.TouchScroller",
    minVersion: "5.1.0",
    overrides: {
        privates: {
            onEvent: function (b) {
                var a = this;
                if (!a[a.listenerMap[b.type]]) {
                    return
                }
                return this.callParent(arguments)
            }
        }
    }
});
Ext.define("Sch.patches.PartnerScroll", {
    extend: "Sch.util.Patch",
    requires: ["Ext.scroll.Scroller"],
    minVersion: "5.1.0",
    maxVersion: "5.1.1",
    applyFn: function () {
        if (Ext.isMac || Ext.isGecko) {
            Ext.ClassManager.get("Ext.scroll.Scroller").override({
                constructor: function (a) {
                    var b = this;
                    b.callParent([a]);
                    this.doNotCall = {}
                }, privates: {
                    onPartnerScrollEnd: function () {
                        this.doNotCall = {}
                    }, invokePartners: function (f, a, e) {
                        var c = this._partners, b, d;
                        if (!this.suspendSync) {
                            for (d in c) {
                                b = c[d];
                                if (!b.suspendSync && !this.doNotCall[b.scroller.id]) {
                                    b.scroller[f](this, a, e)
                                } else {
                                    if (!b.scroller.component.isTableView) {
                                        delete this.doNotCall[b.scroller.id]
                                    }
                                }
                            }
                        }
                    }, onPartnerScroll: function (c, a, d) {
                        var b = c._partners[this.getId()].axis;
                        if (b) {
                            if (b === "x") {
                                d = null
                            } else {
                                if (b === "y") {
                                    a = null
                                }
                            }
                        }
                        this.doNotCall[c.id] = true;
                        this.doScrollTo(a, d, null, false)
                    }
                }
            })
        }
    }
});
Ext.define("Sch.patches.View", {
    extend: "Sch.util.Patch",
    requires: ["Ext.view.View"],
    target: "Ext.view.View",
    minVersion: "5.1.0",
    overrides: {
        handleEvent: function (d) {
            var c = this, b = c.keyEventRe.test(d.type), a = c.getNavigationModel();
            d.view = c;
            if (b) {
                d.item = a.getItem();
                d.record = a.getRecord()
            }
            if (!d.item) {
                d.item = d.getTarget(c.itemSelector)
            }
            if (d.item && !d.record) {
                d.record = c.getRecord(d.item)
            }
            if (c.processUIEvent(d) !== false) {
                c.processSpecialEvent(d)
            }
            if (b && !Ext.fly(d.target).isInputField()) {
                if (d.getKey() === d.SPACE || d.isNavKeyPress(true)) {
                    d.preventDefault()
                }
            }
        }
    }
});
Ext.define("Sch.patches.TableView", {
    extend: "Sch.util.Patch",
    requires: ["Ext.view.Table"],
    target: "Ext.view.Table",
    minVersion: "5.1.0",
    overrides: {
        getLastFocused: function () {
            var a = this.callParent(arguments);
            return a || this.navigationModel.lastFocused
        }
    }
});
Ext.define("Sch.patches.Collection", {
    extend: "Sch.util.Patch",
    requires: ["Ext.util.Collection"],
    target: "Ext.util.Collection",
    minVersion: "5.1.0",
    overrides: {
        updateKey: function (b, e) {
            var a = this, d = a.map, g = a.indices, c = a.getSource(), f;
            if (c && !c.updating) {
                c.updateKey(b, e)
            } else {
                if (d[e] && (f = a.getKey(b)) !== e) {
                    if (e in d || d[f] !== b) {
                        if (e in d) {
                            delete d[e]
                        }
                        a.updating++;
                        a.generation++;
                        d[f] = b;
                        if (g) {
                            g[f] = g[e];
                            delete g[e]
                        }
                        a.notify("updatekey", [{item: b, newKey: f, oldKey: e}]);
                        a.updating--
                    }
                }
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.patches.TreeStore")) {
    Ext.define("Sch.patches.TreeStore", {
        extend: "Sch.util.Patch",
        requires: ["Ext.data.TreeStore"],
        target: "Ext.data.TreeStore",
        minVersion: "5.1.0",
        overrides: {
            getRejectRecords: function () {
                return this.getModifiedRecords()
            }, rejectChanges: function () {
                this.removed = this.removedNodes;
                this.callParent(arguments)
            }, remove: function (b) {
                if (b.isModel) {
                    b.remove()
                } else {
                    if (b instanceof Array && b[0].isModel) {
                        for (var a = 0; a < b.length; a++) {
                            b[a].remove()
                        }
                    } else {
                        this.callParent(arguments)
                    }
                }
            }
        }
    })
}
Ext.define("Sch.patches.TreeStoreInternalIdMap", {
    extend: "Sch.util.Patch",
    requires: ["Ext.data.TreeStore"],
    target: "Ext.data.TreeStore",
    minVersion: "5.1.1",
    overrides: {
        registerNode: function (c, a) {
            var b = this;
            if (!b.byInternalIdMap) {
                b.byInternalIdMap = {}
            }
            b.byInternalIdMap[c.internalId] = c;
            b.callParent(arguments)
        }, unregisterNode: function (c, a) {
            var b = this;
            if (b.byInternalIdMap) {
                delete b.byInternalIdMap[c.internalId]
            }
            b.callParent(arguments)
        }, updateRoot: function () {
            this.byInternalIdMap = {};
            this.callParent(arguments)
        }
    }
});
Ext.define("Sch.patches.ToolTip", {
    extend: "Sch.util.Patch",
    requires: ["Ext.tip.ToolTip"],
    target: "Ext.tip.ToolTip",
    minVersion: "5.1.0",
    overrides: {
        setTarget: function (d) {
            var b = this, a = Ext.get(d), c;
            if (b.target) {
                c = Ext.get(b.target);
                b.mun(c, {
                    mouseover: b.onTargetOver,
                    tap: b.onTargetOver,
                    mouseout: b.onTargetOut,
                    mousemove: b.onMouseMove,
                    scope: b
                })
            }
            b.target = a;
            if (a) {
                b.mon(a, {
                    mouseover: b.onTargetOver,
                    tap: b.onTargetOver,
                    mouseout: b.onTargetOut,
                    mousemove: b.onMouseMove,
                    scope: b
                })
            }
            if (b.anchor) {
                b.anchorTarget = b.target
            }
        }
    }
});
Ext.define("Sch.patches.OperationDestroy", {
    extend: "Sch.util.Patch",
    requires: ["Ext.data.operation.Destroy"],
    target: "Ext.data.operation.Destroy",
    minVersion: "5.1.1",
    maxVersion: "5.1.2",
    overrides: {
        doProcess: function () {
            var c = Ext.Array.slice(this.getRecords()), a = c.length, b;
            for (b = 0; b < a; ++b) {
                c[b].setErased()
            }
        }
    }
});
Ext.define("Sch.patches.Chrome", {
    extend: "Sch.util.Patch",
    requires: ["Ext.util.CSS"],
    minVersion: "5.1.0",
    applyFn: function () {
        if (Ext.isChrome && Ext.browser.version.isGreaterThanOrEqual("43")) {
            Ext.util.CSS.createStyleSheet(".sch-timelinepanel ." + Ext.baseCSSPrefix + "form-text { display: inherit; }")
        }
    }
});
Ext.define("Sch.mixin.Localizable", {
    requires: ["Sch.locale.En"],
    legacyMode: false,
    activeLocaleId: "",
    l10n: null,
    isLocaleApplied: function () {
        var b = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;
        if (!b) {
            return false
        }
        for (var a in Sch.locale.Active) {
            if (b === Sch.locale.Active[a].self.getName()) {
                return true
            }
        }
        return false
    },
    applyLocale: function () {
        for (var a in Sch.locale.Active) {
            Sch.locale.Active[a].apply(this.singleton ? this : this.self.getName())
        }
    },
    L: function () {
        return this.localize.apply(this, arguments)
    },
    localize: function (b, d, g) {
        if (!this.isLocaleApplied() && !g) {
            this.applyLocale()
        }
        if (this.hasOwnProperty("l10n") && this.l10n.hasOwnProperty(b) && "function" != typeof this.l10n[b]) {
            return this.l10n[b]
        }
        var c = this.self && this.self.prototype;
        if (this.legacyMode) {
            var a = d || this.legacyHolderProp;
            var h = a ? this[a] : this;
            if (h && h.hasOwnProperty(b) && "function" != typeof h[b]) {
                return h[b]
            }
            if (c) {
                var e = a ? c[a] : c;
                if (e && e.hasOwnProperty(b) && "function" != typeof e[b]) {
                    return e[b]
                }
            }
        }
        var i = c.l10n && c.l10n[b];
        if (i === null || i === undefined) {
            var f = c && c.superclass;
            if (f && f.localize) {
                i = f.localize(b, d, g)
            }
            if (i === null || i === undefined) {
                throw"Cannot find locale: " + b + " [" + this.self.getName() + "]"
            }
        }
        return i
    }
});
Ext.define("Sch.crud.AbstractManager", {
    require: ["Ext.data.StoreManager"],
    mixins: {observable: "Ext.util.Observable"},
    revision: null,
    stores: null,
    storeIdProperty: "storeId",
    storesIndex: null,
    activeRequests: null,
    delayedSyncs: null,
    transport: null,
    trackResponseType: false,
    phantomIdField: "$PhantomId",
    autoLoad: false,
    autoSyncTimeout: 100,
    autoSync: false,
    resetIdsBeforeSync: true,
    syncApplySequence: null,
    writeAllFields: false,
    ignoreUpdates: 0,
    createMissingRecords: false,
    autoSyncTimerId: null,
    constructor: function (b) {
        b = b || {};
        this.mixins.observable.constructor.call(this, b);
        this.activeRequests = {};
        this.delayedSyncs = [];
        this.transport = b.transport || this.transport || {};
        var a = b.stores || this.stores;
        this.stores = [];
        this.addStore(a);
        var c = b.syncApplySequence || this.syncApplySequence;
        if (c) {
            this.syncApplySequence = null;
            this.addStoreToApplySequence(c)
        }
        if (this.autoLoad) {
            this.load()
        }
    },
    updateStoreIndex: function () {
        var b = {};
        for (var d = 0, a = this.stores.length; d < a; d++) {
            var c = this.stores[d];
            if (c.storeId) {
                b[c.storeId] = this.stores[d]
            }
        }
        this.storesIndex = b
    },
    getStoreDescriptor: function (b) {
        if (!b) {
            return
        }
        if (b instanceof Ext.data.AbstractStore) {
            for (var c = 0, a = this.stores.length; c < a; c++) {
                if (this.stores[c].store === b) {
                    return this.stores[c]
                }
            }
        } else {
            if (typeof b == "object") {
                return this.storesIndex[b.storeId]
            } else {
                return this.storesIndex[b] || this.getStoreDescriptor(Ext.data.StoreManager.get(b))
            }
        }
    },
    getStore: function (a) {
        var b = this.getStoreDescriptor(a);
        return b && b.store
    },
    forEachStore: function (e, d) {
        if (!e) {
            return
        }
        var b = this.stores;
        for (var c = 0, a = b.length; c < a; c++) {
            if (e.call(d || this, b[c].store, b[c].storeId, b[c]) === false) {
                break
            }
        }
    },
    addStore: function (p, h, a) {
        if (!p) {
            return
        }
        if (!Ext.isArray(p)) {
            p = [p]
        }
        var f = [];
        for (var g = 0, c = p.length; g < c; g++) {
            var o = p[g];
            if (o instanceof Ext.data.AbstractStore) {
                o = {store: o}
            } else {
                if (typeof o == "object") {
                    if (o.stores) {
                        if (!Ext.isArray(o.stores)) {
                            o.stores = [o.stores]
                        }
                        for (var d = 0, b = o.stores.length; d < b; d++) {
                            var k = o.stores[d], e = k;
                            if ("string" === typeof k) {
                                e = {storeId: k}
                            }
                            e.masterStoreInfo = o;
                            o.stores[d] = e
                        }
                    }
                } else {
                    o = {store: Ext.data.StoreManager.get(o)}
                }
            }
            f.push(this.fillStoreDescriptor(o));
            o.store.crudManager = this;
            this.mon(o.store, {
                add: this.onStoreChange,
                append: this.onStoreChange,
                insert: this.onStoreChange,
                update: this.onStoreUpdate,
                remove: this.onStoreChange,
                clear: this.onStoreChange,
                scope: this
            })
        }
        if (typeof h === "undefined") {
            this.stores.push.apply(this.stores, f)
        } else {
            var m = h;
            if (a) {
                if (a instanceof Ext.data.AbstractStore || typeof a !== "object") {
                    a = this.getStoreDescriptor(a)
                }
                m += Ext.Array.indexOf(this.stores, a)
            }
            this.stores.splice.apply(this.stores, [].concat([m, 0], f))
        }
        this.updateStoreIndex()
    },
    fillStoreDescriptor: function (d) {
        var a = d.store, c = a.storeIdProperty || this.storeIdProperty, b = a.getModel && a.getModel() || a.model;
        b = b && b.prototype;
        Ext.applyIf(d, {
            storeId: a[c],
            phantomIdField: b && b.phantomIdField,
            idProperty: b && b.idProperty,
            writeAllFields: a.writeAllFields
        });
        return d
    },
    removeStore: function (b) {
        for (var c = 0, a = this.stores.length; c < a; c++) {
            var d = this.stores[c];
            if (d === b || d.store === b || d.storeId === b) {
                this.mun(d.store, {
                    add: this.onStoreChange,
                    append: this.onStoreChange,
                    insert: this.onStoreChange,
                    update: this.onStoreUpdate,
                    remove: this.onStoreChange,
                    clear: this.onStoreChange,
                    scope: this
                });
                delete this.storesIndex[d.storeId];
                this.stores.splice(c, 1);
                if (this.syncApplySequence) {
                    this.removeStoreFromApplySequence(b)
                }
                break
            }
        }
    },
    addStoreToApplySequence: function (c, a, e) {
        if (!c) {
            return
        }
        if (!Ext.isArray(c)) {
            c = [c]
        }
        var g = [];
        for (var d = 0, b = c.length; d < b; d++) {
            var f = this.getStoreDescriptor(c[d]);
            if (f) {
                g.push(f)
            }
        }
        if (!this.syncApplySequence) {
            this.syncApplySequence = []
        }
        if (typeof a === "undefined") {
            this.syncApplySequence.push.apply(this.syncApplySequence, g)
        } else {
            var h = a;
            if (e) {
                if (e instanceof Ext.data.AbstractStore || typeof e !== "object") {
                    e = this.getStoreDescriptor(e)
                }
                h += Ext.Array.indexOf(this.syncApplySequence, e)
            }
            this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([h, 0], g))
        }
    },
    removeStoreFromApplySequence: function (b) {
        for (var c = 0, a = this.syncApplySequence.length; c < a; c++) {
            var d = this.syncApplySequence[c];
            if (d === b || d.store === b || d.storeId === b) {
                this.syncApplySequence.splice(c, 1);
                break
            }
        }
    },
    onStoreUpdate: function (b, a) {
        if (!b.isTreeStore || a !== b.getRoot()) {
            this.onStoreChange()
        }
    },
    onStoreChange: function () {
        if (this.ignoreUpdates) {
            return
        }
        var a = this;
        this.fireEvent(this.hasChanges() ? "haschanges" : "nochanges", this);
        if (this.autoSync) {
            if (!this.autoSyncTimerId) {
                this.autoSyncTimerId = setTimeout(function () {
                    a.autoSyncTimerId = null;
                    a.sync()
                }, this.autoSyncTimeout)
            }
        }
    },
    hasChanges: function (b) {
        var c;
        if (b) {
            c = this.getStore(b);
            if (!c) {
                return
            }
            return Boolean(c.getModifiedRecords().length || c.getRemovedRecords().length)
        }
        for (var d = 0, a = this.stores.length; d < a; d++) {
            c = this.stores[d].store;
            if (c.getModifiedRecords().length || c.getRemovedRecords().length) {
                return true
            }
        }
        return false
    },
    getLoadPackage: function (k) {
        var g = {type: "load", requestId: this.getRequestId(), stores: []};
        var j = this.stores, b = g.stores;
        for (var e = 0, c = j.length; e < c; e++) {
            var h = j[e], a = k && k[h.storeId], f = h.pageSize || h.store.pageSize;
            if (a || f) {
                var d = Ext.apply({storeId: h.storeId, page: 1, pageSize: f}, a);
                j[e].currentPage = d.page;
                b.push(d)
            } else {
                b.push(h.storeId)
            }
        }
        return g
    },
    prepareAdded: function (h, m, k) {
        var o = [];
        for (var c = 0, a = h.length; c < a; c++) {
            var d = h[c], b = {}, e = d.getFields();
            if (!b.hasOwnProperty(m)) {
                b[m] = d.getId()
            }
            for (var g = 0, n = e.length; g < n; g++) {
                var j = e[g];
                if (j) {
                    if (j.persist && (d.data.hasOwnProperty(j.name) || j.critical)) {
                        if (j.serialize) {
                            b[j.name] = j.serialize(d.data[j.name], d)
                        } else {
                            b[j.name] = d.data[j.name]
                        }
                    }
                }
            }
            if (this.resetIdsBeforeSync) {
                delete b[d.idProperty]
            }
            if (k) {
                this.processSubStores(d, b, k)
            }
            o.push(b)
        }
        return o
    },
    prepareUpdated: function (m, p, o) {
        var q = [], b = o.writeAllFields || (o.writeAllFields !== false && this.writeAllFields), e, n;
        for (var g = 0, c = m.length; g < c; g++) {
            var h = m[g], k;
            if (b) {
                e = h.getData();
                e[h.idProperty] = h.getId();
                for (k in e) {
                    n = h.getField(k);
                    if (!n || !n.persist && !n.critical) {
                        delete e[k]
                    } else {
                        if (n.serialize) {
                            e[k] = n.serialize(e[k], h)
                        } else {
                            e[k] = h.get(k)
                        }
                    }
                }
            } else {
                e = h.getChanges();
                e[h.idProperty] = h.getId();
                for (k in e) {
                    n = h.getField(k);
                    if (!n || !n.persist) {
                        delete e[k]
                    } else {
                        if (n.serialize) {
                            e[k] = n.serialize(e[k], h)
                        } else {
                            e[k] = h.get(k)
                        }
                    }
                }
                var a = h.getCriticalFields();
                for (var d = 0; d < a.length; d++) {
                    n = a[d];
                    if (n.serialize) {
                        e[n.getName()] = n.serialize(h.get(n.getName()), h)
                    } else {
                        e[n.getName()] = h.get(n.getName())
                    }
                }
            }
            if (p) {
                this.processSubStores(h, e, p)
            }
            q.push(e)
        }
        return q
    },
    prepareRemoved: function (e) {
        var a = [], d;
        for (var c = 0, b = e.length; c < b; c++) {
            d = {};
            d[e[c].idProperty] = e[c].getId();
            a.push(d)
        }
        return a
    },
    processSubStores: function (b, f, a) {
        for (var d = 0, h = a.length; d < h; d++) {
            var g = a[d].storeId, c = b.get(g);
            if (c) {
                var e = this.getStoreChanges(Ext.apply({store: c}, a[d]));
                if (e) {
                    f[g] = Ext.apply(e, {$store: true})
                } else {
                    delete f[g]
                }
            } else {
                delete f[g]
            }
        }
    },
    getStoreChanges: function (d, g) {
        g = g || d.phantomIdField || this.phantomIdField;
        var f = d.store, e = f.getNewRecords(), c = f.getUpdatedRecords(), h = f.getRemovedRecords(), b = d.stores;
        var a;
        if (e.length) {
            e = this.prepareAdded(e, g, b)
        }
        if (c.length) {
            c = this.prepareUpdated(c, b, d)
        }
        if (h.length) {
            h = this.prepareRemoved(h)
        }
        if (e.length || c.length || h.length) {
            a = {};
            if (e.length) {
                a.added = e
            }
            if (c.length) {
                a.updated = c
            }
            if (h.length) {
                a.removed = h
            }
        }
        return a
    },
    getChangeSetPackage: function () {
        var d = {type: "sync", requestId: this.getRequestId(), revision: this.revision};
        var f = this.stores, j = 0;
        for (var b = 0, a = f.length; b < a; b++) {
            var e = f[b], g = e.phantomIdField || this.phantomIdField, h = e.storeId;
            var c = this.getStoreChanges(e, g);
            if (c) {
                j++;
                d[h] = c
            }
        }
        return j ? d : null
    },
    getSubStoresData: function (h, f, g, e) {
        if (!h) {
            return
        }
        var j = [];
        var a = function (n, o) {
            for (var l = 0, i = o.length; l < i; l++) {
                var k = o[l].storeId;
                if (n[k]) {
                    j.push({id: n[g], storeDesc: o[l], data: n[k]});
                    delete n[k]
                }
            }
        };
        var d = 0, c = h.length;
        if (e) {
            for (; d < c; d++) {
                a(h[d], f);
                var b = this.getSubStoresData(h[d].children, f, g, true);
                if (b) {
                    j = j.concat(b)
                }
            }
        } else {
            for (; d < c; d++) {
                a(h[d], f)
            }
        }
        return j
    },
    loadDataToStore: function (a, d) {
        var h = a.store, j = a.stores, k = a.idProperty || "id", f = h instanceof Ext.data.TreeStore, g;
        var m = d && d.rows;
        h.metaData = d && d.metaData;
        if (m) {
            if (j) {
                g = this.getSubStoresData(m, j, k, f)
            }
            h.__loading = true;
            if (f) {
                h.proxy.data = m;
                h.load()
            } else {
                h.totalCount = d.total;
                h.currentPage = a.currentPage;
                h.loadData(m);
                h.fireEvent("load", h, h.getRange(), true)
            }
            if (g) {
                for (var c = 0, b = g.length; c < b; c++) {
                    var e = g[c];
                    this.loadDataToStore(Ext.apply({store: h[f ? "getNodeById" : "getById"](e.id).get(e.storeDesc.storeId)}, e.storeDesc), e.data)
                }
            }
            h.__loading = false
        }
    },
    loadData: function (b) {
        for (var c = 0, a = this.stores.length; c < a; c++) {
            var e = this.stores[c], d = b[e.storeId];
            if (d) {
                this.loadDataToStore(e, d)
            }
        }
    },
    applyChangesToRecord: function (g, i, m) {
        var h = g.fields, f = g.data, e = {}, c = false, a;
        if (m) {
            for (var d = 0, b = m.length; d < b; d++) {
                a = m[d].storeId;
                if (i.hasOwnProperty(a)) {
                    e[a] = true;
                    var l = g.get(a);
                    if (l) {
                        this.applyChangesToStore(Ext.apply({store: l}, m[d]), i[a])
                    } else {
                        Ext.log("Can't find store for the response sub-package")
                    }
                }
            }
        }
        for (a in i) {
            if (i.hasOwnProperty(a) && !e[a]) {
                var k = i[a];
                if (!g.isEqual(f[a], k)) {
                    if (!c) {
                        c = true;
                        g.beginEdit()
                    }
                    if (a === g.idProperty) {
                        g.setId(k)
                    } else {
                        g.set(a, k)
                    }
                }
            }
        }
        this.ignoreUpdates++;
        if (c) {
            g.endEdit()
        }
        this.ignoreUpdates--;
        g.commit()
    },
    applyRemovals: function (o, m, d) {
        var p = d.idProperty, n = o.getRemovedRecords(), q = d.findByIdFn, a = d.removeRecordFn, h = 0;
        for (var g = 0, e = m.length; g < e; g++) {
            var f = false;
            var c = m[g][p];
            for (var l = 0, b = n.length; l < b; l++) {
                if (n[l].getId() == c) {
                    n.splice(l, 1);
                    f = true;
                    h++;
                    break
                }
            }
            if (!f) {
                var i = q(c);
                if (i) {
                    this.ignoreUpdates++;
                    a(i);
                    Ext.Array.remove(n, i);
                    h++;
                    this.ignoreUpdates--
                } else {
                    Ext.log("Can't find record to remove from the response package")
                }
            }
        }
        return h
    },
    applyChangesToStore: function (h, x) {
        var t, r, p;
        var b = h.phantomIdField || this.phantomIdField, i = h.idProperty, o = h.store;
        if (!i) {
            var e = o.getModel && o.getModel() || o.model;
            e = e && e.prototype;
            i = e && e.idProperty || "id"
        }
        var q = function (j) {
            return o.data.getByKey(j)
        }, w = function (j) {
            return o.getById(j)
        }, g = function (j) {
            return o.getNodeById(j)
        }, a, v;
        var n, m;
        if (o instanceof Ext.data.TreeStore) {
            n = m = g;
            a = function (k) {
                var j = (k.parentId && o.getNodeById(k.parentId)) || o.getRootNode();
                return j.appendChild(k)
            };
            v = function (j) {
                return j.parentNode.removeChild(j)
            }
        } else {
            n = q;
            m = w;
            a = function (j) {
                return o.add(j)[0]
            };
            v = function (j) {
                return o.remove(j)
            }
        }
        var l = x.rows, u = x.removed, c;
        if (l) {
            var y, d, f = h.stores;
            for (t = 0, r = l.length; t < r; t++) {
                y = l[t];
                d = y[b];
                p = y[i];
                c = null;
                if (d != null) {
                    c = n(d)
                } else {
                    if (i) {
                        c = m(p)
                    }
                }
                if (c) {
                    this.applyChangesToRecord(c, y, f)
                } else {
                    this.ignoreUpdates++;
                    c = a(y);
                    this.ignoreUpdates--;
                    c.commit()
                }
            }
        }
        if (u && this.applyRemovals(o, u, {idProperty: i, findByIdFn: m, removeRecordFn: v})) {
            o.fireEvent("datachanged", o)
        }
    },
    applySyncResponse: function (c) {
        var b = this.syncApplySequence || this.stores;
        for (var d = 0, a = b.length; d < a; d++) {
            var e = c[b[d].storeId];
            if (e) {
                this.applyChangesToStore(b[d], e)
            }
        }
    },
    applyLoadResponse: function (a) {
        this.loadData(a)
    },
    applyResponse: function (a, b) {
        if (this.trackResponseType) {
            a = b.type || a
        }
        switch (a) {
            case"load":
                this.applyLoadResponse(b);
                break;
            case"sync":
                this.applySyncResponse(b);
                break
        }
    },
    getRequestId: function () {
        return Ext.Date.now()
    },
    onResponse: function (a, c, d) {
        this.activeRequests[a] = null;
        var b = this.decode(c);
        if (!b || !b.success) {
            this.fireEvent("requestfail", this, a, b, d);
            this.fireEvent(a + "fail", this, b, d);
            this.warn("CrudManager: " + a + " failed, please inspect the server response", c);
            return b
        }
        if ((this.fireEvent("beforeresponseapply", this, a, b) !== false) && (this.fireEvent("before" + a + "apply", this, b) !== false)) {
            this.revision = b.revision;
            this.applyResponse(a, b);
            this.fireEvent("requestdone", this, a, b, d);
            this.fireEvent(a, this, b, d);
            if (!this.hasChanges()) {
                this.fireEvent("nochanges", this)
            }
        }
        return b
    },
    onLoad: function (a, b) {
        return this.onResponse("load", a, b)
    },
    onSync: function (a, b) {
        return this.onResponse("sync", a, b)
    },
    load: function (e, a, d) {
        var b;
        if (typeof e === "object") {
            b = e;
            e = a;
            a = d;
            d = arguments[3]
        }
        var c = this.getLoadPackage(b);
        if (this.fireEvent("beforeload", this, c) !== false) {
            d = d || this;
            if (this.activeRequests.load) {
                this.cancelRequest(this.activeRequests.load.desc);
                this.fireEvent("loadcanceled", this, c)
            }
            this.activeRequests.load = {id: c.requestId};
            this.activeRequests.load.desc = this.sendRequest({
                data: this.encode(c),
                type: "load",
                success: function (g, h) {
                    var f = this.onLoad(g, h);
                    if (a && (!f || !f.success)) {
                        a.call(d, f, g)
                    } else {
                        if (e) {
                            e.call(d, f, g)
                        }
                    }
                },
                failure: function (f, g) {
                    this.onLoad(f, g);
                    if (a) {
                        a.apply(d, arguments)
                    }
                },
                scope: this
            })
        } else {
            this.fireEvent("loadcanceled", this, c)
        }
    },
    sync: function (d, a, c) {
        if (this.activeRequests.sync) {
            this.delayedSyncs.push(arguments);
            this.fireEvent("syncdelayed", this, arguments);
            return
        }
        var b = this.getChangeSetPackage();
        c = c || this;
        if (!b) {
            if (d) {
                d.call(c, null, null)
            }
            return
        }
        if (this.fireEvent("beforesync", this, b) === false) {
            this.fireEvent("synccanceled", this, b);
            return
        }
        this.activeRequests.sync = {id: b.requestId};
        this.activeRequests.sync.desc = this.sendRequest({
            data: this.encode(b), type: "sync", success: function (h, f) {
                var g = this.activeRequests.sync;
                var e = this.onSync(h, f);
                if (a && (!e || !e.success)) {
                    a.call(c, e, h, g)
                } else {
                    if (d) {
                        d.call(c, e, h, g)
                    }
                }
                this.runDelayedSync()
            }, failure: function (f, e) {
                this.onSync(f, e);
                if (a) {
                    a.apply(c, arguments)
                }
                this.runDelayedSync()
            }, scope: this
        })
    },
    runDelayedSync: function () {
        var a = this.delayedSyncs.shift();
        if (!a) {
            return
        }
        this.sync.apply(this, a)
    },
    commit: function () {
        for (var b = 0, a = this.stores.length; b < a; b++) {
            this.stores[b].store.commitChanges()
        }
    },
    reject: function () {
        for (var b = 0, a = this.stores.length; b < a; b++) {
            this.stores[b].store.rejectChanges()
        }
    },
    warn: function () {
        if ("console"in window) {
            var a = console;
            a.log && a.log.apply && a.log.apply(a, arguments)
        }
    },
    isLoading: function () {
        return !!this.activeRequests.load
    }
});
Ext.define("Sch.crud.transport.Ajax", {
    defaultMethod: {load: "GET", sync: "POST"}, cancelRequest: function (a) {
        Ext.Ajax.abort(a)
    }, sendRequest: function (b) {
        var c = b.data, d = this.transport[b.type], e = d.paramName, f = Ext.apply({}, d && d.params), g = d.method || this.defaultMethod[b.type];
        var a = Ext.apply({
            url: d.url, method: g, params: f, failure: b.failure, success: function (h, i) {
                if (b.success) {
                    b.success.call(b.scope || this, h.responseXml || h.responseText)
                }
            }, scope: b.scope
        }, d.requestConfig);
        if (!e) {
            if (this.format === "xml") {
                Ext.apply(a, {xmlData: c})
            } else {
                Ext.apply(a, {jsonData: c})
            }
        } else {
            a.params = a.params || {};
            a.params[e] = c
        }
        this.fireEvent("beforesend", this, f, b.type, a);
        return Ext.Ajax.request(a)
    }
});
Ext.define("Sch.crud.encoder.Json", {
    format: "json", encode: function (a) {
        return Ext.JSON.encode(a)
    }, decode: function (a) {
        if (typeof a == "object") {
            return a
        }
        return Ext.JSON.decode(a, true)
    }
});
Ext.define("Sch.crud.encoder.Xml", {
    requires: ["Ext.XTemplate"],
    format: "xml",
    stringReplaces: [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/"/g, "&quot;"]],
    encodeString: function (e) {
        if (!e) {
            return e
        }
        var a = e.toString(), c = this.stringReplaces;
        for (var d = 0, b = c.length; d < b; d++) {
            a = a.replace(c[d][0], c[d][1])
        }
        return a
    },
    encodeRecords: function (c) {
        var a = "";
        for (var d = 0, b = c.length; d < b; d++) {
            a += this.encodeRecord(c[d])
        }
        return a
    },
    encodeRecord: function (b) {
        var a = "<record>";
        for (var c in b) {
            var d = b[c];
            a += '<field id="' + this.encodeString(c) + '">' + (d && d.$store ? this.encodeStoreChanges({storeId: c}, d) : this.encodeString(d)) + "</field>"
        }
        a += "</record>";
        return a
    },
    encodeStoreChanges: function (b, c) {
        var a = '<store id="' + this.encodeString(b.storeId) + '">';
        if (c.added) {
            a += "<added>" + this.encodeRecords(c.added) + "</added>"
        }
        if (c.updated) {
            a += "<updated>" + this.encodeRecords(c.updated) + "</updated>"
        }
        if (c.removed) {
            a += "<removed>" + this.encodeRecords(c.removed) + "</removed>"
        }
        a += "</store>";
        return a
    },
    encode: function (e) {
        var a, d, b, c;
        switch (e.type) {
            case"load":
                a = '<load requestId="' + this.encodeString(e.requestId) + '">';
                for (d = 0, b = e.stores.length; d < b; d++) {
                    c = e.stores[d];
                    if (typeof c === "string") {
                        a += '<store id="' + this.encodeString(c) + '"/>'
                    } else {
                        a += '<store id="' + this.encodeString(c.storeId) + '" page="' + this.encodeString(c.page) + '" pageSize="' + this.encodeString(c.pageSize) + '"/>'
                    }
                }
                a += "</load>";
                return a;
            case"sync":
                a = '<sync requestId="' + this.encodeString(e.requestId) + '" revision="' + this.encodeString(e.revision) + '">';
                for (d in e) {
                    if (e.hasOwnProperty(d)) {
                        c = this.getStore(d);
                        if (c) {
                            a += this.encodeStoreChanges(c, e[d])
                        }
                    }
                }
                a += "</sync>";
                break
        }
        return a
    },
    stringToXML: function (b) {
        if (!b) {
            return
        }
        var a;
        if (window.DOMParser) {
            a = (new DOMParser()).parseFromString(b, "text/xml")
        } else {
            if (window.ActiveXObject) {
                a = new ActiveXObject("Microsoft.XMLDOM");
                a.async = false;
                a.loadXML(b)
            }
        }
        return a
    },
    decodeRecords: function (d) {
        var b = [];
        for (var c = 0, a = d.length; c < a; c++) {
            b.push(this.decodeRecord(d[c]))
        }
        return b
    },
    decodeRecord: function (f) {
        var b = f.childNodes, a = {}, g;
        for (var e = 0, c = b.length; e < c; e++) {
            var h = b[e];
            if (h.nodeName == "field") {
                g = "";
                if (h.firstChild) {
                    var d = this.getElementByTagName(h, "store");
                    g = d ? this.decodeStore(d) : h.firstChild.nodeValue
                }
                a[h.getAttribute("id")] = g
            }
        }
        return a
    },
    getElementsByTagName: function (f, c) {
        var e = f.childNodes, b = [];
        for (var d = 0, a = e.length; d < a; d++) {
            if (e[d].nodeName == c) {
                b.push(e[d])
            }
        }
        return b
    },
    getElementByTagName: function (e, b) {
        var d = e.childNodes;
        for (var c = 0, a = d.length; c < a; c++) {
            if (d[c].nodeName == b) {
                return d[c]
            }
        }
    },
    decodeStore: function (a) {
        var d = {}, c = this.getElementsByTagName(a, "rows");
        if (c.length) {
            d.rows = this.decodeRecords(this.getElementsByTagName(c[0], "record"));
            var b = parseInt(c[0].getAttribute("total"), 10);
            if (isNaN(b) || b < d.rows.length) {
                b = d.rows.length
            }
            d.total = b
        }
        var e = this.getElementByTagName(a, "removed");
        if (e) {
            d.removed = this.decodeRecords(this.getElementsByTagName(e, "record"))
        }
        return d
    },
    decode: function (a) {
        var d = typeof a == "string" ? this.stringToXML(a) : a;
        if (!d) {
            return
        }
        var k = {}, e = d.documentElement, g = e.getElementsByTagName("store"), f, h;
        k.requestId = e.getAttribute("requestId");
        k.revision = e.getAttribute("revision");
        k.success = e.getAttribute("success") || "false";
        k.success = k.success.toLowerCase() == "true";
        if (!k.success) {
            k.code = e.getAttribute("code");
            var j = e.getElementsByTagName("message")[0];
            k.message = j && j.firstChild && j.firstChild.nodeValue
        }
        for (var c = 0, b = g.length; c < b; c++) {
            f = g[c];
            h = f.getAttribute("id");
            if (this.getStore(h)) {
                k[h] = this.decodeStore(f)
            }
        }
        return k
    }
});
Ext.define("Sch.util.Date", {
    requires: "Ext.Date",
    mixins: ["Sch.mixin.Localizable"],
    singleton: true,
    stripEscapeRe: /(\\.)/g,
    hourInfoRe: /([gGhHisucUOPZ]|MS)/,
    unitHash: null,
    unitsByName: {},
    constructor: function () {
        var a = Ext.Date;
        var c = this.unitHash = {
            MILLI: a.MILLI,
            SECOND: a.SECOND,
            MINUTE: a.MINUTE,
            HOUR: a.HOUR,
            DAY: a.DAY,
            WEEK: "w",
            MONTH: a.MONTH,
            QUARTER: "q",
            YEAR: a.YEAR
        };
        Ext.apply(this, c);
        var b = this;
        this.units = [b.MILLI, b.SECOND, b.MINUTE, b.HOUR, b.DAY, b.WEEK, b.MONTH, b.QUARTER, b.YEAR]
    },
    onLocalized: function () {
        this.setUnitNames(this.L("unitNames"))
    },
    setUnitNames: function (f, b) {
        var e = this.unitsByName = {};
        this.l10n.unitNames = f;
        this._unitNames = Ext.apply({}, f);
        var c = this.unitHash;
        for (var a in c) {
            if (c.hasOwnProperty(a)) {
                var d = c[a];
                this._unitNames[d] = this._unitNames[a];
                e[a] = d;
                e[d] = d
            }
        }
    },
    betweenLesser: function (b, d, a) {
        var c = b.getTime();
        return d.getTime() <= c && c < a.getTime()
    },
    constrain: function (b, c, a) {
        return this.min(this.max(b, c), a)
    },
    compareUnits: function (c, b) {
        var a = Ext.Array.indexOf(this.units, c), d = Ext.Array.indexOf(this.units, b);
        return a > d ? 1 : (a < d ? -1 : 0)
    },
    isUnitGreater: function (b, a) {
        return this.compareUnits(b, a) > 0
    },
    copyTimeValues: function (b, a) {
        b.setHours(a.getHours());
        b.setMinutes(a.getMinutes());
        b.setSeconds(a.getSeconds());
        b.setMilliseconds(a.getMilliseconds())
    },
    add: function (b, c, e) {
        var f = Ext.Date.clone(b);
        if (!c || e === 0) {
            return f
        }
        switch (c.toLowerCase()) {
            case this.MILLI:
                f = new Date(b.getTime() + e);
                break;
            case this.SECOND:
                f = new Date(b.getTime() + (e * 1000));
                break;
            case this.MINUTE:
                f = new Date(b.getTime() + (e * 60000));
                break;
            case this.HOUR:
                f = new Date(b.getTime() + (e * 3600000));
                break;
            case this.DAY:
                f.setDate(b.getDate() + e);
                if (f.getHours() === 23 && b.getHours() === 0) {
                    f = Ext.Date.add(f, Ext.Date.HOUR, 1)
                }
                break;
            case this.WEEK:
                f.setDate(b.getDate() + e * 7);
                break;
            case this.MONTH:
                var a = b.getDate();
                if (a > 28) {
                    a = Math.min(a, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(b), this.MONTH, e)).getDate())
                }
                f.setDate(a);
                f.setMonth(f.getMonth() + e);
                break;
            case this.QUARTER:
                f = this.add(b, this.MONTH, e * 3);
                break;
            case this.YEAR:
                f.setFullYear(b.getFullYear() + e);
                break
        }
        return f
    },
    getUnitDurationInMs: function (a) {
        return this.add(new Date(1, 0, 1), a, 1) - new Date(1, 0, 1)
    },
    getMeasuringUnit: function (a) {
        if (a === this.WEEK) {
            return this.DAY
        }
        return a
    },
    getDurationInUnit: function (e, a, c, d) {
        var b;
        switch (c) {
            case this.YEAR:
                b = this.getDurationInYears(e, a);
                break;
            case this.QUARTER:
                b = this.getDurationInMonths(e, a) / 3;
                break;
            case this.MONTH:
                b = this.getDurationInMonths(e, a);
                break;
            case this.WEEK:
                b = this.getDurationInDays(e, a) / 7;
                break;
            case this.DAY:
                b = this.getDurationInDays(e, a);
                break;
            case this.HOUR:
                b = this.getDurationInHours(e, a);
                break;
            case this.MINUTE:
                b = this.getDurationInMinutes(e, a);
                break;
            case this.SECOND:
                b = this.getDurationInSeconds(e, a);
                break;
            case this.MILLI:
                b = this.getDurationInMilliseconds(e, a);
                break
        }
        return d ? b : Math.round(b)
    },
    getUnitToBaseUnitRatio: function (b, a) {
        if (b === a) {
            return 1
        }
        switch (b) {
            case this.YEAR:
                switch (a) {
                    case this.QUARTER:
                        return 1 / 4;
                    case this.MONTH:
                        return 1 / 12
                }
                break;
            case this.QUARTER:
                switch (a) {
                    case this.YEAR:
                        return 4;
                    case this.MONTH:
                        return 1 / 3
                }
                break;
            case this.MONTH:
                switch (a) {
                    case this.YEAR:
                        return 12;
                    case this.QUARTER:
                        return 3
                }
                break;
            case this.WEEK:
                switch (a) {
                    case this.DAY:
                        return 1 / 7;
                    case this.HOUR:
                        return 1 / 168
                }
                break;
            case this.DAY:
                switch (a) {
                    case this.WEEK:
                        return 7;
                    case this.HOUR:
                        return 1 / 24;
                    case this.MINUTE:
                        return 1 / 1440
                }
                break;
            case this.HOUR:
                switch (a) {
                    case this.DAY:
                        return 24;
                    case this.MINUTE:
                        return 1 / 60
                }
                break;
            case this.MINUTE:
                switch (a) {
                    case this.HOUR:
                        return 60;
                    case this.SECOND:
                        return 1 / 60;
                    case this.MILLI:
                        return 1 / 60000
                }
                break;
            case this.SECOND:
                switch (a) {
                    case this.MILLI:
                        return 1 / 1000
                }
                break;
            case this.MILLI:
                switch (a) {
                    case this.SECOND:
                        return 1000
                }
                break
        }
        return -1
    },
    getDurationInMilliseconds: function (b, a) {
        return (a - b)
    },
    getDurationInSeconds: function (b, a) {
        return (a - b) / 1000
    },
    getDurationInMinutes: function (b, a) {
        return (a - b) / 60000
    },
    getDurationInHours: function (b, a) {
        return (a - b) / 3600000
    },
    getDurationInDays: function (c, b) {
        var a = c.getTimezoneOffset() - b.getTimezoneOffset();
        return (b - c + a * 60 * 1000) / 86400000
    },
    getDurationInMonths: function (b, a) {
        return ((a.getFullYear() - b.getFullYear()) * 12) + (a.getMonth() - b.getMonth())
    },
    getDurationInYears: function (b, a) {
        return this.getDurationInMonths(b, a) / 12
    },
    min: function (b, a) {
        return b < a ? b : a
    },
    max: function (b, a) {
        return b > a ? b : a
    },
    intersectSpans: function (c, d, b, a) {
        return this.betweenLesser(c, b, a) || this.betweenLesser(b, c, d)
    },
    getNameOfUnit: function (a) {
        a = this.getUnitByName(a);
        switch (a.toLowerCase()) {
            case this.YEAR:
                return "YEAR";
            case this.QUARTER:
                return "QUARTER";
            case this.MONTH:
                return "MONTH";
            case this.WEEK:
                return "WEEK";
            case this.DAY:
                return "DAY";
            case this.HOUR:
                return "HOUR";
            case this.MINUTE:
                return "MINUTE";
            case this.SECOND:
                return "SECOND";
            case this.MILLI:
                return "MILLI"
        }
        throw"Incorrect UnitName"
    },
    getReadableNameOfUnit: function (b, a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        return this._unitNames[b][a ? "plural" : "single"]
    },
    getShortNameOfUnit: function (a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        return this._unitNames[a].abbrev
    },
    getUnitByName: function (a) {
        if (!this.isLocaleApplied()) {
            this.applyLocale()
        }
        if (!this.unitsByName[a]) {
            Ext.Error.raise("Unknown unit name: " + a)
        }
        return this.unitsByName[a]
    },
    getNext: function (c, g, a, f) {
        var e = Ext.Date.clone(c);
        f = arguments.length < 4 ? 1 : f;
        a = a == null ? 1 : a;
        switch (g) {
            case this.MILLI:
                e = this.add(c, g, a);
                break;
            case this.SECOND:
                e = this.add(c, g, a);
                if (e.getMilliseconds() > 0) {
                    e.setMilliseconds(0)
                }
                break;
            case this.MINUTE:
                e = this.add(c, g, a);
                if (e.getSeconds() > 0) {
                    e.setSeconds(0)
                }
                if (e.getMilliseconds() > 0) {
                    e.setMilliseconds(0)
                }
                break;
            case this.HOUR:
                e = this.add(c, g, a);
                if (e.getMinutes() > 0) {
                    e.setMinutes(0)
                }
                if (e.getSeconds() > 0) {
                    e.setSeconds(0)
                }
                if (e.getMilliseconds() > 0) {
                    e.setMilliseconds(0)
                }
                break;
            case this.DAY:
                var d = c.getHours() === 23 && this.add(e, this.HOUR, 1).getHours() === 1;
                if (d) {
                    e = this.add(e, this.DAY, 2);
                    this.clearTime(e);
                    return e
                }
                this.clearTime(e);
                e = this.add(e, this.DAY, a);
                if (e.getHours() === 1) {
                    this.clearTime(e)
                }
                break;
            case this.WEEK:
                this.clearTime(e);
                var b = e.getDay();
                e = this.add(e, this.DAY, f - b + 7 * (a - (f <= b ? 0 : 1)));
                if (e.getDay() !== f) {
                    e = this.add(e, this.HOUR, 1)
                } else {
                    this.clearTime(e)
                }
                break;
            case this.MONTH:
                e = this.add(e, this.MONTH, a);
                e.setDate(1);
                this.clearTime(e);
                break;
            case this.QUARTER:
                e = this.add(e, this.MONTH, ((a - 1) * 3) + (3 - (e.getMonth() % 3)));
                this.clearTime(e);
                e.setDate(1);
                break;
            case this.YEAR:
                e = new Date(e.getFullYear() + a, 0, 1);
                break;
            default:
                throw"Invalid date unit"
        }
        return e
    },
    getNumberOfMsFromTheStartOfDay: function (a) {
        return a - this.clearTime(a, true) || 86400000
    },
    getNumberOfMsTillTheEndOfDay: function (a) {
        return this.getStartOfNextDay(a, true) - a
    },
    getStartOfNextDay: function (b, f, e) {
        var d = this.add(e ? b : this.clearTime(b, f), this.DAY, 1);
        if (d.getDate() == b.getDate()) {
            var c = this.add(this.clearTime(b, f), this.DAY, 2).getTimezoneOffset();
            var a = b.getTimezoneOffset();
            d = this.add(d, this.MINUTE, a - c)
        }
        return d
    },
    getEndOfPreviousDay: function (b, c) {
        var a = c ? b : this.clearTime(b, true);
        if (a - b) {
            return a
        } else {
            return this.add(a, this.DAY, -1)
        }
    },
    timeSpanContains: function (c, b, d, a) {
        return (d - c) >= 0 && (b - a) >= 0
    },
    compareWithPrecision: function (e, c, f) {
        var d = Sch.util.Date, b = Ext.Date, a;
        switch (f) {
            case d.DAY:
                e = Number(b.format(e, "Ymd"));
                c = Number(b.format(c, "Ymd"));
                break;
            case d.WEEK:
                e = Number(b.format(e, "YmW"));
                c = Number(b.format(c, "YmW"));
                break;
            case d.MONTH:
                e = Number(b.format(e, "Ym"));
                c = Number(b.format(c, "Ym"));
                break;
            case d.QUARTER:
                e = e.getFullYear() * 4 + Math.floor(e.getMonth() / 3);
                c = c.getFullYear() * 4 + Math.floor(c.getMonth() / 3);
                break;
            case d.YEAR:
                e = e.getFullYear();
                c = c.getFullYear();
                break;
            default:
            case d.MILLI:
            case d.SECOND:
            case d.MINUTE:
            case d.HOUR:
                f = f && this.getUnitDurationInMs(f) || 1;
                e = Math.floor(e.valueOf() / f);
                c = Math.floor(c.valueOf() / f);
                break
        }
        ((e < c) && (a = -1)) || ((e > c) && (a = +1)) || (a = 0);
        return a
    },
    getValueInUnits: function (a, b) {
        switch (b) {
            case this.MONTH:
                return a.getMonth();
            case this.DAY:
                return a.getDate();
            case this.HOUR:
                return a.getHours();
            case this.MINUTE:
                return a.getMinutes();
            case this.SECOND:
                return a.getSeconds()
        }
    },
    setValueInUnits: function (b, c, e) {
        var a = Ext.Date.clone(b), d;
        switch (c) {
            case this.YEAR:
                d = "setFullYear";
                break;
            case this.MONTH:
                d = "setMonth";
                break;
            case this.DAY:
                d = "setDate";
                break;
            case this.HOUR:
                d = "setHours";
                break;
            case this.MINUTE:
                d = "setMinutes";
                break;
            case this.SECOND:
                d = "setSeconds";
                break;
            case this.MILLI:
                d = "setMilliseconds";
                break
        }
        a[d](e);
        return a
    },
    getSubUnit: function (a) {
        switch (a) {
            case this.YEAR:
                return this.MONTH;
            case this.MONTH:
                return this.DAY;
            case this.DAY:
                return this.HOUR;
            case this.HOUR:
                return this.MINUTE;
            case this.MINUTE:
                return this.SECOND;
            case this.SECOND:
                return this.MILLI
        }
    },
    setValueInSubUnits: function (a, b, c) {
        b = this.getSubUnit(b);
        return this.setValueInUnits(a, b, c)
    },
    mergeDates: function (c, b, a) {
        var d = Ext.Date.clone(c);
        switch (a) {
            case this.YEAR:
                d.setFullYear(b.getFullYear());
            case this.MONTH:
                d.setMonth(b.getMonth());
            case this.WEEK:
            case this.DAY:
                if (a === this.WEEK) {
                    d = this.add(d, this.DAY, b.getDay() - d.getDay())
                } else {
                    d.setDate(b.getDate())
                }
            case this.HOUR:
                d.setHours(b.getHours());
            case this.MINUTE:
                d.setMinutes(b.getMinutes());
            case this.SECOND:
                d.setSeconds(b.getSeconds());
            case this.MILLI:
                d.setMilliseconds(b.getMilliseconds())
        }
        return d
    },
    splitToSubUnits: function (d, c, a, b) {
        a = a || 1;
        b = arguments.length < 4 ? 1 : b;
        switch (c) {
            case this.MONTH:
                return this.splitMonth(d, a, b);
            case this.WEEK:
            case this.DAY:
                return this.splitDay(d, a);
            default:
                break
        }
    },
    splitYear: function (e, c) {
        var b = this.clearTime(e, true);
        b.setMonth(0);
        b.setDate(1);
        var a = [];
        for (var d = 0; d <= 12; d = d + c) {
            a.push(this.add(b, this.MONTH, d))
        }
        return a
    },
    splitMonth: function (h, c, g) {
        var b = this.clearTime(h, true);
        b.setDate(1);
        b = this.add(b, this.DAY, g - b.getDay());
        var d = Ext.Date.clone(b);
        var f = this.add(b, this.MONTH, 1);
        var a = [];
        for (var e = 0; d.getTime() < f.getTime(); e = e + c) {
            d = this.add(b, this.WEEK, e);
            a.push(d)
        }
        return a
    },
    splitWeek: function (f, c, e) {
        var b = this.add(f, this.DAY, e - f.getDay());
        b = this.clearTime(b);
        var a = [];
        for (var d = 0; d <= 7; d = d + c) {
            a.push(this.add(b, this.DAY, d))
        }
        return a
    },
    splitDay: function (e, b) {
        var d = this.clearTime(e, true);
        var a = [];
        for (var c = 0; c <= 24; c = c + b) {
            a.push(this.add(d, this.HOUR, c))
        }
        return a
    },
    splitHour: function (e, b) {
        var d = new Date(e.getTime());
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        var a = [];
        for (var c = 0; c <= 60; c = c + b) {
            a.push(this.add(d, this.MINUTE, c))
        }
        return a
    },
    splitMinute: function (e, b) {
        var d = Ext.Date.clone(e);
        d.setSeconds(0);
        d.setMilliseconds(0);
        var a = [];
        for (var c = 0; c <= 60; c = c + b) {
            a.push(this.add(d, this.SECOND, c))
        }
        return a
    },
    clearTime: function (a, b) {
        if (a.getHours() > 0 || a.getMinutes() > 0 || a.getSeconds() > 0) {
            return Ext.Date.clearTime(a, b)
        }
        return b ? Ext.Date.clone(a) : a
    }
});
Ext.define("Sch.util.DragTracker", {
    extend: "Ext.dd.DragTracker",
    requires: ["Ext.util.Region"],
    xStep: 1,
    yStep: 1,
    deferredActivation: 0,
    constructor: function () {
        this.callParent(arguments);
        this.on("dragstart", function () {
            var b = this.el;
            var a = {scroll: this.onMouseMove, pinchstart: this.onMouseUp, scope: this};
            b.on(a);
            this.on("dragend", function () {
                b.un(a)
            }, this, {single: true})
        });
        this.moveListener = {
            pinchstart: this.abortWait,
            touchend: this.abortWait,
            mouseup: this.abortWait,
            mousemove: this.onMoveWhileWaiting,
            scope: this,
            capture: true
        }
    },
    setXStep: function (a) {
        this.xStep = a
    },
    startScroll: null,
    deferTimer: null,
    deferTolerance: 10,
    moveListener: null,
    setYStep: function (a) {
        this.yStep = a
    },
    onMoveWhileWaiting: function (d, a) {
        var c = d.getXY();
        var b = this.startXY;
        if (Math.max(Math.abs(b[0] - c[0]), Math.abs(b[1] - c[1])) > this.deferTolerance) {
            this.abortWait();
            this.onMouseUp(d)
        }
    },
    abortWait: function () {
        clearTimeout(this.deferTimer);
        this.deferTimer = null;
        Ext.getDoc().un(this.moveListener)
    },
    getRegion: function () {
        var j = this.startXY, f = this.el.getScroll(), l = this.getXY(), c = l[0], b = l[1], h = f.left - this.startScroll.left, m = f.top - this.startScroll.top, i = j[0] - h, g = j[1] - m, e = Math.min(i, c), d = Math.min(g, b), a = Math.abs(i - c), k = Math.abs(g - b);
        return new Ext.util.Region(d, e + a, d + k, e)
    },
    onMouseDown: function (c, b) {
        if (c.event.touches && c.event.touches.length > 1) {
            return
        }
        c.stopPropagation = Ext.emptyFn;
        this.startXY = c.getXY();
        if (this.deferredActivation) {
            var a = this;
            Ext.getDoc().on(this.moveListener);
            this.deferTimer = setTimeout(function () {
                var d = a.deferredActivation;
                Ext.getDoc().un(a.moveListener);
                a.deferredActivation = false;
                a.onMouseDown(c, b);
                a.deferredActivation = d
            }, this.deferredActivation);
            return
        }
        this.callParent([c, b]);
        this.lastXY = this.startXY;
        this.startScroll = this.el.getScroll()
    },
    onMouseMove: function (g, f) {
        if (this.active && g.type === "mousemove" && Ext.isIE9m && !g.browserEvent.button) {
            g.preventDefault();
            this.onMouseUp(g);
            return
        }
        g.preventDefault();
        var d = g.type === "scroll" ? this.lastXY : g.getXY(), b = this.startXY;
        if (!this.active) {
            if (Math.max(Math.abs(b[0] - d[0]), Math.abs(b[1] - d[1])) > this.tolerance) {
                this.triggerStart(g)
            } else {
                return
            }
        }
        var a = d[0], h = d[1];
        if (this.xStep > 1) {
            a -= this.startXY[0];
            a = Math.round(a / this.xStep) * this.xStep;
            a += this.startXY[0]
        }
        if (this.yStep > 1) {
            h -= this.startXY[1];
            h = Math.round(h / this.yStep) * this.yStep;
            h += this.startXY[1]
        }
        var c = this.xStep > 1 || this.yStep > 1;
        if (!c || a !== d[0] || h !== d[1]) {
            this.lastXY = [a, h];
            if (this.fireEvent("mousemove", this, g) === false) {
                this.onMouseUp(g)
            } else {
                this.onDrag(g);
                this.fireEvent("drag", this, g)
            }
        }
    }
});
Ext.define("Sch.util.ScrollManager", {
    singleton: true,
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 200,
    activeCmp: null,
    activeEl: null,
    targetScroller: null,
    scrollElRegion: null,
    scrollProcess: {},
    pt: null,
    scrollWidth: null,
    scrollHeight: null,
    direction: "both",
    constructor: function () {
        this.doScroll = Ext.Function.bind(this.doScroll, this)
    },
    triggerRefresh: function () {
        if (this.activeEl) {
            this.refreshElRegion();
            this.clearScrollInterval();
            this.onMouseMove()
        }
    },
    doScroll: function () {
        var f = this.scrollProcess, e = f.cmp, d = f.dir[0], b = this.increment, h = this.activeCmp.getScrollX(), g = this.activeCmp.getScrollY();
        if (d === "r") {
            b = Math.min(b, this.scrollWidth - h - this.activeEl.dom.clientWidth)
        } else {
            if (d === "d") {
                b = Math.min(b, this.scrollHeight - g - this.activeEl.dom.clientHeight)
            }
        }
        b = Math.max(b, 0);
        var c = 0, a = 0;
        if (d === "r") {
            c = b
        }
        if (d === "l") {
            c = -b
        }
        if (d === "u") {
            a = -b
        }
        if (d === "d") {
            a = b
        }
        e.scrollBy(c, a, {duration: this.animDuration, callback: this.triggerRefresh, scope: this})
    },
    clearScrollInterval: function () {
        var a = this.scrollProcess;
        if (a.id) {
            clearTimeout(a.id)
        }
        a.id = 0;
        a.cmp = null;
        a.dir = ""
    },
    isScrollAllowed: function (a) {
        switch (this.direction) {
            case"both":
                return true;
            case"horizontal":
                return a === "right" || a === "left";
            case"vertical":
                return a === "up" || a === "down";
            default:
                throw"Invalid direction: " + this.direction
        }
    },
    startScrollInterval: function (b, a) {
        if (!this.isScrollAllowed(a)) {
            return
        }
        this.clearScrollInterval();
        this.scrollProcess.cmp = b;
        this.scrollProcess.dir = a;
        this.scrollProcess.id = setTimeout(this.doScroll, this.frequency)
    },
    onMouseMove: function (g) {
        var n = g ? g.getPoint() : this.pt, m = n.x, l = n.y, h = this.scrollProcess, d = this.activeCmp.getScrollX(), c = this.activeCmp.getScrollY(), a, k = this.activeCmp, b = this.activeEl, j = this.scrollElRegion, f = b.dom, i = this;
        this.pt = n;
        if (j && j.contains(n) && b.isScrollable()) {
            if (j.bottom - l <= i.vthresh && (this.scrollHeight - c - f.clientHeight > 0)) {
                if (h.cmp != k) {
                    this.startScrollInterval(this.activeCmp, "down")
                }
                return
            } else {
                if (j.right - m <= i.hthresh && (this.scrollWidth - d - f.clientWidth > 0)) {
                    if (h.cmp != k) {
                        this.startScrollInterval(this.activeCmp, "right")
                    }
                    return
                } else {
                    if (l - j.top <= i.vthresh && c > 0) {
                        if (h.cmp != k) {
                            this.startScrollInterval(this.activeCmp, "up")
                        }
                        return
                    } else {
                        if (m - j.left <= i.hthresh && d > 0) {
                            if (h.cmp != k) {
                                this.startScrollInterval(this.activeCmp, "left")
                            }
                            return
                        }
                    }
                }
            }
        }
        this.clearScrollInterval()
    },
    refreshElRegion: function () {
        this.scrollElRegion = this.activeEl.getRegion()
    },
    activate: function (a, b) {
        this.direction = b || "both";
        this.activeCmp = a;
        this.activeEl = a.getEl();
        if (a.scrollManager) {
            this.targetScroller = a.scrollManager.scroller;
            this.scrollWidth = this.targetScroller.getMaxPosition().x;
            this.scrollHeight = this.targetScroller.getMaxPosition().y
        } else {
            this.scrollWidth = this.activeEl.dom.scrollWidth;
            this.scrollHeight = this.activeEl.dom.scrollHeight
        }
        this.refreshElRegion();
        this.activeEl.on("mousemove", this.onMouseMove, this)
    },
    deactivate: function () {
        this.clearScrollInterval();
        this.activeEl.un("mousemove", this.onMouseMove, this);
        this.targetScroller = this.activeEl = this.activeCmp = this.scrollElRegion = this.scrollWidth = this.scrollHeight = null;
        this.direction = "both"
    }
});
Ext.define("Sch.util.Cache", {
    cache: null, constructor: function () {
        this.cache = {}
    }, key: function (b) {
        var a;
        if (b instanceof Ext.data.Model) {
            a = b.getId().toString()
        } else {
            if (b === undefined || b === null) {
                a = "[ undefined / null ]"
            } else {
                a = (b).toString()
            }
        }
        return a
    }, get: function (b, c) {
        var d = this, a;
        b = d.key(b);
        a = d.cache.hasOwnProperty(b) && d.cache[b];
        if (!a && c) {
            a = c()
        } else {
            if (!a) {
                a = []
            }
        }
        d.cache[b] = a;
        return a
    }, add: function (c, b) {
        var d = this, a = d.key(c);
        if (!d.cache.hasOwnProperty(a)) {
            d.cache[a] = d.get(c)
        }
        Ext.Array.include(d.cache[a], b);
        return d
    }, remove: function (b, a) {
        var c = this;
        b = c.key(b);
        if (c.cache.hasOwnProperty(b)) {
            Ext.Array.remove(c.cache[b], a)
        }
        return c
    }, move: function (c, d, a) {
        var b = this;
        c = b.key(c);
        d = b.key(d);
        if (c != d && arguments.length >= 3) {
            b.remove(c, a);
            b.add(d, a)
        } else {
            if (c != d && b.cache.hasOwnProperty(c) && b.cache.hasOwnProperty(d)) {
                b.cache[d] = Ext.Array.union(b.cache[d], b.cache[c]);
                b.cache[c] = []
            } else {
                if (c != d && b.cache.hasOwnProperty(c)) {
                    b.cache[d] = b.cache[c];
                    b.cache[c] = []
                }
            }
        }
    }, clear: function (a) {
        var b = this;
        if (!arguments.length) {
            b.cache = {}
        } else {
            a = b.key(a);
            if (b.cache.hasOwnProperty(a)) {
                delete b.cache[a]
            }
        }
        return b
    }, uncache: function (b) {
        var c = this, a;
        for (a in c.cache) {
            if (c.cache.hasOwnProperty(a)) {
                c.cache[a] = Ext.Array.remove(c.cache[a], b)
            }
        }
        return c
    }
});
if (!Ext.ClassManager.get("Sch.model.Customizable")) {
    Ext.define("Sch.model.Customizable", {
        extend: "Ext.data.Model",
        customizableFields: null,
        previous: null,
        __editing: null,
        __editCounter: 0,
        constructor: function () {
            var a = this.callParent(arguments);
            return a
        },
        onClassExtended: function (b, d, a) {
            var c = a.onBeforeCreated;
            a.onBeforeCreated = function (n, i) {
                c.apply(this, arguments);
                var j = n.prototype;
                if (!j.customizableFields) {
                    return
                }
                j.customizableFields = (n.superclass.customizableFields || []).concat(j.customizableFields);
                var g = j.customizableFields;
                var h = {};
                var l = this;
                var f = Ext.Array.findBy(n.fields, function (o) {
                    return o.name === j.idProperty
                });
                l.idField = j.idField = f;
                if (!n.fieldsMap[j.idProperty]) {
                    n.fieldsMap[j.idProperty] = f
                }
                Ext.Array.forEach(g, function (o) {
                    if (typeof o == "string") {
                        o = {name: o}
                    }
                    h[o.name] = o
                });
                var k = j.fields;
                var m = [];
                var e = [];
                Ext.Array.forEach(k, function (o) {
                    if (o.isCustomizableField) {
                        e.push(o.getName())
                    }
                });
                if (j.idProperty !== "id" && j.getField("id")) {
                    if (!j.getField("id").hasOwnProperty("name")) {
                        e.push("id")
                    }
                }
                if (j.idProperty !== "Id" && j.getField("Id")) {
                    if (!j.getField("Id").hasOwnProperty("name")) {
                        e.push("Id")
                    }
                }
                n.removeFields(e);
                Ext.Object.each(h, function (o, r) {
                    r.isCustomizableField = true;
                    var s = r.name || r.getName();
                    var x = s === "Id" ? "idProperty" : s.charAt(0).toLowerCase() + s.substr(1) + "Field";
                    var t = j[x];
                    var w = t || s;
                    var v;
                    if (j.getField(w)) {
                        v = Ext.applyIf({name: s, isCustomizableField: true}, j.getField(w));
                        j.getField(w).isCustomizableField = true;
                        v = Ext.create("data.field." + (v.type || "auto"), v);
                        g.push(v)
                    } else {
                        v = Ext.applyIf({name: w, isCustomizableField: true}, r);
                        v = Ext.create("data.field." + (v.type || "auto"), v);
                        m.push(v)
                    }
                    var q = Ext.String.capitalize(s);
                    if (q != "Id") {
                        var u = "get" + q;
                        var p = "set" + q;
                        if (!j[u] || j[u].__getterFor__ && j[u].__getterFor__ != w) {
                            j[u] = function () {
                                return this.get(w)
                            };
                            j[u].__getterFor__ = w
                        }
                        if (!j[p] || j[p].__setterFor__ && j[p].__setterFor__ != w) {
                            j[p] = function (y) {
                                return this.set(w, y)
                            };
                            j[p].__setterFor__ = w
                        }
                    }
                });
                n.addFields(m)
            }
        },
        set: function (f, b) {
            var a;
            var d;
            this.previous = this.previous || {};
            if (typeof f === "string") {
                a = this.get(f);
                if (a instanceof Date && !(b instanceof Date)) {
                    b = this.getField(f).convert(b, this)
                }
                if ((a instanceof Date && (a - b)) || !(a instanceof Date) && a !== b) {
                    this.previous[f] = a
                } else {
                    return []
                }
            } else {
                for (var e in f) {
                    a = this.get(e);
                    var c = f[e];
                    if (a instanceof Date && !(c instanceof Date)) {
                        c = this.getField(e).convert(c, this)
                    }
                    if ((a instanceof Date && (a - c)) || !(a instanceof Date) && a !== c) {
                        this.previous[e] = a
                    }
                }
            }
            d = this.callParent(arguments);
            if (!this.__editing) {
                delete this.previous
            }
            return d
        },
        reject: function () {
            var b = this, a = b.modified || {}, c;
            b.__editing = true;
            b.previous = b.previous || {};
            for (c in a) {
                if (a.hasOwnProperty(c)) {
                    if (typeof a[c] != "function") {
                        b.previous[c] = b.get(c)
                    }
                }
            }
            b.callParent(arguments);
            delete b.previous;
            b.__editing = false
        },
        beginEdit: function () {
            this.__editCounter++;
            this.__editing = true;
            this.callParent(arguments)
        },
        cancelEdit: function () {
            this.__editCounter = 0;
            this.__editing = false;
            this.callParent(arguments);
            delete this.previous
        },
        endEdit: function (b, c) {
            if (--this.__editCounter === 0) {
                if (!b && this.getModifiedFieldNames) {
                    var a = this.editMemento;
                    if (!c) {
                        c = this.getModifiedFieldNames(a.data)
                    }
                    if (c && c.length === 0) {
                        b = true
                    }
                }
                this.callParent([b].concat(Array.prototype.slice.call(arguments, 1)));
                this.__editing = false;
                delete this.previous
            }
        }
    })
}
Ext.define("Sch.data.util.ResourceEventsCache", {
    extend: "Sch.util.Cache",
    requires: ["Ext.data.Model"],
    eventStore: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function (c) {
        var i = this, j = c.getResourceStore();
        i.callParent();
        function l(n, m) {
            Ext.Array.forEach(m, function (o) {
                i.add(o.getResourceId(), o)
            })
        }

        function e(n, m) {
            Ext.Array.forEach(m, function (o) {
                i.remove(o.getResourceId(), o)
            })
        }

        function d(o, r, n, q) {
            var s = r.resourceIdField, p = r.previous && s in r.previous, m = p && r.previous[s];
            if (n != Ext.data.Model.COMMIT && p) {
                i.move(m, r.getResourceId(), r)
            }
        }

        function g() {
            i.clear()
        }

        function k(n, m, o) {
            i.clear();
            a(m)
        }

        function h(n, o, p, m) {
            i.move(p, m)
        }

        function f(m, n) {
            Ext.Array.forEach(n, function (o) {
                i.clear(o)
            })
        }

        function b() {
            i.clear()
        }

        function a(m) {
            Ext.destroy(i.resourceStoreDetacher);
            i.resourceStoreDetacher = m && m.on({
                    idchanged: h,
                    remove: f,
                    clear: b,
                    cacheresethint: b,
                    rootchange: b,
                    priority: 100,
                    destroyable: true
                })
        }

        i.eventStoreDetacher = c.on({
            add: l,
            remove: e,
            update: d,
            clear: g,
            cacheresethint: g,
            rootchange: g,
            resourcestorechange: k,
            priority: 100,
            destroyable: true
        });
        i.eventStoreFiltersDetacher = c.getFilters().on("endupdate", g, this, {priority: 1002, destroyable: true});
        a(j);
        i.eventStore = c
    },
    destroy: function () {
        var a = this;
        Ext.destroyMembers(a, "eventStoreDetacher", "eventStoreFiltersDetacher", "resourceStoreDetacher");
        a.eventStore = null
    },
    get: function (a, b) {
        var c = this;
        a = c.key(a);
        b = b || function () {
                return Ext.Array.filter(c.eventStore.getRange(), function (d) {
                    return d.getResourceId() == a
                })
            };
        return c.callParent([a, b])
    }
});
Ext.define("Sch.data.util.EventAssignmentsCache", {
    extend: "Sch.util.Cache",
    requires: ["Ext.data.Model"],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    constructor: function (g) {
        var h = this, d = g.getEventStore();
        h.callParent();
        function j(n, m) {
            Ext.Array.forEach(m, function (o) {
                h.add(o.getEventId(), o)
            })
        }

        function b(n, m) {
            Ext.Array.forEach(m, function (o) {
                h.remove(o.getEventId(), o)
            })
        }

        function l(o, r, n) {
            var p = r.eventIdField, m = r.previous && p in r.previous, q = m && r.previous[p];
            if (n != Ext.data.Model.COMMIT && m) {
                h.move(q, r.getEventId(), r)
            }
        }

        function k(m) {
            h.clear()
        }

        function c(m, n) {
            h.clear();
            a(n)
        }

        function i(n, o, p, m) {
            h.move(p, m)
        }

        function e(n, m) {
            Ext.Array.forEach(m, function (o) {
                h.clear(o)
            })
        }

        function f() {
            h.clear()
        }

        function a(m) {
            Ext.destroy(h.eventStoreDetacher);
            h.eventStoreDetacher = m && m.on({
                    idchanged: i,
                    remove: e,
                    cacheresethint: f,
                    clear: f,
                    rootchange: f,
                    priority: 100,
                    destroyable: true
                })
        }

        h.assignmentStoreDetacher = g.on({
            add: j,
            remove: b,
            update: l,
            cacheresethint: k,
            clear: k,
            eventstorechange: c,
            priority: 100,
            destroyable: true
        });
        h.assignmentStoreFiltersDetacher = g.getFilters().on("endupdate", k, h, {priority: 1002, destroyable: true});
        a(d);
        h.assignmentStore = g
    },
    destroy: function () {
        var a = this;
        Ext.destroyMembers(a, "assignmentStoreDetacher", "eventStoreDetacher");
        a.assignmentStore = null
    },
    get: function (a, b) {
        var c = this;
        a = c.key(a);
        b = b || function () {
                return Ext.Array.filter(c.assignmentStore.getRange(), function (d) {
                    return d.getEventId() == a
                })
            };
        return c.callParent([a, b])
    }
});
Ext.define("Sch.data.util.ResourceAssignmentsCache", {
    extend: "Sch.util.Cache",
    requires: ["Ext.data.Model"],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function (h) {
        var j = this, f = h.getEventStore(), m = f && f.getResourceStore();
        j.callParent();
        function k(q, p) {
            Ext.Array.forEach(p, function (r) {
                j.add(r.getResourceId(), r)
            })
        }

        function b(q, p) {
            Ext.Array.forEach(p, function (r) {
                j.remove(r.getResourceId(), r)
            })
        }

        function o(r, u, q) {
            var t = u.resourceIdField, s = u.previous && t in u.previous, p = s && u.previous[t];
            if (q != Ext.data.Model.COMMIT && s) {
                j.move(p, u.getResourceId(), u)
            }
        }

        function l(p) {
            j.clear()
        }

        function c(p, q) {
            a(q);
            d(q && q.getResourceStore())
        }

        function n(p, q) {
            j.clear();
            d(q)
        }

        function i(q, r, s, p) {
            j.move(s, p)
        }

        function g(p, q) {
            Ext.Array.forEach(q, function (r) {
                j.clear(r)
            })
        }

        function e() {
            j.clear()
        }

        function a(p) {
            Ext.destroy(j.eventStoreDetacher);
            j.eventStoreDetacher = p && p.on({resourcestorechange: n, priority: 100, destroyable: true})
        }

        function d(p) {
            Ext.destroy(j.resourceStoreDetacher);
            j.resourceStoreDetacher = p && p.on({
                    idchanged: i,
                    remove: g,
                    clear: e,
                    cacheresethint: e,
                    rootchange: e,
                    priority: 100,
                    destroyable: true
                })
        }

        j.assignmentStoreDetacher = h.on({
            add: k,
            remove: b,
            update: o,
            clear: l,
            cacheresethint: l,
            eventstorechange: c,
            priority: 100,
            destroyable: true
        });
        j.assignmentStoreFiltersDetacher = h.getFilters().on("endupdate", l, j, {priority: 1002, destroyable: true});
        a(f);
        d(m);
        j.assignmentStore = h
    },
    destroy: function () {
        var a = this;
        Ext.destroyMembers(a, "assignmentStoreDetacher", "assignmentStoreFiltersDetacher", "eventStoreDetacher", "resourceStoreDetacher");
        a.assignmentStore = null
    },
    get: function (a, b) {
        var c = this;
        a = c.key(a);
        b = b || function () {
                return Ext.Array.filter(c.assignmentStore.getRange(), function (d) {
                    return d.getResourceId() == a
                })
            };
        return c.callParent([a, b])
    }
});
if (!Ext.ClassManager.get("Sch.data.util.AssignmentStoreEventResourcesCache")) {
    Ext.define("Sch.data.util.AssignmentStoreEventResourcesCache", {
        extend: "Sch.util.Cache",
        requires: ["Ext.data.Model"],
        assignmentStore: null,
        assignmentStoreDetacher: null,
        eventStoreDetacher: null,
        resourceStoreDetacher: null,
        constructor: function (j) {
            var k = this, f = j.getEventStore(), o = f && f.getResourceStore();
            k.callParent();
            function m(s, r) {
                var t = k.assignmentStore.getEventStore(), u = t && t.getResourceStore();
                Ext.Array.forEach(r, function (w) {
                    var v = u && u.getModelById(w.getResourceId());
                    if (v) {
                        k.add(w.getEventId(), v)
                    } else {
                        k.clear(w.getEventId())
                    }
                })
            }

            function b(s, r) {
                var t = k.assignmentStore.getEventStore(), u = t && t.getResourceStore();
                Ext.Array.forEach(r, function (w) {
                    var v = u.getModelById(w.getResourceId());
                    if (v) {
                        k.remove(w.getEventId(), v)
                    } else {
                        k.clear(w.getEventId())
                    }
                })
            }

            function q(B, s, x) {
                var y = s.resourceIdField, C = s.previous && y in s.previous, u = C && s.previous[y], z = s.eventIdField, r = s.previous && z in s.previous, t = r && s.previous[z], w = k.assignmentStore.getEventStore(), A = w && w.getResourceStore(), v;
                if (x != Ext.data.Model.COMMIT && (C || r)) {
                    u = C ? u : s.getResourceId();
                    t = r ? t : s.getEventId();
                    v = A.getModelById(u);
                    if (v) {
                        k.remove(t, v)
                    } else {
                        k.clear(t)
                    }
                    v = A.getModelById(s.getResourceId());
                    if (v) {
                        k.add(s.getEventId(), v)
                    } else {
                        k.clear(s.getEventId())
                    }
                }
            }

            function n(r) {
                k.clear()
            }

            function c(r, s) {
                k.clear();
                a(s);
                d(s && s.getResourceStore())
            }

            function l(s, t, u, r) {
                k.move(u, r)
            }

            function g(s, r) {
                Ext.Array.forEach(r, function (t) {
                    k.clear(t)
                })
            }

            function i() {
                k.clear()
            }

            function p(r, s) {
                k.clear();
                d(s)
            }

            function h(r, s) {
                Ext.Array.forEach(s, function (t) {
                    k.uncache(t)
                })
            }

            function e() {
                k.clear()
            }

            function a(r) {
                Ext.destroy(k.eventStoreDetacher);
                k.eventStoreDetacher = r && r.on({
                        idchanged: l,
                        remove: g,
                        clear: i,
                        cacheresethint: i,
                        rootchange: i,
                        resourcestorechange: p,
                        priority: 100,
                        destroyable: true
                    })
            }

            function d(r) {
                Ext.destory(k.resourceStoreDetacher);
                k.resourceStoreDetacher = r && r.on({
                        remove: h,
                        clear: e,
                        cacheresethint: e,
                        rootchange: e,
                        priority: 100,
                        destroyable: true
                    })
            }

            k.assignmentStoreDetacher = j.on({
                add: m,
                remove: b,
                update: q,
                clear: n,
                cacheresethint: n,
                priority: 100,
                destroyable: true
            });
            k.assignmentStore = j
        },
        destroy: function () {
            var a = this;
            Ext.destroyMembers(a, "assignmentStoreDetacher", "eventStoreDetacher", "resourceStoreDetacher");
            a.assignmentStore = null
        },
        get: function (a, b) {
            var c = this;
            b = b || function () {
                    return c.assignmentStore.mapAssignmentsForEvent(a, function e(f) {
                        return f.getResource()
                    }, function d(f) {
                        return !!f
                    })
                };
            return c.callParent([a, b])
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.util.AssignmentStoreResourceEventsCache")) {
    Ext.define("Sch.data.util.AssignmentStoreResourceEventsCache", {
        extend: "Sch.util.Cache",
        requires: ["Ext.data.Model"],
        assignmentStore: null,
        assignmentStoreDetacher: null,
        eventStoreDetacher: null,
        resourceStoreDetacher: null,
        constructor: function (j) {
            var l = this, f = j.getEventStore(), o = f && f.getResourceStore();
            l.callParent();
            function m(s, r) {
                var t = l.assignmentStore.getEventStore();
                Ext.Array.forEach(r, function (v) {
                    var u = t && t.getModelById(v.getEventId());
                    if (u) {
                        l.add(v.getResourceId(), u)
                    } else {
                        l.clear(v.getResourceId())
                    }
                })
            }

            function b(s, r) {
                var t = l.assignmentStore.getEventStore();
                Ext.Array.forEach(r, function (v) {
                    var u = t && t.getModelById(v.getEventId());
                    if (u) {
                        l.remove(v.getResourceId(), u)
                    } else {
                        l.clear(v.getResourceId())
                    }
                })
            }

            function q(A, t, x) {
                var y = t.resourceIdField, B = t.previous && y in t.previous, v = B && t.previous[y], z = t.eventIdField, r = t.previous && z in t.previous, u = r && t.previous[z], w = l.assignmentStore.getEventStore(), s;
                if (x != Ext.data.Model.COMMIT && (B || r)) {
                    v = B ? v : t.getResourceId();
                    u = r ? u : t.getEventId();
                    s = w && w.getModelById(u);
                    if (s) {
                        l.remove(v, s)
                    } else {
                        l.clear(v)
                    }
                    s = w && w.getModelById(t.getEventId());
                    if (s) {
                        l.add(t.getResourceId(), s)
                    } else {
                        l.clear(t.getResourceId())
                    }
                }
            }

            function n(r) {
                l.clear()
            }

            function c(r, s) {
                l.clear();
                a(s);
                d(s && s.getResourceStore())
            }

            function g(s, r) {
                Ext.Array.forEach(r, function (t) {
                    l.uncache(t)
                })
            }

            function i() {
                l.clear()
            }

            function p(r, s) {
                l.clear();
                d(s)
            }

            function k(s, t, u, r) {
                l.move(u, r)
            }

            function h(r, s) {
                Ext.Array.forEach(s, function (t) {
                    l.clear(t)
                })
            }

            function e() {
                l.clear()
            }

            function a(r) {
                Ext.destroy(l.eventStoreDetacher);
                l.eventStoreDetacher = r && r.on({
                        remove: g,
                        cacheresethint: i,
                        clear: i,
                        rootchange: i,
                        resourcestorechange: p,
                        priority: 100,
                        destroyable: true
                    })
            }

            function d(r) {
                Ext.destroy(l.resourceStoreDetacher);
                l.resourceStoreDetacher = r && r.on({
                        idchanged: k,
                        remove: h,
                        cacheresethint: e,
                        clear: e,
                        rootchange: e,
                        priority: 100,
                        destroyable: true
                    })
            }

            l.assignmentStoreDetacher = j.on({
                add: m,
                remove: b,
                update: q,
                cacheresethint: n,
                clear: n,
                eventstorechange: c,
                priority: 100,
                destroyable: true
            });
            a(f);
            d(o);
            l.assignmentStore = j
        },
        destroy: function () {
            var a = this;
            Ext.destroyMembers(a, "assignmentStoreDetacher", "eventStoreDetacher", "resourceStoreDetacher");
            a.assignmentStore = null
        },
        get: function (a, b) {
            var c = this;
            b = b || function () {
                    return c.assignmentStore.mapAssignmentsForResource(a, function e(f) {
                        return f.getEvent()
                    }, function d(f) {
                        return !!f
                    })
                };
            return c.callParent([a, b])
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.util.ModelPersistencyManager")) {
    Ext.define("Sch.data.util.ModelPersistencyManager", {
        config: {
            eventStore: null,
            resourceStore: null,
            assignmentStore: null
        },
        eventStoreDetacher: null,
        resourceStoreDetacher: null,
        assignmentStoreDetacher: null,
        constructor: function (a) {
            this.initConfig(a)
        },
        updateEventStore: function (a, c) {
            var b = this;
            Ext.destroyMembers(b, "eventStoreDetacher");
            if (a && a.autoSync) {
                b.eventStoreDetacher = a.on({
                    beforesync: b.onEventStoreBeforeSync,
                    scope: b,
                    destroyable: true,
                    priority: 100
                })
            }
        },
        updateResourceStore: function (a, b) {
            var c = this;
            Ext.destroyMembers(c, "resourceStoreDetacher");
            if (a && a.autoSync) {
                c.resourceStoreDetacher = a.on({
                    beforesync: c.onResourceStoreBeforeSync,
                    scope: c,
                    destroyable: true,
                    priority: 100
                })
            }
        },
        updateAssignmentStore: function (a, b) {
            var c = this;
            Ext.destroyMembers(c, "assignmentStoreDetacher");
            if (a && a.autoSync) {
                c.assignmentStoreDetacher = a.on({
                    beforesync: c.onAssignmentStoreBeforeSync,
                    scope: c,
                    destroyable: true,
                    priority: 100
                })
            }
        },
        onEventStoreBeforeSync: function (a) {
            var b = this;
            b.removeNonPersistableRecordsToCreate(a);
            return b.shallContinueSync(a)
        },
        onResourceStoreBeforeSync: function (a) {
            var b = this;
            b.removeNonPersistableRecordsToCreate(a);
            return b.shallContinueSync(a)
        },
        onAssignmentStoreBeforeSync: function (a) {
            var b = this;
            b.removeNonPersistableRecordsToCreate(a);
            return b.shallContinueSync(a)
        },
        removeNonPersistableRecordsToCreate: function (b) {
            var a = b.create || [], d, c;
            for (c = a.length - 1; c >= 0; --c) {
                d = a[c];
                if (!d.isPersistable()) {
                    Ext.Array.remove(a, d)
                }
            }
            if (a.length === 0) {
                delete b.create
            }
        },
        shallContinueSync: function (a) {
            return Boolean((a.create && a.create.length > 0) || (a.update && a.update.length > 0) || (a.destroy && a.destroy.length > 0))
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.util.IdConsistencyManager")) {
    Ext.define("Sch.data.util.IdConsistencyManager", {
        config: {
            eventStore: null,
            resourceStore: null,
            assignmentStore: null
        }, eventStoreDetacher: null, resourceStoreDetacher: null, constructor: function (a) {
            this.initConfig(a)
        }, updateEventStore: function (a, c) {
            var b = this;
            Ext.destroyMembers(b, "eventStoreDetacher");
            if (a) {
                b.eventStoreDetacher = a.on({idchanged: b.onEventIdChanged, scope: b, destroyable: true, priority: 200})
            }
        }, updateResourceStore: function (a, b) {
            var c = this;
            Ext.destroyMembers(c, "resourceStoreDetacher");
            if (a) {
                c.resourceStoreDetacher = a.on({
                    idchanged: c.onResourceIdChanged,
                    scope: c,
                    destroyable: true,
                    priority: 200
                })
            }
        }, onEventIdChanged: function (c, e, g, a) {
            var d = this, f = d.getAssignmentStore(), b;
            if (f) {
                b = d.getUpdateAssignmentEventIdFieldFn(f, g, a);
                c.on("update", b, null, {single: true, priority: 200})
            }
        }, onResourceIdChanged: function (i, e, b, d) {
            var h = this, f = h.getEventStore(), g = h.getAssignmentStore(), c, a;
            if (f && !g) {
                c = h.getUpdateEventResourceIdFieldFn(f, b, d)
            }
            if (g) {
                a = h.getUpdateAssignmentResourceIdFieldFn(g, b, d)
            }
            if (c || g) {
                i.on("update", function () {
                    c && c();
                    a && a()
                }, null, {single: true, priority: 200})
            }
        }, getUpdateEventResourceIdFieldFn: function (c, d, a) {
            var b = c.getRange();
            return function () {
                Ext.Array.forEach(b, function (e) {
                    e.getResourceId() == d && e.setResourceId(a)
                })
            }
        }, getUpdateAssignmentEventIdFieldFn: function (c, d, b) {
            var a = c.getAssignmentsForEvent(d);
            return function () {
                Ext.Array.forEach(a, function (e) {
                    e.getEventId() == d && e.setEventId(b)
                })
            }
        }, getUpdateAssignmentResourceIdFieldFn: function (c, d, b) {
            var a = c.getAssignmentsForResource(d);
            return function () {
                Ext.Array.forEach(a, function (e) {
                    e.getResourceId() == d && e.setResourceId(b)
                })
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.mixin.UniversalModelGetter")) {
    Ext.define("Sch.data.mixin.UniversalModelGetter", {
        getModelById: function (b) {
            var a = this;
            return a.getNodeById ? a.getNodeById(b) : a.getById(b)
        }, getModelByInternalId: function (b) {
            var a = this;
            return a.byInternalIdMap ? a.byInternalIdMap[b] : a.getByInternalId(b)
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.mixin.CacheHintHelper")) {
    Ext.define("Sch.data.mixin.CacheHintHelper", {
        extend: "Ext.Mixin",
        mixinConfig: {before: {loadRecords: "loadRecords"}},
        loadRecords: function () {
            var a = this;
            a.fireEvent("cacheresethint", a)
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.mixin.EventStore")) {
    Ext.define("Sch.data.mixin.EventStore", {
        extend: "Ext.Mixin",
        requires: ["Sch.util.Date", "Sch.data.util.IdConsistencyManager", "Sch.data.util.ModelPersistencyManager", "Sch.data.util.ResourceEventsCache"],
        isEventStore: true,
        resourceStore: null,
        resourceStoreDetacher: null,
        assignmentStore: null,
        resourceEventsCache: null,
        idConsistencyManager: null,
        modelPersistencyManager: null,
        mixinConfig: {after: {constructor: "constructor", destroy: "destroy"}},
        constructor: function () {
            var a = this;
            a.resourceEventsCache = a.createResourceEventsCache();
            a.idConsistencyManager = a.createIdConsistencyManager();
            a.modelPersistencyManager = a.createModelPersistencyManager()
        },
        destroy: function () {
            var a = this;
            Ext.destroyMembers(a, "resourceEventsCache", "idConsistencyManager", "modelPersistencyManager")
        },
        createResourceEventsCache: function () {
            return new Sch.data.util.ResourceEventsCache(this)
        },
        createIdConsistencyManager: function () {
            var a = this;
            return new Sch.data.util.IdConsistencyManager({
                eventStore: a,
                resourceStore: a.getResourceStore(),
                assignmentStore: a.getAssignmentStore()
            })
        },
        createModelPersistencyManager: function () {
            var a = this;
            return new Sch.data.util.ModelPersistencyManager({
                eventStore: a,
                resourceStore: a.getResourceStore(),
                assignmentStore: a.getAssignmentStore()
            })
        },
        getResourceStore: function () {
            return this.resourceStore
        },
        setResourceStore: function (b) {
            var a = this, c = a.resourceStore;
            if (a.resourceStore) {
                a.resourceStore.setEventStore(null);
                a.idConsistencyManager && a.idConsistencyManager.setResourceStore(null);
                a.modelPersistencyManager && a.modelPersistencyManager.setResourceStore(null)
            }
            a.resourceStore = b && Ext.StoreMgr.lookup(b) || null;
            if (a.resourceStore) {
                a.modelPersistencyManager && a.modelPersistencyManager.setResourceStore(a.resourceStore);
                a.idConsistencyManager && a.idConsistencyManager.setResourceStore(a.resourceStore);
                b.setEventStore(a)
            }
            if ((c || b) && c !== b) {
                a.fireEvent("resourcestorechange", a, b, c)
            }
        },
        getAssignmentStore: function () {
            return this.assignmentStore
        },
        setAssignmentStore: function (b) {
            var a = this, c = a.assignmentStore;
            if (a.assignmentStore) {
                a.assignmentStore.setEventStore(null);
                a.idConsistencyManager && a.idConsistencyManager.setAssignmentStore(null);
                a.modelPersistencyManager && a.modelPersistencyManager.setAssignmentStore(null)
            }
            a.assignmentStore = b && Ext.StoreMgr.lookup(b) || null;
            if (a.assignmentStore) {
                a.modelPersistencyManager && a.modelPersistencyManager.setAssignmentStore(a.assignmentStore);
                a.idConsistencyManager && a.idConsistencyManager.setAssignmentStore(a.assignmentStore);
                a.assignmentStore.setEventStore(a);
                Ext.destroy(a.resourceEventsCache)
            } else {
                a.resourceEventsCache = a.createResourceEventsCache()
            }
            if ((c || b) && c !== b) {
                a.fireEvent("assignmentstorechange", a, b, c)
            }
        },
        isDateRangeAvailable: function (g, a, c, e) {
            var f = Sch.util.Date, b = this.getEventsForResource(e), d = true;
            Ext.each(b, function (h) {
                d = (c === h || !f.intersectSpans(g, a, h.getStartDate(), h.getEndDate()));
                return d
            });
            return d
        },
        getEventsInTimeSpan: function (f, b, a) {
            var d = new Ext.util.MixedCollection();
            var c = [];
            if (a !== false) {
                var e = Sch.util.Date;
                this.forEachScheduledEvent(function (i, h, g) {
                    if (e.intersectSpans(h, g, f, b)) {
                        c.push(i)
                    }
                })
            } else {
                this.forEachScheduledEvent(function (i, h, g) {
                    if (h - f >= 0 && b - g >= 0) {
                        c.push(i)
                    }
                })
            }
            d.addAll(c);
            return d
        },
        forEachScheduledEvent: function (b, a) {
            this.each(function (e) {
                var d = e.getStartDate(), c = e.getEndDate();
                if (d && c) {
                    return b.call(a || this, e, d, c)
                }
            }, this)
        },
        getTotalTimeSpan: function () {
            var a = new Date(9999, 0, 1), b = new Date(0), c = Sch.util.Date;
            this.each(function (d) {
                if (d.getStartDate()) {
                    a = c.min(d.getStartDate(), a)
                }
                if (d.getEndDate()) {
                    b = c.max(d.getEndDate(), b)
                }
            });
            a = a < new Date(9999, 0, 1) ? a : null;
            b = b > new Date(0) ? b : null;
            this.lastTotalTimeSpan = {start: a || null, end: b || a || null};
            return this.lastTotalTimeSpan
        },
        filterEventsForResource: function (d, c, b) {
            var a = d.getEvents(this);
            return Ext.Array.filter(a, c, b || this)
        },
        append: function (a) {
            throw"Must be implemented by consuming class"
        },
        getResourcesForEvent: function (d) {
            var c = this, e = c.getAssignmentStore(), b = c.getResourceStore(), a;
            if (e) {
                a = e.getResourcesForEvent(d)
            } else {
                if (b) {
                    d = d instanceof Sch.model.Event && d || c.getModelById(d);
                    a = d && b.getModelById(d.getResourceId());
                    a = a && [a] || []
                } else {
                    a = []
                }
            }
            return a
        },
        getEventsForResource: function (d) {
            var c = this, e = c.getAssignmentStore(), b, a;
            if (e) {
                a = e.getEventsForResource(d)
            } else {
                if (c.resourceEventsCache) {
                    a = c.resourceEventsCache.get(d)
                } else {
                    a = []
                }
            }
            return a
        },
        getAssignmentsForEvent: function (b) {
            var a = this, c = a.getAssignmentStore();
            return c && c.getAssignmentsForEvent(b) || []
        },
        getAssignmentsForResource: function (b) {
            var a = this, c = a.getAssignmentStore();
            return c && c.getAssignmentsForResource(b) || []
        },
        assignEventToResource: function (b, c) {
            var a = this, d = a.getAssignmentStore();
            if (d) {
                d.assignEventToResource(b, c)
            } else {
                b = b instanceof Sch.model.Event && b || a.getModelById(b);
                c = c instanceof Sch.model.Resource ? c.getId() : c;
                b && b.setResourceId(c)
            }
        },
        unassignEventFromResource: function (b, c) {
            var a = this, d = a.getAssignmentStore();
            if (d) {
                d.unassignEventFromResource(b, c)
            } else {
                b = b instanceof Sch.model.Event && b || a.getModelById(b);
                c = c instanceof Sch.model.Resource ? c.getId() : c;
                if (b && b.getResourceId() == c) {
                    b.setResourceId(null)
                }
            }
        },
        reassignEventFromResourceToResource: function (d, a, b) {
            var c = this, e = c.getAssignmentStore();
            if (e) {
                e.unassignEventFromResource(d, a);
                e.assignEventToResource(d, b)
            } else {
                d = d instanceof Sch.model.Event && d || c.getModelById(d);
                a = a instanceof Sch.model.Resource ? a.getId() : a;
                b = b instanceof Sch.model.Resource ? b.getId() : b;
                if (d.getResourceId() == a) {
                    d.setResourceId(b)
                }
            }
        },
        isEventAssignedToResource: function (c, d) {
            var b = this, e = b.getAssignmentStore(), a;
            if (e) {
                a = e.isEventAssignedToResource(c, d)
            } else {
                c = c instanceof Sch.model.Event && c || b.getModelById(c);
                d = d instanceof Sch.model.Resource ? d.getId() : d;
                a = c && (c.getResourceId() == d) || false
            }
            return a
        },
        removeAssignmentsForEvent: function (b) {
            var a = this, c = a.getAssignmentStore();
            if (c) {
                c.removeAssignmentsForEvent(b)
            } else {
                b = b instanceof Sch.model.Event && b || a.getModelById(b);
                b && b.setResourceId(null)
            }
        },
        removeAssignmentsForResource: function (c) {
            var b = this, d = b.getAssignmentStore(), a = b.getResourceStore();
            if (d) {
                d.removeAssignmentsForResource(c)
            } else {
                if (a) {
                    c = c instanceof Sch.model.Resource && c || a.getModelById(c);
                    c && Ext.Array.forEach(b.resourceEventsCache.get(c), function (e) {
                        e.setResourceId(null)
                    })
                } else {
                    c = c instanceof Sch.model.Resource ? c.getId() : c;
                    Ext.Array.forEach(b.getRange(), function (e) {
                        e.getResourceId() == c && e.setResourceId(null)
                    })
                }
            }
        },
        isEventPersistable: function (e) {
            var d = this, g = d.getAssignmentStore(), f, c, b, a = true;
            if (!g) {
                f = e.getResources();
                for (c = 0, b = f.length; a && c < b; ++c) {
                    a = f[c].phantom !== true
                }
            }
            return a
        }
    })
}
if (!Ext.ClassManager.get("Sch.model.Range")) {
    Ext.define("Sch.model.Range", {
        extend: "Sch.model.Customizable",
        requires: ["Sch.util.Date"],
        idProperty: "Id",
        config: Ext.versions.touch ? {idProperty: "Id"} : null,
        startDateField: "StartDate",
        endDateField: "EndDate",
        nameField: "Name",
        clsField: "Cls",
        customizableFields: [{name: "StartDate", type: "date", dateFormat: "c"}, {
            name: "EndDate",
            type: "date",
            dateFormat: "c"
        }, {name: "Cls", type: "string"}, {name: "Name", type: "string"}],
        setStartDate: function (a, d) {
            var c = this.getEndDate();
            var b = this.getStartDate();
            this.set(this.startDateField, a);
            if (d === true && c && b) {
                this.setEndDate(Sch.util.Date.add(a, Sch.util.Date.MILLI, c - b))
            }
        },
        setEndDate: function (b, d) {
            var a = this.getStartDate();
            var c = this.getEndDate();
            this.set(this.endDateField, b);
            if (d === true && a && c) {
                this.setStartDate(Sch.util.Date.add(b, Sch.util.Date.MILLI, -(c - a)))
            }
        },
        setStartEndDate: function (b, a) {
            this.beginEdit();
            this.set(this.startDateField, b);
            this.set(this.endDateField, a);
            this.endEdit()
        },
        getDates: function () {
            var c = [], b = this.getEndDate();
            for (var a = Ext.Date.clearTime(this.getStartDate(), true); a < b; a = Sch.util.Date.add(a, Sch.util.Date.DAY, 1)) {
                c.push(a)
            }
            return c
        },
        forEachDate: function (b, a) {
            return Ext.each(this.getDates(), b, a)
        },
        isValid: function () {
            var b = this.callParent(arguments);
            if (b) {
                var c = this.getStartDate(), a = this.getEndDate();
                b = !c || !a || (a - c >= 0)
            }
            return b
        },
        shift: function (b, a) {
            this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), b, a), Sch.util.Date.add(this.getEndDate(), b, a))
        },
        fullCopy: function () {
            return this.copy.apply(this, arguments)
        }
    })
}
if (!Ext.ClassManager.get("Sch.model.TimeAxisTick")) {
    Ext.define("Sch.model.TimeAxisTick", {extend: "Sch.model.Range", startDateField: "start", endDateField: "end"})
}
if (!Ext.ClassManager.get("Sch.model.Assignment")) {
    Ext.define("Sch.model.Assignment", {
        extend: "Sch.model.Customizable",
        idProperty: "Id",
        customizableFields: [{name: "ResourceId"}, {name: "EventId"}],
        resourceIdField: "ResourceId",
        eventIdField: "EventId",
        getInternalId: function () {
            return this.internalId
        },
        getAssignmentStore: function () {
            return this.joined && this.joined[0]
        },
        getEventStore: function () {
            var a = this.getAssignmentStore();
            return a && a.getEventStore()
        },
        getResourceStore: function () {
            var a = this.getEventStore();
            return a && a.getResourceStore()
        },
        getEvent: function (a) {
            var b = this;
            a = a || b.getEventStore();
            return a && a.getModelById(b.getEventId())
        },
        getResource: function (b) {
            var a = this;
            b = b || a.getResourceStore();
            return b && b.getModelById(a.getResourceId())
        },
        getEventName: function (a) {
            var b = this.getEvent(a);
            return b && b.getName() || ""
        },
        getResourceName: function (a) {
            var b = this.getResource(a);
            return b && b.getName() || ""
        },
        isPersistable: function () {
            var b = this, a = b.getEvent(), c = b.getResource();
            return a && !a.phantom && c && !c.phantom
        },
        fullCopy: function () {
            return this.copy.apply(this, arguments)
        }
    })
}
if (!Ext.ClassManager.get("Sch.model.Resource")) {
    Ext.define("Sch.model.Resource", {
        extend: "Sch.model.Customizable",
        idProperty: "Id",
        config: Ext.versions.touch ? {idProperty: "Id"} : null,
        nameField: "Name",
        customizableFields: [{name: "Name", type: "string"}],
        getInternalId: function () {
            return this.internalId
        },
        getResourceStore: function () {
            return this.joined && this.joined[0]
        },
        getEventStore: function () {
            var a = this.getResourceStore();
            return a && a.getEventStore() || this.parentNode && this.parentNode.getEventStore()
        },
        getAssignmentStore: function () {
            var a = this.getEventStore();
            return a && a.getAssignmentStore()
        },
        getEvents: function (a) {
            var b = this;
            a = a || b.getEventStore();
            return a && a.getEventsForResource(b) || []
        },
        getAssignments: function () {
            var b = this, a = b.getEventStore();
            return a && a.getAssignmentsForResource(b)
        },
        isPersistable: function () {
            var a = this.parentNode;
            return !a || !a.phantom || (a.isRoot && a.isRoot())
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.mixin.ResourceStore")) {
    Ext.define("Sch.data.mixin.ResourceStore", {
        eventStore: null, getEventStore: function () {
            return this.eventStore
        }, setEventStore: function (a) {
            var b = this, c;
            if (b.eventStore !== a) {
                c = b.eventStore;
                b.eventStore = a && Ext.StoreMgr.lookup(a) || null;
                b.fireEvent("eventstorechange", b, a, c)
            }
        }
    })
}
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    isFilteredFlag: false,
    isHiddenFlag: false,
    lastTreeFilter: null,
    lastTreeHiding: null,
    allowExpandCollapseWhileFiltered: true,
    reApplyFilterOnDataChange: true,
    suspendIncrementalFilterRefresh: 0,
    filterGeneration: 0,
    currentFilterGeneration: null,
    dataChangeListeners: null,
    monitoringDataChange: false,
    filterUpdateSuspended: false,
    onClassMixedIn: function (a) {
        a.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {})
    },
    initTreeFiltering: function () {
        this.treeFilter = new Ext.util.Filter({filterFn: this.isNodeFilteredIn, scope: this});
        this.dataChangeListeners = {
            nodeappend: this.onNeedToUpdateFilter,
            nodeinsert: this.onNeedToUpdateFilter,
            scope: this
        };
        if (Ext.getVersion().isGreaterThan("5.1.0.107")) {
            Ext.apply(this.dataChangeListeners, {beforeload: this.onStoreBeforeLoad, load: this.onStoreLoad})
        }
    },
    onStoreBeforeLoad: function () {
        this.filterUpdateSuspended = true
    },
    onStoreLoad: function () {
        this.filterUpdateSuspended = false;
        this.onNeedToUpdateFilter()
    },
    startDataChangeMonitoring: function () {
        if (this.monitoringDataChange) {
            return
        }
        this.monitoringDataChange = true;
        this.on(this.dataChangeListeners)
    },
    stopDataChangeMonitoring: function () {
        if (!this.monitoringDataChange) {
            return
        }
        this.monitoringDataChange = false;
        this.un(this.dataChangeListeners)
    },
    onNeedToUpdateFilter: function () {
        if (this.reApplyFilterOnDataChange && !this.filterUpdateSuspended && !this.suspendIncrementalFilterRefresh) {
            this.reApplyFilter()
        }
    },
    clearTreeFilter: function () {
        if (!this.isTreeFiltered()) {
            return
        }
        this.currentFilterGeneration = null;
        this.isFilteredFlag = false;
        this.lastTreeFilter = null;
        if (!this.isTreeFiltered(true)) {
            this.stopDataChangeMonitoring()
        }
        this.refreshNodeStoreContent();
        this.fireEvent("filter-clear", this)
    },
    reApplyFilter: function () {
        if (this.isHiddenFlag) {
            this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag))
        }
        if (this.isFilteredFlag) {
            this.filterTreeBy(this.lastTreeFilter)
        }
    },
    refreshNodeStoreContent: function () {
        var b = this, a = b.getFilters();
        if (a.indexOf(b.treeFilter) < 0) {
            b.addFilter(b.treeFilter)
        } else {
            this.getFilters().fireEvent("endupdate", this.getFilters())
        }
    },
    getIndexInTotalDataset: function (d) {
        var c = this.getRootNode(), f = -1;
        var g = this.rootVisible;
        if (!g && d == c) {
            return -1
        }
        var b = this.isTreeFiltered();
        var a = this.currentFilterGeneration;
        var e = function (j) {
            if (b && j.__filterGen != a || j.hidden) {
                if (j == d) {
                    return false
                }
            }
            if (g || j != c) {
                f++
            }
            if (j == d) {
                return false
            }
            if (!j.isLeaf() && j.isExpanded()) {
                var l = j.childNodes, i = l.length;
                for (var h = 0; h < i; h++) {
                    if (e(l[h]) === false) {
                        return false
                    }
                }
            }
        };
        e(c);
        return f
    },
    isTreeFiltered: function (a) {
        return this.isFilteredFlag || a && this.isHiddenFlag
    },
    markFilteredNodes: function (i, b) {
        var h = this;
        var d = this.currentFilterGeneration;
        var c = {};
        var j = this.getRootNode(), l = this.rootVisible;
        var o = function (q) {
            var p = q.parentNode;
            while (p && !c[p.internalId]) {
                c[p.internalId] = true;
                p = p.parentNode
            }
        };
        var a = b.filter;
        var n = b.scope || this;
        var k = b.shallow;
        var m = b.checkParents || k;
        var f = b.fullMatchingParents;
        var e = b.onlyParents || f;
        if (e && m) {
            throw new Error("Can't combine `onlyParents` and `checkParents` options")
        }
        if (l) {
            c[j.internalId] = true
        }
        var g = function (s) {
            if (s.hidden) {
                return
            }
            var q, t, r, p;
            if (s.isLeaf()) {
                if (a.call(n, s, c)) {
                    c[s.internalId] = true;
                    o(s)
                }
            } else {
                if (e) {
                    q = a.call(n, s);
                    t = s.childNodes;
                    r = t.length;
                    if (q) {
                        c[s.internalId] = true;
                        o(s);
                        if (f) {
                            s.cascadeBy(function (u) {
                                c[u.internalId] = true
                            });
                            return
                        }
                    }
                    for (p = 0; p < r; p++) {
                        if (q && t[p].isLeaf()) {
                            c[t[p].internalId] = true
                        } else {
                            if (!t[p].isLeaf()) {
                                g(t[p])
                            }
                        }
                    }
                } else {
                    if (m) {
                        q = a.call(n, s, c);
                        if (q) {
                            c[s.internalId] = true;
                            o(s)
                        }
                    }
                    if (!m || !k || k && (q || s == j && !l)) {
                        t = s.childNodes;
                        r = t.length;
                        for (p = 0; p < r; p++) {
                            g(t[p])
                        }
                    }
                }
            }
        };
        g(i);
        j.cascadeBy(function (p) {
            if (c[p.internalId]) {
                p.__filterGen = d;
                if (h.allowExpandCollapseWhileFiltered && !p.isLeaf()) {
                    p.expand()
                }
            }
        })
    },
    filterTreeBy: function (c, b) {
        this.currentFilterGeneration = this.filterGeneration++;
        var a;
        if (arguments.length == 1 && Ext.isObject(arguments[0])) {
            b = c.scope;
            a = c.filter
        } else {
            a = c;
            c = {filter: a, scope: b}
        }
        this.fireEvent("nodestore-datachange-start", this);
        c = c || {};
        this.markFilteredNodes(this.getRootNode(), c);
        this.startDataChangeMonitoring();
        this.isFilteredFlag = true;
        this.lastTreeFilter = c;
        this.fireEvent("nodestore-datachange-end", this);
        this.fireEvent("filter-set", this);
        this.refreshNodeStoreContent()
    },
    isNodeFilteredIn: function (c) {
        var b = this.isTreeFiltered();
        var a = this.currentFilterGeneration;
        return this.loading || !Boolean(b && c.__filterGen != a || c.hidden)
    },
    hasNativeFilters: function () {
        var c = this, b = c.getFilters(), a = b.getCount();
        return (a && a > 1) || b.indexOf(c.treeFilter) < 0
    },
    hideNodesBy: function (b, a, d) {
        var c = this;
        if (c.isFiltered() && c.hasNativeFilters()) {
            throw new Error("Can't hide nodes of the filtered tree store")
        }
        a = a || c;
        c.getRootNode().cascadeBy(function (e) {
            e.hidden = Boolean(b.call(a, e, c))
        });
        c.startDataChangeMonitoring();
        c.isHiddenFlag = true;
        c.lastTreeHiding = [b, a];
        if (!d) {
            c.refreshNodeStoreContent()
        }
    },
    showAllNodes: function (a) {
        this.getRootNode().cascadeBy(function (b) {
            b.hidden = false
        });
        this.isHiddenFlag = false;
        this.lastTreeHiding = null;
        if (!this.isTreeFiltered(true)) {
            this.stopDataChangeMonitoring()
        }
        if (!a) {
            this.refreshNodeStoreContent()
        }
    },
    inheritables: function () {
        return {
            onNodeExpand: function (c, b, a) {
                if (this.isTreeFiltered(true) && c == this.getRoot()) {
                    this.callParent(arguments);
                    this.reApplyFilter()
                } else {
                    return this.callParent(arguments)
                }
            }, onNodeCollapse: function (f, a, h, g, i) {
                var e = this;
                var c = e.data;
                var j = c.contains;
                var b = e.isTreeFiltered();
                var d = e.currentFilterGeneration;
                c.contains = function () {
                    var n, m, p;
                    var l = e.indexOf(f) + 1;
                    var o = false;
                    for (var k = 0; k < a.length; k++) {
                        if (!(a[k].hidden || b && a[k].__filterGen != d) && j.call(this, a[k])) {
                            n = f;
                            while (n.parentNode) {
                                m = n;
                                do {
                                    m = m.nextSibling
                                } while (m && (m.hidden || b && m.__filterGen != d));
                                if (m) {
                                    o = true;
                                    p = e.indexOf(m);
                                    break
                                } else {
                                    n = n.parentNode
                                }
                            }
                            if (!o) {
                                p = e.getCount()
                            }
                            e.removeAt(l, p - l);
                            break
                        }
                    }
                    return false
                };
                this.callParent(arguments);
                c.contains = j
            }, handleNodeExpand: function (h, a, j) {
                var e = this;
                var f = [];
                var b = e.isTreeFiltered();
                var g = e.currentFilterGeneration;
                for (var c = 0; c < a.length; c++) {
                    var d = a[c];
                    if (!(b && d.__filterGen != g || d.hidden)) {
                        f[f.length] = d
                    }
                }
                return this.callParent([h, f, j])
            }, onNodeInsert: function (m, a, g) {
                var i = this, h, n, j, b, k, f, c = a.raw || a.data, l, e, d;
                if (i.filterFn) {
                    e = i.filterFn(a);
                    a.set("visible", e);
                    if (e) {
                        m.set("visible", i.filterFn(m))
                    }
                }
                i.registerNode(a, true);
                i.beginUpdate();
                if (i.isVisible(a)) {
                    if (g === 0 || !a.previousSibling) {
                        h = m
                    } else {
                        for (n = a.previousSibling; n && !n.get("visible"); n = n.previousSibling) {
                        }
                        if (!n) {
                            h = m
                        } else {
                            while (n.isExpanded() && n.lastChild) {
                                n = n.lastChild
                            }
                            h = n
                        }
                    }
                    i.insert(i.indexOf(h) + 1, a);
                    if (!a.isLeaf() && a.isExpanded()) {
                        if (a.isLoaded()) {
                            i.onNodeExpand(a, a.childNodes)
                        } else {
                            if (!i.fillCount) {
                                a.set("expanded", false);
                                a.expand()
                            }
                        }
                    }
                } else {
                    i.needsSync = i.needsSync || a.phantom || a.dirty
                }
                if (!a.isLeaf() && !a.isLoaded() && !i.lazyFill) {
                    j = i.getProxy().getReader();
                    b = a.getProxy();
                    k = b ? b.getReader() : null;
                    f = k && k.initialConfig.rootProperty ? k : j;
                    l = f.getRoot(c);
                    if (l) {
                        d = a.childType;
                        i.fillNode(a, f.extractData(l, d ? {model: d} : undefined))
                    }
                }
                i.endUpdate()
            }, isFiltered: function () {
                return this.callParent(arguments) || this.isTreeFiltered()
            }
        }
    }
});
if (!Ext.ClassManager.get("Sch.data.ResourceStore")) {
    Ext.define("Sch.data.ResourceStore", {
        extend: "Ext.data.Store",
        model: "Sch.model.Resource",
        config: {model: "Sch.model.Resource"},
        alias: "store.resourcestore",
        requires: ["Sch.patches.OperationDestroy"],
        mixins: ["Sch.data.mixin.UniversalModelGetter", "Sch.data.mixin.CacheHintHelper", "Sch.data.mixin.ResourceStore"],
        storeId: "resources",
        proxy: "memory",
        constructor: function () {
            this.callParent(arguments);
            if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
                throw"The model for the ResourceStore must subclass Sch.model.Resource"
            }
        }
    })
}
if (!Ext.ClassManager.get("Sch.data.AssignmentStore")) {
    Ext.define("Sch.data.AssignmentStore", {
        extend: "Ext.data.Store",
        mixins: ["Sch.data.mixin.UniversalModelGetter", "Sch.data.mixin.CacheHintHelper"],
        requires: ["Sch.model.Assignment", "Sch.model.Range", "Sch.model.Resource", "Sch.data.util.EventAssignmentsCache", "Sch.data.util.ResourceAssignmentsCache", "Sch.data.util.AssignmentStoreEventResourcesCache", "Sch.data.util.AssignmentStoreResourceEventsCache"],
        model: "Sch.model.Assignment",
        alias: "store.assignmentstore",
        storeId: "assignments",
        proxy: "memory",
        eventResourceCache: null,
        resourceEventsCache: null,
        eventStoreDetacher: null,
        resourceStoreDetacher: null,
        eventStore: null,
        constructor: function (a) {
            var b = this;
            b.callParent([a]);
            b.eventAssignmentsCache = b.eventAssignmentsCache || new Sch.data.util.EventAssignmentsCache(b);
            b.resourceAssignmentsCache = b.resourceAssignmentsCache || new Sch.data.util.ResourceAssignmentsCache(b)
        },
        destroy: function () {
            var a = this;
            Ext.destroyMembers(a, "eventResourceCache", "resourceEventsCache", "eventAssignmentsCache", "resourceEventsCache", "eventStoreDetacher", "resourceStoreDetacher");
            a.callParent()
        },
        getEventStore: function () {
            return this.eventStore
        },
        setEventStore: function (a) {
            var b = this, c = b.eventStore;
            if (b.eventStore) {
            }
            b.eventStore = a && Ext.StoreMgr.lookup(a) || null;
            if (b.eventStore) {
            }
            b.attachToEventStore(b.eventStore);
            if ((c || a) && c !== a) {
                b.fireEvent("eventstorechange", b, a, c)
            }
        },
        attachToEventStore: function (a) {
            var b = this;
            Ext.destroy(b.eventStoreDetacher);
            if (a && a instanceof Ext.data.TreeStore) {
                b.eventStoreDetacher = a.on({
                    noderemove: b.onEventNodeRemove,
                    resourcestorechange: b.onEventStoreResourceStoreChange,
                    scope: b,
                    destroyable: true,
                    priority: 200
                })
            } else {
                if (a) {
                    b.eventStoreDetacher = a.on({
                        remove: b.onEventRemove,
                        resourcestorechange: b.onEventStoreResourceStoreChange,
                        scope: b,
                        destroyable: true,
                        priority: 200
                    })
                }
            }
            b.attachToResourceStore(a && a.getResourceStore())
        },
        attachToResourceStore: function (b) {
            var a = this;
            Ext.destroy(a.resourceStoreDetacher);
            if (b && b instanceof Ext.data.TreeStore) {
                a.resourceStoreDetacher = b.on({
                    noderemove: a.onResourceNodeRemove,
                    scope: a,
                    destroyable: true,
                    priority: 200
                })
            } else {
                if (b) {
                    a.resourceStoreDetacher = b.on({
                        remove: a.onResourceRemove,
                        scope: a,
                        destroyable: true,
                        priority: 200
                    })
                }
            }
        },
        onEventStoreResourceStoreChange: function (b, a, c) {
            this.attachToResourceStore(a)
        },
        onEventRemove: function (e, d, c, b) {
            var f = this, a;
            if (!b) {
                a = [];
                Ext.Array.forEach(d, function (g) {
                    a = a.concat(f.getAssignmentsForEvent(g))
                });
                a.length && f.remove(a)
            }
        },
        onEventNodeRemove: function (c, e, b) {
            var d = this, a;
            if (!b) {
                a = [];
                e.cascadeBy(function (f) {
                    a = a.concat(d.getAssignmentsForEvent(f))
                });
                a.length && d.remove(a)
            }
        },
        onResourceRemove: function (e, f, c, b) {
            var d = this, a;
            if (!b) {
                a = [];
                Ext.Array.forEach(f, function (g) {
                    a = a.concat(d.getAssignmentsForResource(g))
                });
                a.length && d.remove(a)
            }
        },
        onResourceNodeRemove: function (d, e, b) {
            var c = this, a;
            if (!b) {
                a = [];
                e.cascadeBy(function (f) {
                    a = a.concat(c.getAssignmentsForResource(f))
                });
                a.length && c.remove(a)
            }
        },
        mapAssignmentsForEvent: function (d, b, e) {
            var c = this, a = [];
            b = b || Ext.identityFn;
            e = e || Ext.returnTrue;
            if (b !== Ext.identityFn || e !== Ext.returnTrue) {
                Ext.Array.forEach(c.eventAssignmentsCache.get(d), function (g) {
                    var f = b(g);
                    e(f) && a.push(f)
                })
            } else {
                a = [].concat(c.eventAssignmentsCache.get(d))
            }
            return a
        },
        mapAssignmentsForResource: function (d, b, e) {
            var c = this, a = [];
            b = b || Ext.identityFn;
            e = e || Ext.returnTrue;
            if (b !== Ext.identityFn || e !== Ext.returnTrue) {
                Ext.Array.forEach(c.resourceAssignmentsCache.get(d), function (g) {
                    var f = b(g);
                    e(f) && a.push(f)
                })
            } else {
                a = [].concat(c.resourceAssignmentsCache.get(d))
            }
            return a
        },
        getAssignmentsForEvent: function (a) {
            return this.mapAssignmentsForEvent(a)
        },
        removeAssignmentsForEvent: function (b) {
            var a = this;
            a.remove(a.getAssignmentsForEvent(b))
        },
        getAssignmentsForResource: function (a) {
            return this.mapAssignmentsForResource(a)
        },
        removeAssignmentsForResource: function (b) {
            var a = this;
            a.remove(a.getAssignmentsForResource(b))
        },
        getResourcesForEvent: function (d) {
            var c = this, a;
            if (c.eventResourceCache) {
                a = c.eventResourceCache.get(d)
            } else {
                a = c.mapAssignmentsForEvent(d, function e(f) {
                    return f.getResource()
                }, function b(f) {
                    return !!f
                })
            }
            return a
        },
        getEventsForResource: function (d) {
            var c = this, a;
            if (c.resourceEventsCache) {
                a = c.resourceEventsCache.get(d)
            } else {
                a = c.mapAssignmentsForResource(d, function e(f) {
                    return f.getEvent()
                }, function b(f) {
                    return !!f
                })
            }
            return a
        },
        assignEventToResource: function (c, e, d) {
            var b = this, a = [];
            d = d || Ext.identityFn;
            var f = Ext.isArray(e) ? e : [e];
            Ext.Array.forEach(f, function (g) {
                if (!b.isEventAssignedToResource(c, g)) {
                    var h = new b.model();
                    h.setEventId(c instanceof Ext.data.Model && c.getId() || c);
                    h.setResourceId(g instanceof Ext.data.Model && g.getId() || g);
                    h = d(h);
                    a.push(h)
                }
            });
            b.add(a);
            return a
        },
        unassignEventFromResource: function (b, c) {
            var a = this, d;
            if (!c) {
                this.removeAssignmentsForEvent(b)
            } else {
                if (a.isEventAssignedToResource(b, c)) {
                    d = a.getAssignmentForEventAndResource(b, c);
                    a.remove(d)
                }
            }
            return d
        },
        isEventAssignedToResource: function (f, g) {
            var e = this, c = e.getResourcesForEvent(f), b = false, d, a;
            g = g instanceof Ext.data.Model && g.getId() || g;
            for (d = 0, a = c.length; !b && d < a; d++) {
                b = c[d];
                b = b.getId() == g
            }
            return b
        },
        getAssignmentForEventAndResource: function (f, g) {
            var e = this, c = e.getAssignmentsForEvent(f), b = null, d, a;
            g = g instanceof Ext.data.Model && g.getId() || g;
            for (d = 0, a = c.length; !b && d < a; d++) {
                b = c[d];
                b = b.getResourceId() == g && b || null
            }
            return b
        }
    })
}
Ext.define("Sch.data.TimeAxis", {
    extend: "Ext.data.JsonStore",
    requires: ["Sch.util.Date", "Sch.model.TimeAxisTick"],
    model: "Sch.model.TimeAxisTick",
    continuous: true,
    originalContinuous: null,
    autoAdjust: true,
    unit: null,
    increment: null,
    resolutionUnit: null,
    resolutionIncrement: null,
    weekStartDay: null,
    mainUnit: null,
    shiftUnit: null,
    shiftIncrement: 1,
    defaultSpan: 1,
    isConfigured: false,
    adjustedStart: null,
    adjustedEnd: null,
    visibleTickStart: null,
    visibleTickEnd: null,
    presetName: null,
    mode: "plain",
    startTime: 0,
    endTime: 24,
    constructor: function (a) {
        var c = this;
        a = a || {};
        if (c.setModel) {
            c.setModel(c.model)
        }
        c.setMode(a.mode || c.mode);
        c.originalContinuous = c.continuous;
        c.callParent(arguments);
        c.on(Ext.versions.touch ? "refresh" : "datachanged", function (d) {
            c.fireEvent("reconfigure", c, false)
        });
        c.on("endreconfigure", function (d, e) {
            d.fireEvent("reconfigure", d, e)
        });
        if (a.viewPreset) {
            var b = Sch.preset.Manager.getPreset(a.viewPreset);
            b && c.consumeViewPreset(b)
        }
        if (a.start || c.start) {
            c.reconfigure(a)
        }
    },
    reconfigure: function (d, a) {
        this.isConfigured = true;
        Ext.apply(this, d);
        var k = this.getAdjustedDates(d.start, d.end, true);
        var j = this.getAdjustedDates(d.start, d.end);
        var b = j.start;
        var e = j.end;
        if (this.fireEvent("beforereconfigure", this, b, e) !== false) {
            this.fireEvent("beginreconfigure", this);
            var h = this.unit;
            var i = this.increment || 1;
            var g = this.generateTicks(b, e, h, i, this.mainUnit);
            this.removeAll(true);
            this.suspendEvents();
            this.add(g);
            if (this.getCount() === 0) {
                Ext.Error.raise("Invalid time axis configuration or filter, please check your input data.")
            }
            this.resumeEvents();
            var c = Sch.util.Date;
            var f = g.length;
            if (this.isContinuous()) {
                this.adjustedStart = k.start;
                this.adjustedEnd = this.getNext(f > 1 ? g[f - 1].start : k.start, h, i)
            } else {
                this.adjustedStart = this.getStart();
                this.adjustedEnd = this.getEnd()
            }
            do {
                this.visibleTickStart = (this.getStart() - this.adjustedStart) / (c.getUnitDurationInMs(h) * i);
                if (this.visibleTickStart >= 1) {
                    this.adjustedStart = c.getNext(this.adjustedStart, h, i)
                }
            } while (this.visibleTickStart >= 1);
            do {
                this.visibleTickEnd = f - (this.adjustedEnd - this.getEnd()) / (c.getUnitDurationInMs(h) * i);
                if (f - this.visibleTickEnd >= 1) {
                    this.adjustedEnd = c.getNext(this.adjustedEnd, h, -1)
                }
            } while (f - this.visibleTickEnd >= 1);
            this.fireEvent("endreconfigure", this, a)
        }
    },
    setMode: function (a) {
        this.mode = a;
        if (a === "calendar") {
            this.generateTicksValidatorFn = function (b) {
                if (this.startTime > 0 || this.endTime < 24) {
                    return (b.getHours() >= this.startTime && b.getHours() < this.endTime)
                } else {
                    return true
                }
            }
        } else {
            this.generateTicksValidatorFn = function () {
                return true
            }
        }
    },
    setTimeSpan: function (c, a) {
        var b = this.getAdjustedDates(c, a);
        c = b.start;
        a = b.end;
        if (this.getStart() - c !== 0 || this.getEnd() - a !== 0) {
            this.reconfigure({start: c, end: a})
        }
    },
    filterBy: function (b, a) {
        this.continuous = false;
        a = a || this;
        this.clearFilter(true);
        this.suspendEvents(true);
        this.filter([{
            filterFn: function (d, c) {
                return b.call(a, d.data, c)
            }
        }]);
        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise("Invalid time axis filter - no ticks passed through the filter. Please check your filter method.")
        }
        this.resumeEvents()
    },
    isContinuous: function () {
        return this.continuous && !this.isFiltered()
    },
    clearFilter: function () {
        this.continuous = this.originalContinuous;
        this.callParent(arguments)
    },
    generateTicks: function (a, d, g, i) {
        var h = [], f, b = Sch.util.Date, e = 0;
        g = g || this.unit;
        i = i || this.increment;
        var j = this.getAdjustedDates(a, d);
        a = j.start;
        d = j.end;
        while (a < d) {
            f = this.getNext(a, g, i);
            if (!this.autoAdjust && f > d) {
                f = d
            }
            if (g === b.HOUR && i > 1 && h.length > 0 && e === 0) {
                var c = h[h.length - 1];
                e = ((c.start.getHours() + i) % 24) - c.end.getHours();
                if (e !== 0) {
                    f = b.add(f, b.HOUR, e)
                }
            }
            this.generateTicksValidatorFn(a) && h.push({start: a, end: f});
            a = f
        }
        return h
    },
    getVisibleTickTimeSpan: function () {
        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount()
    },
    getAdjustedDates: function (b, e, d) {
        var c = Sch.util.Date;
        b = b || this.getStart();
        e = e || c.add(b, this.mainUnit, this.defaultSpan);
        if (this.mode === "calendar") {
            if (this.shiftUnit === c.MONTH) {
                var g = c.add(b, c.WEEK, 1);
                var f = c.add(e, c.WEEK, -1);
                if (!e) {
                    e = this.getNext(b, this.shiftUnit, 1);
                    e = this.ceilDate(e, false, this.shiftUnit, 1);
                    e = this.ceilDate(e, false, this.mainUnit, 1)
                }
                if (g.getMonth() !== b.getMonth() && f.getMonth() !== e.getMonth()) {
                    return {start: b, end: e}
                }
            }
            var i = this.floorDate(b, false, this.shiftUnit, 1);
            i = this.floorDate(i, false, this.mainUnit, 1);
            var h = this.getNext(b, this.shiftUnit, 1);
            var a = this.ceilDate(h, false, this.shiftUnit, 1);
            a = this.ceilDate(a, false, this.mainUnit, 1);
            return {start: i, end: a}
        } else {
            return this.autoAdjust || d ? {
                start: this.floorDate(b, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end: this.ceilDate(e, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {start: b, end: e}
        }
    },
    getTickFromDate: function (d) {
        var j = this.data.items;
        var h = j.length - 1;
        if (d < j[0].data.start || d > j[h].data.end) {
            return -1
        }
        var f, g, b;
        if (this.isContinuous()) {
            if (d - j[0].data.start === 0) {
                return this.visibleTickStart
            }
            if (d - j[h].data.end === 0) {
                return this.visibleTickEnd
            }
            var k = this.adjustedStart;
            var a = this.adjustedEnd;
            var c = Math.floor(j.length * (d - k) / (a - k));
            if (c > h) {
                c = h
            }
            g = c === 0 ? k : j[c].data.start;
            b = c == h ? a : j[c].data.end;
            f = c + (d - g) / (b - g);
            if (f < this.visibleTickStart || f > this.visibleTickEnd) {
                return -1
            }
            return f
        } else {
            for (var e = 0; e <= h; e++) {
                b = j[e].data.end;
                if (d <= b) {
                    g = j[e].data.start;
                    f = e + (d > g ? (d - g) / (b - g) : 0);
                    return f
                }
            }
        }
        return -1
    },
    getDateFromTick: function (e, i) {
        if (e === this.visibleTickEnd) {
            return this.getEnd()
        }
        var b = Math.floor(e), g = e - b, h = this.getAt(b);
        if (!h) {
            return null
        }
        var f = h.data;
        var a = b === 0 ? this.adjustedStart : f.start;
        var d = (b == this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : f.end;
        var c = Sch.util.Date.add(a, Sch.util.Date.MILLI, g * (d - a));
        if (i) {
            c = this[i + "Date"](c)
        }
        return c
    },
    getTicks: function () {
        var a = [];
        this.each(function (b) {
            a.push(b.data)
        });
        return a
    },
    getStart: function () {
        var a = this.first();
        if (a) {
            return new Date(a.data.start)
        }
        return null
    },
    getEnd: function () {
        var a = this.last();
        if (a) {
            return new Date(a.data.end)
        }
        return null
    },
    floorDate: function (e, g, h, a) {
        g = g !== false;
        var c = Ext.Date.clone(e), d = g ? this.getStart() : null, l = a || this.resolutionIncrement, k;
        if (h) {
            k = h
        } else {
            k = g ? this.resolutionUnit : this.mainUnit
        }
        var b = Sch.util.Date;
        var f = function (n, m) {
            return Math.floor(n / m) * m
        };
        switch (k) {
            case b.MILLI:
                if (g) {
                    c = b.add(d, b.MILLI, f(b.getDurationInMilliseconds(d, c), l))
                }else{
                    /*add ms hander by tianjsh*/
                    c.setMilliseconds(f(c.getMilliseconds(), l));
                }
                break;
            case b.SECOND:
                if (g) {
                    c = b.add(d, b.MILLI, f(b.getDurationInSeconds(d, c), l) * 1000)
                } else {
                    c.setMilliseconds(0);
                    c.setSeconds(f(c.getSeconds(), l))
                }
                break;
            case b.MINUTE:
                if (g) {
                    c = b.add(d, b.SECOND, f(b.getDurationInMinutes(d, c), l) * 60)
                } else {
                    c.setMinutes(f(c.getMinutes(), l));
                    c.setSeconds(0);
                    c.setMilliseconds(0)
                }
                break;
            case b.HOUR:
                if (g) {
                    c = b.add(d, b.MINUTE, f(b.getDurationInHours(this.getStart(), c), l) * 60)
                } else {
                    c.setMinutes(0);
                    c.setSeconds(0);
                    c.setMilliseconds(0);
                    c.setHours(f(c.getHours(), l))
                }
                break;
            case b.DAY:
                if (g) {
                    c = b.add(d, b.DAY, f(b.getDurationInDays(d, c), l))
                } else {
                    Sch.util.Date.clearTime(c);
                    c.setDate(f(c.getDate() - 1, l) + 1)
                }
                break;
            case b.WEEK:
                var j = c.getDay() || 7;
                var i = this.weekStartDay || 7;
                Sch.util.Date.clearTime(c);
                c = b.add(c, b.DAY, j >= i ? i - j : -(7 - i + j));
                if (c.getDay() !== i && c.getHours() === 23) {
                    c = b.add(c, b.HOUR, 1)
                }
                break;
            case b.MONTH:
                if (g) {
                    c = b.add(d, b.MONTH, f(b.getDurationInMonths(d, c), l))
                } else {
                    Sch.util.Date.clearTime(c);
                    c.setDate(1);
                    c.setMonth(f(c.getMonth(), l))
                }
                break;
            case b.QUARTER:
                Sch.util.Date.clearTime(c);
                c.setDate(1);
                c = b.add(c, b.MONTH, -(c.getMonth() % 3));
                break;
            case b.YEAR:
                if (g) {
                    c = b.add(d, b.YEAR, f(b.getDurationInYears(d, c), l))
                } else {
                    c = new Date(f(e.getFullYear() - 1, l) + 1, 0, 1)
                }
                break
        }
        return c
    },
    roundDate: function (r, b) {
        var l = Ext.Date.clone(r), s = this.resolutionIncrement;
        b = b || this.getStart();
        switch (this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var e = Sch.util.Date.getDurationInMilliseconds(b, l), d = Math.round(e / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.MILLI, d);
                break;
            case Sch.util.Date.SECOND:
                var i = Sch.util.Date.getDurationInSeconds(b, l), q = Math.round(i / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.MILLI, q * 1000);
                break;
            case Sch.util.Date.MINUTE:
                var n = Sch.util.Date.getDurationInMinutes(b, l), a = Math.round(n / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.SECOND, a * 60);
                break;
            case Sch.util.Date.HOUR:
                var m = Sch.util.Date.getDurationInHours(b, l), j = Math.round(m / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.MINUTE, j * 60);
                break;
            case Sch.util.Date.DAY:
                var c = Sch.util.Date.getDurationInDays(b, l), f = Math.round(c / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.DAY, f);
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(l);
                var o = l.getDay() - this.weekStartDay, t;
                if (o < 0) {
                    o = 7 + o
                }
                if (Math.round(o / 7) === 1) {
                    t = 7 - o
                } else {
                    t = -o
                }
                l = Sch.util.Date.add(l, Sch.util.Date.DAY, t);
                break;
            case Sch.util.Date.MONTH:
                var p = Sch.util.Date.getDurationInMonths(b, l) + (l.getDate() / Ext.Date.getDaysInMonth(l)), h = Math.round(p / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.MONTH, h);
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(l);
                l.setDate(1);
                l = Sch.util.Date.add(l, Sch.util.Date.MONTH, 3 - (l.getMonth() % 3));
                break;
            case Sch.util.Date.YEAR:
                var k = Sch.util.Date.getDurationInYears(b, l), g = Math.round(k / s) * s;
                l = Sch.util.Date.add(b, Sch.util.Date.YEAR, g);
                break
        }
        return l
    },
    ceilDate: function (c, b, f) {
        var e = Ext.Date.clone(c);
        b = b !== false;
        var a = b ? this.resolutionIncrement : 1, g = false, d;
        if (f) {
            d = f
        } else {
            d = b ? this.resolutionUnit : this.mainUnit
        }
        switch (d) {
            case Sch.util.Date.HOUR:
                if (e.getMinutes() > 0 || e.getSeconds() > 0 || e.getMilliseconds() > 0) {
                    g = true
                }
                break;
            case Sch.util.Date.DAY:
                if (e.getHours() > 0 || e.getMinutes() > 0 || e.getSeconds() > 0 || e.getMilliseconds() > 0) {
                    g = true
                }
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(e);
                if (e.getDay() !== this.weekStartDay || c.getTime() - e.getTime() > 0) {
                    g = true
                }
                break;
            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(e);
                if (e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                    g = true
                }
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(e);
                if (e.getMonth() % 3 !== 0 || e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                    g = true
                }
                break;
            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(e);
                if (e.getMonth() !== 0 || e.getDate() !== 1 || c.getTime() - e.getTime() > 0) {
                    g = true
                }
                break;
            default:
                break
        }
        if (g) {
            return this.getNext(e, d, a)
        } else {
            return e
        }
    },
    getNext: function (b, c, a) {
        return Sch.util.Date.getNext(b, c, a, this.weekStartDay)
    },
    getResolution: function () {
        return {unit: this.resolutionUnit, increment: this.resolutionIncrement}
    },
    setResolution: function (b, a) {
        this.resolutionUnit = b;
        this.resolutionIncrement = a || 1
    },
    shift: function (a, b) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    shiftNext: function (a) {
        a = a || this.getShiftIncrement();
        var b = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    shiftPrevious: function (a) {
        a = -(a || this.getShiftIncrement());
        var b = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), b, a), Sch.util.Date.add(this.getEnd(), b, a))
    },
    getShiftUnit: function () {
        return this.shiftUnit || this.mainUnit
    },
    getShiftIncrement: function () {
        return this.shiftIncrement || 1
    },
    getUnit: function () {
        return this.unit
    },
    getIncrement: function () {
        return this.increment
    },
    getRowTicks: function () {
        if (this.mode === "plain") {
            return
        } else {
            var c = this.getStart();
            var a = Sch.util.Date.add(c, this.headerConfig.middle.splitUnit, 1);
            var b = this.findBy(function (d) {
                return d.getStartDate().getTime() >= a.getTime()
            });
            if (b === -1) {
                return this.getRange()
            }
            return this.getRange(0, b - 1)
        }
    },
    dateInAxis: function (a) {
        return Sch.util.Date.betweenLesser(a, this.getStart(), this.getEnd())
    },
    timeSpanInAxis: function (b, a) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(b, a, this.getStart(), this.getEnd())
        } else {
            return (b < this.getStart() && a > this.getEnd()) || this.getTickFromDate(b) !== this.getTickFromDate(a)
        }
    },
    isRangeInAxis: function (b) {
        var c = b.getStartDate(), a = b.getEndDate();
        if (!c || !a) {
            return false
        }
        return this.timeSpanInAxis(c, a)
    },
    forEachAuxInterval: function (h, b, a, f) {
        f = f || this;
        var c = this.getEnd(), g = this.getStart(), e = 0, d;
        if (g > c) {
            throw"Invalid time axis configuration"
        }
        while (g < c) {
            d = Sch.util.Date.min(this.getNext(g, h, b || 1), c);
            a.call(f, g, d, e);
            g = d;
            e++
        }
    },
    consumeViewPreset: function (a) {
        Ext.apply(this, {
            unit: a.getBottomHeader().unit,
            increment: a.getBottomHeader().increment || 1,
            resolutionUnit: a.timeResolution.unit,
            resolutionIncrement: a.timeResolution.increment,
            mainUnit: a.getMainHeader().unit,
            shiftUnit: a.shiftUnit,
            shiftIncrement: a.shiftIncrement || 1,
            defaultSpan: a.defaultSpan || 1,
            presetName: a.name,
            headerConfig: a.headerConfig
        })
    }
});
Ext.define("Sch.preset.ViewPreset", {
    name: null,
    rowHeight: null,
    timeColumnWidth: 50,
    timeRowHeight: null,
    timeAxisColumnWidth: null,
    displayDateFormat: "G:i",
    shiftUnit: "HOUR",
    shiftIncrement: 1,
    defaultSpan: 12,
    timeResolution: null,
    headerConfig: null,
    columnLinesFor: "middle",
    headers: null,
    mainHeader: 0,
    constructor: function (a) {
        Ext.apply(this, a)
    },
    getHeaders: function () {
        if (this.headers) {
            return this.headers
        }
        var a = this.headerConfig;
        this.mainHeader = a.top ? 1 : 0;
        return this.headers = [].concat(a.top || [], a.middle || [], a.bottom || [])
    },
    getMainHeader: function () {
        return this.getHeaders()[this.mainHeader]
    },
    getBottomHeader: function () {
        var a = this.getHeaders();
        return a[a.length - 1]
    },
    clone: function () {
        var a = {};
        var b = this;
        Ext.each(["rowHeight", "timeColumnWidth", "timeRowHeight", "timeAxisColumnWidth", "displayDateFormat", "shiftUnit", "shiftIncrement", "defaultSpan", "timeResolution", "headerConfig"], function (c) {
            a[c] = b[c]
        });
        return new this.self(Ext.clone(a))
    }
});
Ext.define("Sch.preset.Manager", {
    extend: "Ext.util.MixedCollection",
    requires: ["Sch.util.Date", "Sch.preset.ViewPreset"],
    mixins: ["Sch.mixin.Localizable"],
    singleton: true,
    defaultPresets: {
        secondAndMinute: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i:s",
            shiftIncrement: 10,
            shiftUnit: "MINUTE",
            defaultSpan: 24,
            timeResolution: {unit: "SECOND", increment: 5},
            headerConfig: {
                middle: {unit: "SECOND", increment: 10, align: "center", dateFormat: "s"},
                top: {unit: "MINUTE", align: "center", dateFormat: "D, d g:iA"}
            }
        },
        minuteAndHour: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "HOUR",
            defaultSpan: 24,
            timeResolution: {unit: "MINUTE", increment: 30},
            headerConfig: {
                middle: {unit: "MINUTE", increment: "30", align: "center", dateFormat: "i"},
                top: {unit: "HOUR", align: "center", dateFormat: "D, gA/d"}
            }
        },
        hourAndDay: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "DAY",
            defaultSpan: 24,
            timeResolution: {unit: "MINUTE", increment: 30},
            headerConfig: {
                middle: {unit: "HOUR", align: "center", dateFormat: "G:i"},
                top: {unit: "DAY", align: "center", dateFormat: "D d/m"}
            }
        },
        dayAndWeek: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d G:i",
            shiftUnit: "DAY",
            shiftIncrement: 1,
            defaultSpan: 5,
            timeResolution: {unit: "HOUR", increment: 1},
            headerConfig: {
                middle: {unit: "DAY", align: "center", dateFormat: "D d M"},
                top: {
                    unit: "WEEK", align: "center", renderer: function (c, b, a) {
                        return Sch.util.Date.getShortNameOfUnit("WEEK") + "." + Ext.Date.format(c, "W M Y")
                    }
                }
            }
        },
        weekAndDay: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {unit: "DAY", increment: 1},
            headerConfig: {
                bottom: {unit: "DAY", align: "center", increment: 1, dateFormat: "d/m"},
                middle: {unit: "WEEK", dateFormat: "D d M"}
            }
        },
        weekAndMonth: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 5,
            defaultSpan: 6,
            timeResolution: {unit: "DAY", increment: 1},
            headerConfig: {
                middle: {
                    unit: "WEEK", renderer: function (c, b, a) {
                        return Ext.Date.format(c, "d M")
                    }
                }, top: {unit: "MONTH", align: "center", dateFormat: "M Y"}
            }
        },
        monthAndYear: {
            timeColumnWidth: 110,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftIncrement: 3,
            shiftUnit: "MONTH",
            defaultSpan: 12,
            timeResolution: {unit: "DAY", increment: 1},
            headerConfig: {
                middle: {unit: "MONTH", align: "center", dateFormat: "M Y"},
                top: {unit: "YEAR", align: "center", dateFormat: "Y"}
            }
        },
        year: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "YEAR",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {unit: "MONTH", increment: 1},
            headerConfig: {
                middle: {
                    unit: "QUARTER", align: "center", renderer: function (c, b, a) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit("QUARTER").toUpperCase() + "{0}", Math.floor(c.getMonth() / 3) + 1)
                    }
                }, top: {unit: "YEAR", align: "center", dateFormat: "Y"}
            }
        },
        manyYears: {
            timeColumnWidth: 50,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "YEAR",
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {unit: "YEAR", increment: 1},
            headerConfig: {
                middle: {unit: "YEAR", align: "center", dateFormat: "Y", increment: 5},
                bottom: {unit: "YEAR", align: "center", dateFormat: "y", increment: 1}
            }
        },
        weekAndDayLetter: {
            timeColumnWidth: 20,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {unit: "DAY", increment: 1},
            headerConfig: {
                bottom: {
                    unit: "DAY", align: "center", renderer: function (a) {
                        return Ext.Date.dayNames[a.getDay()].substring(0, 1)
                    }
                }, middle: {unit: "WEEK", dateFormat: "D d M Y"}
            }
        },
        weekDateAndMonth: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "Y-m-d",
            shiftUnit: "WEEK",
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {unit: "DAY", increment: 1},
            headerConfig: {
                middle: {unit: "WEEK", align: "center", dateFormat: "d"},
                top: {unit: "MONTH", dateFormat: "Y F"}
            }
        },
        day: {
            timeRowHeight: 40,
            calendarColumnWidth: 200,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "DAY",
            defaultSpan: 24,
            timeResolution: {unit: "MINUTE", increment: 30},
            headerConfig: {
                bottom: {
                    unit: "HOUR", align: "center", renderer: function (a) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span><span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(a, "H"), Ext.Date.format(a, "i"))
                    }
                }, middle: {unit: "DAY", align: "center", dateFormat: "D d/m", splitUnit: "DAY"}
            }
        },
        week: {
            timeRowHeight: 40,
            calendarColumnWidth: 164,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "WEEK",
            defaultSpan: 24,
            timeResolution: {unit: "MINUTE", increment: 30},
            headerConfig: {
                bottom: {
                    unit: "HOUR", align: "center", dateFormat: "H:i", renderer: function (a) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span><span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(a, "H"), Ext.Date.format(a, "i"))
                    }
                }, middle: {unit: "WEEK", align: "center", dateFormat: "D d", splitUnit: "DAY"}
            }
        },
        month: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: "G:i",
            shiftIncrement: 1,
            shiftUnit: "MONTH",
            defaultSpan: 4,
            timeResolution: {unit: "HOUR", increment: 12},
            headerConfig: {
                bottom: {unit: "DAY", align: "center", dateFormat: "D", splitUnit: "WEEK"},
                middle: {unit: "WEEK", align: "center", dateFormat: "D d/m"},
                top: {
                    unit: "MONTH", align: "center", renderer: function (c, b, a) {
                        return Ext.Date.format(c, "d/m") + " - " + Ext.Date.format(b, "d/m, Y")
                    }, splitUnit: "WEEK"
                }
            }
        }
    },
    constructor: function () {
        this.callParent(arguments);
        this.registerDefaults()
    },
    onLocalized: function () {
        var a = this;
        this.eachKey(function (c, d) {
            if (a.l10n[c]) {
                var b = a.L(c);
                b.displayDateFormat && (d.displayDateFormat = b.displayDateFormat);
                b.middleDateFormat && (d.headerConfig.middle.dateFormat = b.middleDateFormat);
                b.topDateFormat && (d.headerConfig.top.dateFormat = b.topDateFormat);
                b.bottomDateFormat && (d.headerConfig.bottom.dateFormat = b.bottomDateFormat)
            }
        })
    },
    registerPreset: function (b, a) {
        if (a) {
            var c = a.headerConfig;
            var f = Sch.util.Date;
            for (var g in c) {
                if (c.hasOwnProperty(g)) {
                    if (f[c[g].unit]) {
                        c[g].unit = f[c[g].unit.toUpperCase()]
                    }
                    if (f[c[g].splitUnit]) {
                        c[g].splitUnit = f[c[g].splitUnit.toUpperCase()]
                    }
                }
            }
            if (!a.timeColumnWidth) {
                a.timeColumnWidth = 50
            }
            if (!a.rowHeight) {
                a.rowHeight = 24
            }
            var d = a.timeResolution;
            if (d && f[d.unit]) {
                d.unit = f[d.unit.toUpperCase()]
            }
            var e = a.shiftUnit;
            if (e && f[e]) {
                a.shiftUnit = f[e.toUpperCase()]
            }
        }
        if (this.isValidPreset(a)) {
            if (this.containsKey(b)) {
                this.removeAtKey(b)
            }
            a.name = b;
            this.add(b, new Sch.preset.ViewPreset(a))
        } else {
            throw"Invalid preset, please check your configuration"
        }
    },
    isValidPreset: function (a) {
        var e = Sch.util.Date, c = true, d = Sch.util.Date.units, b = {};
        for (var f in a.headerConfig) {
            if (a.headerConfig.hasOwnProperty(f)) {
                b[f] = true;
                c = c && Ext.Array.indexOf(d, a.headerConfig[f].unit) >= 0
            }
        }
        if (!(a.columnLinesFor in b)) {
            a.columnLinesFor = "middle"
        }
        if (a.timeResolution) {
            c = c && Ext.Array.indexOf(d, a.timeResolution.unit) >= 0
        }
        if (a.shiftUnit) {
            c = c && Ext.Array.indexOf(d, a.shiftUnit) >= 0
        }
        return c
    },
    getPreset: function (a) {
        return this.get(a)
    },
    deletePreset: function (a) {
        this.removeAtKey(a)
    },
    registerDefaults: function () {
        var b = this, a = this.defaultPresets;
        for (var c in a) {
            b.registerPreset(c, a[c])
        }
    }
});
if (!Ext.ClassManager.get("Sch.feature.AbstractTimeSpan")) {
    Ext.define("Sch.feature.AbstractTimeSpan", {
        extend: "Ext.AbstractPlugin",
        mixins: {observable: "Ext.util.Observable"},
        lockableScope: "top",
        schedulerView: null,
        timeAxis: null,
        containerEl: null,
        expandToFitView: false,
        disabled: false,
        cls: null,
        clsField: "Cls",
        template: null,
        store: null,
        renderElementsBuffered: false,
        renderDelay: 15,
        refreshSizeOnItemUpdate: true,
        _resizeTimer: null,
        _renderTimer: null,
        showHeaderElements: false,
        headerTemplate: null,
        innerHeaderTpl: null,
        headerContainerCls: "sch-header-secondary-canvas",
        headerContainerEl: null,
        renderingDoneEvent: null,
        constructor: function (a) {
            this.uniqueCls = this.uniqueCls || ("sch-timespangroup-" + Ext.id());
            Ext.apply(this, a);
            this.mixins.observable.constructor.call(this);
            this.callParent(arguments)
        },
        setDisabled: function (a) {
            if (a) {
                this.removeElements()
            }
            this.disabled = a
        },
        removeElements: function () {
            this.removeBodyElements();
            if (this.showHeaderElements) {
                this.removeHeaderElements()
            }
        },
        getBodyElements: function () {
            if (this.containerEl) {
                return this.containerEl.select("." + this.uniqueCls)
            }
            return null
        },
        getHeaderContainerEl: function () {
            var c = this.headerContainerEl, b = Ext.baseCSSPrefix, a;
            if (!c || !c.dom) {
                if (this.schedulerView.isHorizontal()) {
                    a = this.panel.getHorizontalTimeAxisColumn().headerView.containerEl
                } else {
                    a = this.panel.el.down("." + b + "grid-inner-locked ." + b + "panel-body ." + b + "grid-view")
                }
                if (a) {
                    c = a.down("." + this.headerContainerCls);
                    if (!c) {
                        c = a.appendChild({cls: this.headerContainerCls})
                    }
                    this.headerContainerEl = c
                }
            }
            return c
        },
        getHeaderElements: function () {
            var a = this.getHeaderContainerEl();
            if (a) {
                return a.select("." + this.uniqueCls)
            }
            return null
        },
        removeBodyElements: function () {
            var a = this.getBodyElements();
            if (a) {
                a.each(function (b) {
                    b.destroy()
                })
            }
        },
        removeHeaderElements: function () {
            var a = this.getHeaderElements();
            if (a) {
                a.each(function (b) {
                    b.destroy()
                })
            }
        },
        getElementId: function (a) {
            return this.uniqueCls + "-" + a.internalId
        },
        getHeaderElementId: function (a) {
            return this.uniqueCls + "-header-" + a.internalId
        },
        getTemplateData: function (a) {
            return this.prepareTemplateData ? this.prepareTemplateData(a) : a.data
        },
        getElementCls: function (a, c) {
            var b = a.clsField || this.clsField;
            if (!c) {
                c = this.getTemplateData(a)
            }
            return this.cls + " " + this.uniqueCls + " " + (c[b] || "")
        },
        getHeaderElementCls: function (a, c) {
            var b = a.clsField || this.clsField;
            if (!c) {
                c = this.getTemplateData(a)
            }
            return "sch-header-indicator " + this.uniqueCls + " " + (c[b] || "")
        },
        init: function (a) {
            if (Ext.versions.touch && !a.isReady()) {
                a.on("viewready", function () {
                    this.init(a)
                }, this);
                return
            }
            if (Ext.isString(this.innerHeaderTpl)) {
                this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl)
            }
            var b = this.innerHeaderTpl;
            if (!this.headerTemplate) {
                this.headerTemplate = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="{cls}" style="{side}:{position}px;">' + (b ? "{[this.renderInner(values)]}" : "") + "</div>", "</tpl>", {
                    renderInner: function (c) {
                        return b.apply(c)
                    }
                })
            }
            this.schedulerView = a.getSchedulingView();
            this.panel = a;
            this.timeAxis = a.getTimeAxis();
            this.store = Ext.StoreManager.lookup(this.store);
            if (!this.store) {
                Ext.Error.raise("Error: You must define a store for this plugin")
            }
            if (!this.schedulerView.getEl()) {
                this.schedulerView.on({afterrender: this.onAfterRender, scope: this})
            } else {
                this.onAfterRender()
            }
        },
        onAfterRender: function (c) {
            var a = this.schedulerView;
            this.containerEl = a.getSecondaryCanvasEl();
            this.storeListeners = {
                load: this.renderElements,
                datachanged: this.renderElements,
                clear: this.renderElements,
                add: this.renderElements,
                remove: this.renderElements,
                update: this.refreshSingle,
                addrecords: this.renderElements,
                removerecords: this.renderElements,
                updaterecord: this.refreshSingle,
                expand: this.renderElements,
                collapse: this.renderElements,
                scope: this
            };
            this.store.on(this.storeListeners);
            a.on({
                bufferedrefresh: this.renderElements,
                refresh: this.renderElements,
                itemadd: this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
                itemremove: this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
                itemupdate: this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
                groupexpand: this.renderElements,
                groupcollapse: this.renderElements,
                columnwidthchange: this.renderElements,
                resize: this.renderElements,
                scope: this
            });
            if (a.headerCt) {
                a.headerCt.on({add: this.renderElements, remove: this.renderElements, scope: this})
            }
            this.panel.on({
                viewchange: this.renderElements,
                show: this.refreshSizes,
                modechange: this.forceNewRenderingTimeout,
                scope: this
            });
            var b = a.getRowContainerEl();
            if (b && b.down(".sch-timetd")) {
                this.renderElements()
            }
        },
        forceNewRenderingTimeout: function () {
            this.renderElementsBuffered = false;
            clearTimeout(this._renderTimer);
            clearTimeout(this._resizeTimer);
            this.renderElements()
        },
        refreshSizesInternal: function () {
            if (!this.schedulerView.isDestroyed && this.schedulerView.isHorizontal()) {
                var a = this.schedulerView.getTimeSpanRegion(new Date(), null, this.expandToFitView);
                this.getBodyElements().setHeight(a.bottom - a.top)
            }
        },
        refreshSizes: function () {
            clearTimeout(this._resizeTimer);
            this._resizeTimer = Ext.Function.defer(this.refreshSizesInternal, this.renderDelay, this)
        },
        renderElements: function () {
            if (this.renderElementsBuffered || this.disabled) {
                return
            }
            this.renderElementsBuffered = true;
            clearTimeout(this._renderTimer);
            this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this)
        },
        setElementX: function (b, a) {
            if (this.panel.rtl) {
                b.setRight(a)
            } else {
                b.setLeft(a)
            }
        },
        getHeaderElementPosition: function (b) {
            var a = this.schedulerView.getTimeAxisViewModel();
            return Math.round(a.getPositionFromDate(b))
        },
        renderBodyElementsInternal: function (a) {
            Ext.DomHelper.append(this.containerEl, this.generateMarkup(false, a))
        },
        getHeaderElementData: function (a, b) {
            throw"Abstract method call"
        },
        renderHeaderElementsInternal: function (a) {
            var b = this.getHeaderContainerEl();
            if (b) {
                Ext.DomHelper.append(b, this.generateHeaderMarkup(false, a))
            }
        },
        renderElementsInternal: function () {
            this.renderElementsBuffered = false;
            if (this.disabled || this.schedulerView.isDestroyed) {
                return
            }
            if (Ext.versions.extjs && !this.schedulerView.el.down("." + Ext.baseCSSPrefix + "grid-item-container")) {
                return
            }
            this.removeElements();
            this.renderBodyElementsInternal();
            if (this.showHeaderElements) {
                this.headerContainerEl = null;
                this.renderHeaderElementsInternal()
            }
            if (this.renderingDoneEvent) {
                this.fireEvent(this.renderingDoneEvent, this)
            }
        },
        generateMarkup: function (c, b) {
            var e = this.timeAxis.getStart(), a = this.timeAxis.getEnd(), d = this.getElementData(e, a, b, c);
            return this.template.apply(d)
        },
        generateHeaderMarkup: function (b, a) {
            var c = this.getHeaderElementData(a, b);
            return this.headerTemplate.apply(c)
        },
        getElementData: function (d, c, a, b) {
            throw"Abstract method call"
        },
        updateBodyElement: function (b) {
            var c = Ext.get(this.getElementId(b));
            if (c) {
                var e = this.timeAxis.getStart(), a = this.timeAxis.getEnd(), d = this.getElementData(e, a, [b])[0];
                if (d) {
                    c.dom.className = d.$cls;
                    c.setTop(d.top);
                    this.setElementX(c, d.left);
                    c.setSize(d.width, d.height)
                } else {
                    Ext.destroy(c)
                }
            } else {
                this.renderBodyElementsInternal([b])
            }
        },
        updateHeaderElement: function (a) {
            var b = Ext.get(this.getHeaderElementId(a));
            if (b) {
                var c = this.getHeaderElementData([a])[0];
                if (c) {
                    b.dom.className = c.cls;
                    if (this.schedulerView.isHorizontal()) {
                        this.setElementX(b, c.position);
                        b.setWidth(c.size)
                    } else {
                        b.setTop(c.position);
                        b.setHeight(c.size)
                    }
                } else {
                    Ext.destroy(b)
                }
            } else {
                this.renderHeaderElementsInternal([a])
            }
        },
        destroy: function () {
            clearTimeout(this._renderTimer);
            clearTimeout(this._resizeTimer);
            if (this.store.autoDestroy) {
                this.store.destroy()
            }
            this.store.un(this.storeListeners)
        },
        refreshSingle: function (b, a) {
            a = a instanceof Array ? a : [a];
            Ext.Array.forEach(a, function (c) {
                this.updateBodyElement(c);
                if (this.showHeaderElements) {
                    this.updateHeaderElement(c)
                }
            }, this)
        }
    })
}
Ext.define("Sch.plugin.Lines", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_lines",
    cls: "sch-timeline",
    showTip: true,
    innerTpl: null,
    prepareTemplateData: null,
    side: null,
    init: function (a) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl)
        }
        this.side = a.rtl ? "right" : "left";
        var b = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ' : "") + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px">' + (b ? "{[this.renderInner(values)]}" : "") + "</div>", "</tpl>", {
                getTipText: function (c) {
                    return a.getSchedulingView().getFormattedDate(c.Date) + " " + (c.Text || "")
                }, renderInner: function (c) {
                    return b.apply(c)
                }
            })
        }
        this.callParent(arguments)
    },
    generateMarkup: function (b, a) {
        return this.schedulerView.getMode() === "calendar" ? "" : this.callParent(arguments)
    },
    generateHeaderMarkup: function (b, a) {
        return this.schedulerView.getMode() === "calendar" ? "" : this.callParent(arguments)
    },
    getElementData: function (m, q, c) {
        var t = this.store, j = this.schedulerView, p = j.isHorizontal(), f = c || t.getRange(), h = [], r, a, o = j.getTimeSpanRegion(m, null, this.expandToFitView), k, b, e;
        if (Ext.versions.touch) {
            r = "100%"
        } else {
            r = p ? o.bottom - o.top : 1
        }
        a = p ? 1 : o.right - o.left;
        for (var g = 0, d = f.length; g < d; g++) {
            k = f[g];
            b = k.get("Date");
            if (b && Sch.util.Date.betweenLesser(b, m, q)) {
                var n = j.getCoordinateFromDate(b);
                e = Ext.apply({}, this.getTemplateData(k));
                e.id = this.getElementId(k);
                e.$cls = this.getElementCls(k, e);
                e.width = a;
                e.height = r;
                if (p) {
                    e.left = n
                } else {
                    e.top = n
                }
                h.push(e)
            }
        }
        return h
    },
    getHeaderElementData: function (c) {
        var a = this.timeAxis.getStart(), k = this.timeAxis.getEnd(), m = this.schedulerView.isHorizontal(), g = [], h, b, j, e;
        c = c || this.store.getRange();
        for (var f = 0, d = c.length; f < d; f++) {
            h = c[f];
            b = h.get("Date");
            if (b && Sch.util.Date.betweenLesser(b, a, k)) {
                j = this.getHeaderElementPosition(b);
                e = this.getTemplateData(h);
                e = Ext.apply({side: m ? this.side : "top", cls: this.getHeaderElementCls(h, e), position: j}, e);
                e.id = this.getHeaderElementId(h);
                g.push(e)
            }
        }
        return g
    }
});
Ext.define("Sch.plugin.Zones", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_zones",
    requires: ["Sch.model.Range"],
    innerTpl: null,
    cls: "sch-zone",
    side: null,
    init: function (a) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl)
        }
        this.side = a.rtl ? "right" : "left";
        var b = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for="."><div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' + (b ? "{[this.renderInner(values)]}" : "") + "</div></tpl>", {
                renderInner: function (c) {
                    return b.apply(c)
                }
            })
        }
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl)
        }
        this.callParent(arguments)
    },
    getElementData: function (h, d, r, f) {
        var g = this.schedulerView, t = [];
        var c = g.getTimeSpanRegion(h, d, this.expandToFitView);
        var b, k, a, j, n, e;
        r = r || this.store.getRange();
        for (var q = 0, p = r.length; q < p; q++) {
            b = r[q];
            k = b.getStartDate();
            a = b.getEndDate();
            e = this.getTemplateData(b);
            if (k && a && Sch.util.Date.intersectSpans(k, a, h, d)) {
                j = Ext.apply({}, e);
                j.id = this.getElementId(b);
                j.$cls = this.getElementCls(b, e);
                var m = g.getMode();
                if (m === "calendar") {
                    var s = g.getTimeSpanRegion(k, a);
                    j.left = s.left;
                    j.top = s.top;
                    j.height = s.bottom - s.top;
                    j.width = s.right - s.left
                } else {
                    var u = g.getCoordinateFromDate(Sch.util.Date.max(k, h));
                    var o = g.getCoordinateFromDate(Sch.util.Date.min(a, d));
                    if (m === "horizontal") {
                        j.left = u;
                        j.top = c.top;
                        j.width = f ? 0 : o - u;
                        j.height = c.bottom - c.top;
                        j.style = f ? ("border-left-width:" + (o - u) + "px") : ""
                    } else {
                        j.left = c.left;
                        j.top = u;
                        j.height = f ? 0 : o - u;
                        j.width = c.right - c.left;
                        j.style = f ? ("border-top-width:" + (o - u) + "px") : ""
                    }
                }
                t.push(j)
            }
        }
        return t
    },
    getHeaderElementId: function (b, a) {
        return this.callParent([b]) + (a ? "-start" : "-end")
    },
    getHeaderElementCls: function (b, d, a) {
        var c = b.clsField || this.clsField;
        if (!d) {
            d = this.getTemplateData(b)
        }
        return "sch-header-indicator sch-header-indicator-" + (a ? "start " : "end ") + this.uniqueCls + " " + (d[c] || "")
    },
    getZoneHeaderElementData: function (b, h, f, a) {
        var c = a ? f.getStartDate() : f.getEndDate(), e = null, g, i, d;
        if (c && Sch.util.Date.betweenLesser(c, b, h)) {
            g = this.getHeaderElementPosition(c);
            i = this.schedulerView.isHorizontal();
            d = this.getTemplateData(f);
            e = Ext.apply({
                id: this.getHeaderElementId(f, a),
                cls: this.getHeaderElementCls(f, d, a),
                isStart: a,
                side: i ? this.side : "top",
                position: g
            }, d)
        }
        return e
    },
    getHeaderElementData: function (b) {
        var a = this.timeAxis.getStart(), h = this.timeAxis.getEnd(), e = [], g, d, j;
        b = b || this.store.getRange();
        for (var f = 0, c = b.length; f < c; f++) {
            g = b[f];
            d = this.getZoneHeaderElementData(a, h, g, true);
            if (d) {
                e.push(d)
            }
            j = this.getZoneHeaderElementData(a, h, g, false);
            if (j) {
                e.push(j)
            }
        }
        return e
    },
    updateZoneHeaderElement: function (a, b) {
        a.dom.className = b.cls;
        if (this.schedulerView.isHorizontal()) {
            this.setElementX(a, b.position)
        } else {
            a.setTop(b.position)
        }
    },
    updateHeaderElement: function (c) {
        var a = this.timeAxis.getStart(), g = this.timeAxis.getEnd(), f = Ext.get(this.getHeaderElementId(c, true)), e = Ext.get(this.getHeaderElementId(c, false)), d = this.getZoneHeaderElementData(a, g, c, true), b = this.getZoneHeaderElementData(a, g, c, false);
        if (!(f && b) || !(e && b)) {
            Ext.destroy(f, e);
            this.renderHeaderElementsInternal([c])
        } else {
            if (f) {
                if (!d) {
                    Ext.destroy(f)
                } else {
                    this.updateZoneHeaderElement(f, d)
                }
            }
            if (e) {
                if (!b) {
                    Ext.destroy(e)
                } else {
                    this.updateZoneHeaderElement(e, b)
                }
            }
        }
    }
});
Ext.define("Sch.plugin.Pan", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.scheduler_pan",
    lockableScope: "top",
    enableVerticalPan: true,
    statics: {KEY_SHIFT: 1, KEY_CTRL: 2, KEY_ALT: 4, KEY_ALL: 7},
    disableOnKey: 0,
    constructor: function (a) {
        Ext.apply(this, a)
    },
    init: function (a) {
        if (Ext.supports.Touch) {
            return
        }
        this.view = a.getSchedulingView();
        this.view.on("afterrender", this.onRender, this)
    },
    onRender: function (a) {
        this.view.el.on("mousedown", this.onMouseDown, this)
    },
    onMouseDown: function (d, c) {
        var b = this.self, a = this.disableOnKey;
        if ((d.shiftKey && (a & b.KEY_SHIFT)) || (d.ctrlKey && (a & b.KEY_CTRL)) || (d.altKey && (a & b.KEY_ALT))) {
            return
        }
        if (d.getTarget("." + this.view.timeCellCls, 10) && !d.getTarget(this.view.eventSelector)) {
            this.mouseX = d.getX();
            this.mouseY = d.getY();
            Ext.getBody().on("mousemove", this.onMouseMove, this);
            Ext.getDoc().on("mouseup", this.onMouseUp, this);
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on("mouseenter", this.onMouseUp, this)
            }
            d.stopEvent()
        }
    },
    onMouseMove: function (d) {
        if (this.disabled) {
            return
        }
        d.stopEvent();
        var a = d.getX();
        var f = d.getY();
        var b = 0, c = this.mouseX - a;
        if (this.enableVerticalPan) {
            b = this.mouseY - f
        }
        this.mouseX = a;
        this.mouseY = f;
        this.view.scrollBy(c, b, false)
    },
    onMouseUp: function (a) {
        Ext.getBody().un("mousemove", this.onMouseMove, this);
        Ext.getDoc().un("mouseup", this.onMouseUp, this);
        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un("mouseenter", this.onMouseUp, this)
        }
    }
});
Ext.define("Sch.tooltip.ClockTemplate", {
    extend: "Ext.XTemplate",
    minuteHeight: 8,
    minuteTop: 2,
    hourHeight: 8,
    hourTop: 2,
    handLeft: 10,
    getRotateStyle: function (a) {
        return "transform:rotate(Ddeg);-ms-transform:rotate(Ddeg);-moz-transform: rotate(Ddeg);-webkit-transform: rotate(Ddeg);-o-transform:rotate(Ddeg);".replace(/D/g, a)
    },
    getRotateStyleIE: (function () {
        var c = Math.PI / 180, b = Math.cos, a = Math.sin;
        return function (d, j, n) {
            var g = this, h = d * c, f = b(h), l = a(h), i = n * a((90 - d) * c), k = n * b((90 - d) * c), m = Math.min(n, n - i), e = d > 180 ? k : 0, o = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + f + ", M12 = " + (-l) + ", M21 = " + l + ", M22 = " + f + ")";
            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", o, m + j, e + g.handLeft)
        }
    })(),
    constructor: function () {
        var a = Ext.isIE && Ext.isIE8m;
        this.callParent(['<div class="sch-clockwrap ' + (a ? "" : "sch-supports-border-radius") + ' {cls}"><div class="sch-clock"><div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ", + " + this.hourHeight + ')]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div><div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6,' + this.minuteTop + ", + " + this.minuteHeight + ')]}">{[values.date.getDate()]}</div>' + (a ? "" : '<div class="sch-clock-dot"></div>') + '</div><span class="sch-clock-text">{text}</span></div>', {
            disableFormats: true,
            getMinuteStyle: a ? this.getRotateStyleIE : this.getRotateStyle,
            getHourStyle: a ? this.getRotateStyleIE : this.getRotateStyle
        }])
    }
});
Ext.define("Sch.tooltip.Tooltip", {
    extend: "Ext.tip.ToolTip",
    requires: ["Sch.tooltip.ClockTemplate"],
    autoHide: false,
    anchor: "b",
    padding: "0 3 0 0",
    showDelay: 0,
    hideDelay: 0,
    quickShowInterval: 0,
    dismissDelay: 0,
    trackMouse: false,
    anchorOffset: 5,
    shadow: false,
    frame: false,
    schedulerView: null,
    message: null,
    startDate: null,
    endDate: null,
    template: null,
    valid: true,
    mode: null,
    offsetAdjust: [18, 5],
    constructor: function (b) {
        var a = new Sch.tooltip.ClockTemplate();
        this.startDate = this.endDate = new Date();
        if (!this.template) {
            this.template = Ext.create("Ext.XTemplate", '<div class="sch-tip-{[values.valid ? "ok" : "notok"]}">{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}<div class="sch-tip-message">{message}</div></div>', {
                disableFormats: true,
                renderClock: function (d, e, c) {
                    return a.apply({date: d, text: e, cls: c})
                }
            })
        }
        this.callParent(arguments)
    },
    update: function (a, g, f, e) {
        if (this.startDate - a !== 0 || this.endDate - g !== 0 || this.valid !== f || this.message !== e) {
            var d = (this.message && !e) || (!this.message && e);
            this.startDate = a;
            this.endDate = g;
            this.valid = f;
            this.message = e;
            var c = this.schedulerView.getFormattedDate(a), b = this.schedulerView.getFormattedEndDate(g, a);
            if (this.mode === "calendar" && g.getHours() === 0 && g.getMinutes() === 0 && !(g.getYear() === a.getYear() && g.getMonth() === a.getMonth() && g.getDate() === a.getDate())) {
                g = Sch.util.Date.add(g, Sch.util.Date.DAY, -1)
            }
            this.callParent([this.template.apply({
                valid: f,
                startDate: a,
                endDate: g,
                startText: c,
                endText: b,
                message: e
            })]);
            if (d) {
                this.realign()
            }
        }
    },
    show: function (b, a) {
        if (!b || Ext.isArray(b)) {
            return
        }
        if (this.rendered === true) {
            this.setPosition(0, 0)
        }
        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = "calendar";
            this.addCls("sch-day-resolution");
            this.removeCls("sch-hour-resolution")
        } else {
            this.mode = "clock";
            this.removeCls("sch-day-resolution");
            this.addCls("sch-hour-resolution")
        }
        a = arguments.length > 1 ? a : this.offsetAdjust[0];
        this.mouseOffsets = [a - this.offsetAdjust[0], -this.offsetAdjust[1]];
        this.setTarget(b);
        this.callParent();
        this.realign()
    },
    realign: function () {
        this.el.alignTo(this.target, "bl-tl", this.mouseOffsets)
    },
    afterRender: function () {
        this.callParent(arguments);
        this.el.on("mouseenter", this.realign, this)
    }
});
Ext.define("Sch.tooltip.HoverTip", {
    extend: "Ext.tip.ToolTip",
    alias: "widget.scheduler_hovertip",
    requires: ["Sch.tooltip.ClockTemplate"],
    trackMouse: true,
    bodyCls: "sch-hovertip",
    messageTpl: '<div class="sch-hovertip-msg">{message}</div>',
    autoHide: false,
    dismissDelay: 1000,
    showDelay: 300,
    schedulerView: null,
    clockTpl: null,
    lastTime: null,
    lastResource: null,
    initComponent: function () {
        var b = this;
        var a = b.schedulerView;
        b.clockTpl = new Sch.tooltip.ClockTemplate();
        b.messageTpl = new Ext.XTemplate(b.messageTpl);
        b.lastTime = null;
        b.lastResource = null;
        b.callParent(arguments);
        b.on("beforeshow", b.tipOnBeforeShow, b);
        a.mon(a.el, {
            mouseleave: function () {
                b.hide()
            }, mousemove: b.handleMouseMove, scope: b
        })
    },
    handleMouseMove: function (f) {
        var c = this;
        var a = c.schedulerView;
        if (c.disabled) {
            return
        }
        if (f.getTarget("." + a.timeCellCls, 5) && !f.getTarget(a.eventSelector)) {
            var d = a.getDateFromDomEvent(f, "floor");
            if (d) {
                var b = a.resolveResource(f.getTarget());
                if (d - c.lastTime !== 0 || b !== c.lastResource) {
                    c.lastResource = b;
                    c.updateHoverTip(d, f);
                    if (c.hidden) {
                        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
                            c.addCls("sch-day-resolution");
                            c.removeCls("sch-hour-resolution")
                        } else {
                            c.removeCls("sch-day-resolution");
                            c.addCls("sch-hour-resolution")
                        }
                        c.show()
                    }
                }
            } else {
                c.hide();
                c.lastTime = null;
                c.lastResource = null
            }
        } else {
            c.hide();
            c.lastTime = null;
            c.lastResource = null
        }
    },
    getText: function () {
    },
    updateHoverTip: function (c, d) {
        if (c) {
            var b = this.clockTpl.apply({date: c, text: this.schedulerView.getFormattedDate(c)});
            var a = this.messageTpl.apply({message: this.getText(c, d)});
            this.update(b + a);
            this.lastTime = c
        }
    },
    tipOnBeforeShow: function (a) {
        return !this.disabled && this.lastTime !== null
    }
});
if (!Ext.ClassManager.get("Sch.view.model.TimeAxis")) {
    Ext.define("Sch.view.model.TimeAxis", {
        extend: "Ext.util.Observable",
        requires: ["Ext.Date", "Sch.util.Date", "Sch.preset.Manager"],
        timeAxis: null,
        availableWidth: 0,
        tickWidth: 100,
        snapToIncrement: false,
        forceFit: false,
        headerConfig: null,
        headers: null,
        mainHeader: 0,
        timeAxisColumnWidth: null,
        resourceColumnWidth: null,
        calendarColumnWidth: null,
        timeColumnWidth: null,
        rowHeightHorizontal: null,
        rowHeightVertical: null,
        mode: "horizontal",
        suppressFit: false,
        refCount: 0,
        columnConfig: {},
        viewPreset: null,
        columnLinesFor: "middle",
        eventStore: null,
        originalTickWidth: null,
        constructor: function (a) {
            var c = this;
            Ext.apply(this, a);
            if (this.viewPreset) {
                if (this.viewPreset instanceof Sch.preset.ViewPreset) {
                    this.consumeViewPreset(this.viewPreset)
                } else {
                    var b = Sch.preset.Manager.getPreset(this.viewPreset);
                    b && this.consumeViewPreset(b)
                }
            }
            c.timeAxis.on("reconfigure", c.onTimeAxisReconfigure, c);
            this.callParent(arguments)
        },
        destroy: function () {
            this.timeAxis.un("reconfigure", this.onTimeAxisReconfigure, this)
        },
        onTimeAxisReconfigure: function (a, b) {
            if (!b) {
                this.update()
            }
        },
        reconfigure: function (a) {
            this.headers = null;
            Ext.apply(this, a);
            switch (this.mode) {
                case"horizontal":
                    this.setTickWidth(this.timeColumnWidth);
                    break;
                case"vertical":
                    this.setTickWidth(this.rowHeightVertical);
                    break;
                case"calendar":
                    this.setTickWidth(this.rowHeightVertical);
                    break
            }
            this.fireEvent("reconfigure", this)
        },
        getColumnConfig: function () {
            return this.columnConfig
        },
        update: function (d, b) {
            var e = this.timeAxis, c = this.headerConfig;
            this.availableWidth = Math.max(d || this.availableWidth, 0);
            if (!Ext.isNumber(this.availableWidth)) {
                throw"Invalid available width provided to Sch.view.model.TimeAxis"
            }
            if (this.forceFit && this.availableWidth <= 0) {
                return
            }
            this.columnConfig = {};
            for (var f in c) {
                if (c[f].cellGenerator) {
                    this.columnConfig[f] = c[f].cellGenerator.call(this, e.getStart(), e.getEnd())
                } else {
                    this.columnConfig[f] = this.createHeaderRow(f, c[f])
                }
            }
            var a = this.calculateTickWidth(this.originalTickWidth);
            if (!Ext.isNumber(a) || a <= 0) {
                throw"Invalid column width calculated in Sch.view.model.TimeAxis"
            }
            this.updateTickWidth(a);
            if (!b) {
                this.fireEvent("update", this)
            }
        },
        createHeaderRow: function (a, d) {
            var c = [], e = this, f = d.align, b = Ext.Date.clearTime(new Date());
            e.forEachInterval(a, function (k, g, h) {
                var j = {align: f, start: k, end: g, headerCls: ""};
                if (d.renderer) {
                    j.header = d.renderer.call(d.scope || e, k, g, j, h, e.eventStore)
                } else {
                    j.header = Ext.Date.format(k, d.dateFormat)
                }
                if (d.unit === Sch.util.Date.DAY && (!d.increment || d.increment === 1)) {
                    j.headerCls += " sch-dayheadercell-" + k.getDay();
                    if (Ext.Date.clearTime(k, true) - b === 0) {
                        j.headerCls += " sch-dayheadercell-today"
                    }
                }
                c.push(j)
            });
            return c
        },
        getDistanceBetweenDates: function (b, a) {
            return Math.round(this.getPositionFromDate(a, true) - this.getPositionFromDate(b))
        },
        getPositionFromDate: function (e, d) {
            if (this.mode === "calendar") {
                var a = this.rowHeightCalendar || this.rowHeightVertical;
                var c = this.getHeaders();
                var b = this.timeAxis.getStart();
                var g = Sch.util.Date;
                var i = g.mergeDates(b, e, c[1].unit);
                var j = g.getDurationInUnit(b, i, c[1].unit, true) * a;
                var k = Math.round(j);
                if (k === 0 && d) {
                    return this.calendarRowsAmount * a
                }
                return k
            } else {
                var h = -1, f = this.timeAxis.getTickFromDate(e);
                if (f >= 0) {
                    h = Math.round(this.tickWidth * (f - this.timeAxis.visibleTickStart))
                }
                return h
            }
        },
        getDateFromPosition: function (i, l) {
            if (this.mode === "calendar") {
                var b = this.rowHeightCalendar || this.rowHeightVertical;
                var h = Sch.util.Date;
                var c = this.timeAxis.getStart();
                var d = this.getHeaders();
                var j = h.add(c, d[0].splitUnit, Math.floor(i[0] / this.calendarColumnWidth));
                var g = this.timeAxis.first();
                var e = (g.get("end") - g.get("start")) / b;
                var k = h.add(j, h.MILLI, Math.round(i[1] * e));
                if (l) {
                    k = this.timeAxis[l + "Date"](k)
                }
                return k
            } else {
                var f = i / this.getTickWidth() + this.timeAxis.visibleTickStart, a = this.timeAxis.getCount();
                if (f < 0 || f > a) {
                    return null
                }
                return this.timeAxis.getDateFromTick(f, l)
            }
        },
        getSingleUnitInPixels: function (a) {
            return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), a) * this.tickWidth / this.timeAxis.increment
        },
        getSnapPixelAmount: function () {
            if (this.snapToIncrement) {
                var a = this.timeAxis.getResolution();
                return (a.increment || 1) * this.getSingleUnitInPixels(a.unit)
            } else {
                return 1
            }
        },
        getTickWidth: function () {
            return this.tickWidth
        },
        setTickWidth: function (b, a) {
            this.originalTickWidth = b;
            this.updateTickWidth(b);
            this.update(null, a)
        },
        updateTickWidth: function (a) {
            this.tickWidth = a;
            switch (this.mode) {
                case"horizontal":
                    this.timeColumnWidth = a;
                    break;
                case"vertical":
                    this.rowHeightVertical = a;
                    break;
                case"calendar":
                    this.rowHeightVertical = a;
                    break
            }
        },
        getTotalWidth: function () {
            return Math.round(this.tickWidth * this.timeAxis.getVisibleTickTimeSpan())
        },
        calculateTickWidth: function (e) {
            var k = this.forceFit;
            var h = this.timeAxis;
            var c = 0, g = h.getUnit(), j = Number.MAX_VALUE, d = Sch.util.Date;
            if (this.snapToIncrement) {
                var f = h.getResolution();
                j = d.getUnitToBaseUnitRatio(g, f.unit) * f.increment
            } else {
                var i = d.getMeasuringUnit(g);
                j = Math.min(j, d.getUnitToBaseUnitRatio(g, i))
            }
            if (!this.suppressFit) {
                var b = Math[k ? "floor" : "round"](this.getAvailableWidth() / h.getVisibleTickTimeSpan());
                c = (k || e < b) ? b : e;
                if (j > 0 && (!k || j < 1)) {
                    var a = Ext.versions.touch && k ? "ceil" : (k ? "floor" : "round");
                    c = Math.round(Math.max(1, Math[a](j * c)) / j)
                }
            } else {
                c = e
            }
            return c
        },
        getAvailableWidth: function () {
            return this.availableWidth
        },
        setAvailableWidth: function (a) {
            this.availableWidth = Math.max(0, a);
            var b = this.calculateTickWidth(this.originalTickWidth);
            if (b !== this.tickWidth) {
                this.update()
            }
        },
        fitToAvailableWidth: function (a) {
            var b = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());
            this.setTickWidth(b, a)
        },
        setForceFit: function (a) {
            if (a !== this.forceFit) {
                this.forceFit = a;
                this.update()
            }
        },
        setSnapToIncrement: function (a) {
            if (a !== this.snapToIncrement) {
                this.snapToIncrement = a;
                this.update()
            }
        },
        getViewRowHeight: function () {
            var a = this.mode == "horizontal" ? this.rowHeightHorizontal : this.rowHeightVertical;
            if (!a) {
                throw"rowHeight info not available"
            }
            return a
        },
        setViewRowHeight: function (c, a) {
            var d = this.mode === "horizontal";
            var b = "rowHeight" + Ext.String.capitalize(this.mode);
            if (this[b] != c) {
                this[b] = c;
                if (d) {
                    if (!a) {
                        this.fireEvent("update", this)
                    }
                } else {
                    this.setTickWidth(c, a)
                }
            }
        },
        setViewColumnWidth: function (b, a) {
            switch (this.mode) {
                case"horizontal":
                    this.setTickWidth(b, a);
                    break;
                case"vertical":
                    this.resourceColumnWidth = b;
                    break;
                case"calendar":
                    this.calendarColumnWidth = b;
                    break
            }
            if (!a) {
                this.fireEvent("columnwidthchange", this, b)
            }
        },
        getHeaders: function () {
            if (this.headers) {
                return this.headers
            }
            var a = this.headerConfig;
            this.mainHeader = a.top ? 1 : 0;
            return this.headers = [].concat(a.top || [], a.middle || [], a.bottom || [])
        },
        getMainHeader: function () {
            return this.getHeaders()[this.mainHeader]
        },
        getBottomHeader: function () {
            var a = this.getHeaders();
            return a[a.length - 1]
        },
        forEachInterval: function (b, a, d) {
            d = d || this;
            var c = this.headerConfig;
            if (!c) {
                return
            }
            if (b === "top" || (b === "middle" && c.bottom)) {
                var e = c[b];
                this.timeAxis.forEachAuxInterval(e.unit, e.increment, a, d)
            } else {
                this.timeAxis.each(function (g, f) {
                    return a.call(d, g.data.start, g.data.end, f)
                })
            }
        },
        forEachMainInterval: function (a, b) {
            this.forEachInterval("middle", a, b)
        },
        consumeViewPreset: function (a) {
            this.headers = null;
            var b = this.mode == "horizontal";
            Ext.apply(this, {
                headerConfig: a.headerConfig,
                columnLinesFor: a.columnLinesFor || "middle",
                rowHeightHorizontal: a.rowHeight,
                tickWidth: b ? a.timeColumnWidth : a.timeRowHeight || a.timeColumnWidth || 60,
                timeColumnWidth: a.timeColumnWidth,
                rowHeightVertical: a.timeRowHeight || a.timeColumnWidth || 60,
                timeAxisColumnWidth: a.timeAxisColumnWidth,
                resourceColumnWidth: a.resourceColumnWidth || 100
            });
            this.originalTickWidth = this.tickWidth
        }
    })
}
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: "Ext.util.Observable",
    requires: ["Ext.XTemplate"],
    trackHeaderOver: true,
    compactCellWidthThreshold: 15,
    baseCls: "sch-column-header",
    tableCls: "sch-header-row",
    headerHtmlRowTpl: '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}"><thead><tr><tpl for="cells"><td class="{{baseCls}} {headerCls}" style="position : static; text-align: {align}; width: {width}px; {style}" tabIndex="0"headerPosition="{parent.position}" headerIndex="{[xindex-1]}"><div class="sch-simple-timeheader">{header}</div></td></tpl></tr></thead></table>',
    model: null,
    hoverCls: "",
    containerEl: null,
    height: null,
    constructor: function (d) {
        var e = this;
        var b = !!Ext.versions.touch;
        var a = b ? "tap" : "click";
        Ext.apply(this, d);
        e.callParent(arguments);
        e.model.on("update", e.onModelUpdate, this, {priority: 5});
        e.containerEl = Ext.get(e.containerEl);
        if (!(e.headerHtmlRowTpl instanceof Ext.Template)) {
            e.headerHtmlRowTpl = e.headerHtmlRowTpl.replace("{{baseCls}}", this.baseCls).replace("{{tableCls}}", this.tableCls);
            e.headerHtmlRowTpl = new Ext.XTemplate(e.headerHtmlRowTpl)
        }
        if (e.trackHeaderOver && e.hoverCls) {
            e.containerEl.on({mousemove: e.highlightCell, delegate: ".sch-column-header", scope: e});
            e.containerEl.on({mouseleave: e.clearHighlight, scope: e})
        }
        var c = {scope: this, delegate: ".sch-column-header"};
        if (b) {
            c.tap = this.onElClick("tap");
            c.doubletap = this.onElClick("doubletap")
        } else {
            c.click = this.onElClick("click");
            c.dblclick = this.onElClick("dblclick");
            c.contextmenu = this.onElClick("contextmenu")
        }
        e._listenerCfg = c;
        if (e.containerEl) {
            e.containerEl.on(c)
        }
    },
    destroy: function () {
        var a = this;
        if (a.containerEl) {
            a.containerEl.un(a._listenerCfg);
            a.containerEl.un({mousemove: a.highlightCell, delegate: ".sch-simple-timeheader", scope: a});
            a.containerEl.un({mouseleave: a.clearHighlight, scope: a})
        }
        a.model.un({update: a.onModelUpdate, scope: a})
    },
    onModelUpdate: function () {
        this.render()
    },
    getHTML: function (e, h, d) {
        var i = this.model.getColumnConfig();
        var g = this.model.getTotalWidth();
        var c = Ext.Object.getKeys(i).length;
        var b = this.height ? this.height / c : 0;
        var f = "";
        var a;
        if (i.top) {
            this.embedCellWidths(i.top);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.top,
                position: "top",
                tstyle: "border-top : 0;" + (b ? "height:" + b + "px" : "")
            })
        }
        if (i.middle) {
            this.embedCellWidths(i.middle);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.middle,
                position: "middle",
                tstyle: (i.top ? "" : "border-top : 0;") + (b ? "height:" + b + "px" : ""),
                cls: !i.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? "sch-header-row-compact" : ""
            })
        }
        if (i.bottom) {
            this.embedCellWidths(i.bottom);
            f += this.headerHtmlRowTpl.apply({
                totalWidth: g,
                cells: i.bottom,
                position: "bottom",
                tstyle: (b ? "height:" + b + "px" : ""),
                cls: this.model.getTickWidth() <= this.compactCellWidthThreshold ? "sch-header-row-compact" : ""
            })
        }
        return f + '<div class="sch-header-secondary-canvas"></div>'
    },
    render: function () {
        if (!this.containerEl) {
            return
        }
        var e = this.containerEl, f = e.dom, d = f.style.display, a = this.model.getColumnConfig(), b = f.parentNode;
        f.style.display = "none";
        b.removeChild(f);
        var c = this.getHTML();
        f.innerHTML = c;
        if (!a.top && !a.middle) {
            this.containerEl.addCls("sch-header-single-row")
        } else {
            this.containerEl.removeCls("sch-header-single-row")
        }
        b && b.appendChild(f);
        f.style.display = d;
        this.fireEvent("refresh", this)
    },
    embedCellWidths: function (b) {
        var e = (Ext.isIE7 || (Ext.isSafari && !Ext.supports.Touch)) ? 1 : 0;
        for (var c = 0; c < b.length; c++) {
            var a = b[c];
            var d = this.model.getDistanceBetweenDates(a.start, a.end);
            if (d) {
                a.width = d - (c ? e : 0)
            } else {
                a.width = 0;
                a.style = "display: none"
            }
        }
    },
    onElClick: function (a) {
        return function (e, f) {
            f = e.delegatedTarget || f;
            var b = Ext.fly(f).getAttribute("headerPosition"), c = Ext.fly(f).getAttribute("headerIndex"), d = this.model.getColumnConfig()[b][c];
            this.fireEvent("timeheader" + a, this, d.start, d.end, e)
        }
    },
    highlightCell: function (c, a) {
        var b = this;
        if (a !== b.highlightedCell) {
            b.clearHighlight();
            b.highlightedCell = a;
            Ext.fly(a).addCls(b.hoverCls)
        }
    },
    clearHighlight: function () {
        var b = this, a = b.highlightedCell;
        if (a) {
            Ext.fly(a).removeCls(b.hoverCls);
            delete b.highlightedCell
        }
    }
});
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend: "Ext.grid.column.Column",
    alias: "widget.timeaxiscolumn",
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    fixed: true,
    menuDisabled: true,
    cls: "sch-simple-timeaxis",
    tdCls: "sch-timetd",
    enableLocking: false,
    requires: ["Sch.view.HorizontalTimeAxis"],
    timeAxisViewModel: null,
    headerView: null,
    hoverCls: "",
    ownHoverCls: "sch-column-header-over",
    trackHeaderOver: true,
    compactCellWidthThreshold: 20,
    afterRender: function () {
        var b = this;
        var a = b.titleEl.createChild({cls: "sch-horizontaltimeaxis-ct"});
        b.headerView = new Sch.view.HorizontalTimeAxis({
            model: b.timeAxisViewModel,
            containerEl: a,
            hoverCls: b.ownHoverCls,
            trackHeaderOver: b.trackHeaderOver,
            compactCellWidthThreshold: b.compactCellWidthThreshold
        });
        b.headerView.on("refresh", b.onTimeAxisViewRefresh, b);
        b.ownerCt.on("afterlayout", function () {
            if (!b.ownerCt) {
                return
            }
            b.mon(b.ownerCt, "resize", b.onHeaderContainerResize, b);
            if (this.getWidth() > 0) {
                if (b.getAvailableWidthForSchedule() === b.timeAxisViewModel.getAvailableWidth()) {
                    b.headerView.render()
                } else {
                    b.timeAxisViewModel.update(b.getAvailableWidthForSchedule())
                }
                b.setWidth(b.timeAxisViewModel.getTotalWidth())
            }
        }, null, {single: true});
        this.enableBubble("timeheaderclick", "timeheaderdblclick", "timeheadercontextmenu");
        b.relayEvents(b.headerView, ["timeheaderclick", "timeheaderdblclick", "timeheadercontextmenu"]);
        b.callParent(arguments);
        b.focusable = false
    },
    initRenderData: function () {
        var a = this;
        a.renderData.headerCls = a.renderData.headerCls || a.headerCls;
        return a.callParent(arguments)
    },
    destroy: function () {
        if (this.headerView) {
            this.headerView.destroy()
        }
        this.callParent(arguments)
    },
    onTimeAxisViewRefresh: function () {
        this.headerView.un("refresh", this.onTimeAxisViewRefresh, this);
        this.setWidth(this.timeAxisViewModel.getTotalWidth());
        this.headerView.on("refresh", this.onTimeAxisViewRefresh, this)
    },
    getAvailableWidthForSchedule: function () {
        var d = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : (this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0), a = this.ownerCt.items, c;
        for (var b = 1; b < a.length; b++) {
            c = a.get(b);
            if (!c.hidden) {
                d -= c.isVisible(true) ? c.getWidth() : (c.lastBox && c.lastBox.width || 0)
            }
        }
        return d - Ext.getScrollbarSize().width - 1
    },
    onResize: function () {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule())
    },
    onHeaderContainerResize: function () {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        this.headerView.render()
    },
    refresh: function () {
        this.timeAxisViewModel.update(null, true);
        this.headerView.render()
    }
});
Ext.define("Sch.plugin.TreeCellEditing", {
    extend: "Ext.grid.plugin.CellEditing",
    alias: "plugin.scheduler_treecellediting",
    lockableScope: "locked",
    editorsStarted: 0,
    init: function (a) {
        this._grid = a;
        this.on("beforeedit", this.onMyBeforeEdit, this);
        this.callParent(arguments)
    },
    showEditor: function (a) {
        var b = this, c = a.field;
        if (!a._cancelEdit) {
            a._cancelEdit = a.cancelEdit;
            a.cancelEdit = b.myCancelEdit
        }
        if (c.setSuppressTaskUpdate) {
            c.setSuppressTaskUpdate(true)
        }
        this.callParent(arguments);
        if (c.setSuppressTaskUpdate) {
            c.setSuppressTaskUpdate(false)
        }
    },
    checkReadOnly: function () {
        var a = this._grid;
        if (!(a instanceof Sch.panel.TimelineTreePanel)) {
            a = a.up("tablepanel")
        }
        return !a.isReadOnly()
    },
    onEditComplete: function (b, d, a) {
        var c = this;
        if (b.field.applyChanges) {
            b.field.applyChanges(b.field.task || c.context.record);
            return c.callParent([b, d, d])
        } else {
            return c.callParent([b, d, a])
        }
    },
    myCancelEdit: function () {
        var b = this, d = b.field;
        if (d && d.applyChanges) {
            var c = d.instantUpdate;
            d.instantUpdate = true;
            var a = b._cancelEdit.apply(this, arguments);
            d.instantUpdate = c;
            return a
        } else {
            return b._cancelEdit.apply(this, arguments)
        }
    },
    onMyBeforeEdit: function (b, a) {
        var c = a.column.getEditor();
        if (this.editing) {
            this.completeEdit()
        }
        if (c) {
            if (c.setTask) {
                c.setTask(a.record);
                a.value = a.originalValue = c.getValue()
            }
        }
        return this.checkReadOnly()
    }
});
Ext.define("Sch.feature.ResizeZone", {
    extend: "Ext.util.Observable",
    requires: ["Ext.resizer.Resizer", "Sch.tooltip.Tooltip", "Sch.util.ScrollManager"],
    showTooltip: true,
    showExactResizePosition: false,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    schedulerView: null,
    origEl: null,
    handlePos: null,
    eventRec: null,
    tip: null,
    tipInstance: null,
    startScroll: null,
    constructor: function (a) {
        Ext.apply(this, a);
        var b = this.schedulerView;
        b.on({destroy: this.cleanUp, scope: this});
        b.mon(b.el, {
            mousedown: this.onMouseDown,
            mouseup: this.onMouseUp,
            scope: this,
            delegate: ".sch-resizable-handle"
        });
        this.callParent(arguments)
    },
    onMouseDown: function (f, a) {
        var b = this.schedulerView;
        var d = this.eventRec = b.resolveEventRecord(a);
        var c = d.isResizable();
        if (f.button !== 0 || (c === false || typeof c === "string" && !a.className.match(c))) {
            return
        }
        this.eventRec = d;
        this.handlePos = this.getHandlePosition(a);
        this.origEl = Ext.get(f.getTarget(".sch-event"));
        b.el.on({mousemove: this.onMouseMove, scope: this, single: true})
    },
    onMouseUp: function (c, a) {
        var b = this.schedulerView;
        b.el.un({mousemove: this.onMouseMove, scope: this, single: true})
    },
    getTipInstance: function () {
        if (this.tipInstance) {
            return this.tipInstance
        }
        var a = this.schedulerView;
        var c = this.tip;
        var b = a.up("[lockable=true]").el;
        if (c instanceof Ext.tip.ToolTip) {
            Ext.applyIf(c, {schedulerView: a})
        } else {
            c = new Sch.tooltip.Tooltip(Ext.apply({
                rtl: this.rtl,
                schedulerView: a,
                constrainTo: b,
                cls: "sch-resize-tip",
                onMyMouseMove: function (d) {
                    this.el.alignTo(this.target, "bl-tl", [d.getX() - this.target.getX(), -5])
                }
            }, c))
        }
        return this.tipInstance = c
    },
    onMouseMove: function (h, a) {
        var b = this.schedulerView, g = this.eventRec, d = this.handlePos;
        if (!g || b.fireEvent("beforeeventresize", b, g, h) === false) {
            return
        }
        delete this.eventRec;
        h.stopEvent();
        this.origEl.addCls("sch-event-resizing");
        this.resizer = this.createResizer(this.origEl, g, d);
        var c = this.resizer.resizeTracker;
        if (this.showTooltip) {
            var f = this.getTipInstance();
            f.setTarget(this.origEl);
            f.update(g.getStartDate(), g.getEndDate(), true);
            f.show(this.origEl)
        }
        c.onMouseDown(h, this.resizer[d].dom);
        c.onMouseMove(h, this.resizer[d].dom);
        b.fireEvent("eventresizestart", b, g);
        b.el.on("scroll", this.onViewElScroll, this)
    },
    getHandlePosition: function (b) {
        var a = b.className.match("start");
        if (this.schedulerView.getMode() === "horizontal") {
            if (this.schedulerView.rtl) {
                return a ? "east" : "west"
            }
            return a ? "west" : "east"
        } else {
            return a ? "north" : "south"
        }
    },
    createResizer: function (b, e, o) {
        var l = this.schedulerView, r = this, f = l.resolveResource(b), q = l.getSnapPixelAmount(), n = l.getScheduleRegion(f, e), p = l.getDateConstraints(f, e), m = b.getHeight(), g = (l.rtl && o[0] === "e") || (!l.rtl && o[0] === "w") || o[0] === "n", h = l.getMode() !== "horizontal", d = {
            otherEdgeX: g ? b.getRight() : b.getLeft(),
            otherEdgeY: g ? b.getBottom() : b.getTop(),
            target: b,
            isStart: g,
            startYOffset: b.getY() - b.parent().getY(),
            startXOffset: b.getX() - b.parent().getX(),
            dateConstraints: p,
            resourceRecord: f,
            eventRecord: e,
            handles: o[0],
            minHeight: m,
            constrainTo: n,
            listeners: {resizedrag: this.partialResize, resize: this.afterResize, scope: this}
        };
        var c = b.id;
        var j = "_" + c;
        b.id = b.dom.id = j;
        Ext.cache[j] = Ext.cache[c];
        if (h) {
            if (q > 0) {
                var i = b.getWidth();
                Ext.apply(d, {minHeight: q, minWidth: i, maxWidth: i, heightIncrement: q})
            }
        } else {
            if (q > 0) {
                Ext.apply(d, {minWidth: q, maxHeight: m, widthIncrement: q})
            }
        }
        var k = new Ext.resizer.Resizer(d);
        k.prevId = c;
        if (k.resizeTracker) {
            k.resizeTracker.tolerance = -1;
            var a = k.resizeTracker.updateDimensions;
            k.resizeTracker.updateDimensions = function (t) {
                if (!Ext.isWebKit || t.getTarget(".sch-timelineview")) {
                    var s;
                    if (h) {
                        s = l.el.getScroll().top - r.startScroll.top;
                        k.resizeTracker.minHeight = d.minHeight - Math.abs(s)
                    } else {
                        s = l.el.getScroll().left - r.startScroll.left;
                        k.resizeTracker.minWidth = d.minWidth - Math.abs(s)
                    }
                    a.apply(this, arguments)
                }
            };
            k.resizeTracker.resize = function (s) {
                var t;
                if (h) {
                    t = l.el.getScroll().top - r.startScroll.top;
                    if (o[0] === "s") {
                        s.y -= t
                    }
                    s.height += Math.abs(t)
                } else {
                    t = l.el.getScroll().left - r.startScroll.left;
                    if (o[0] === "e") {
                        s.x -= t
                    }
                    s.width += Math.abs(t)
                }
                Ext.resizer.ResizeTracker.prototype.resize.apply(this, arguments)
            }
        }
        b.setStyle("z-index", parseInt(b.getStyle("z-index"), 10) + 1);
        Sch.util.ScrollManager.activate(l, l.getMode() === "horizontal" ? "horizontal" : "vertical");
        this.startScroll = l.el.getScroll();
        return k
    },
    getStartEndDates: function () {
        var e = this.resizer, c = e.el, d = this.schedulerView, b = e.isStart, g, a, f;
        if (b) {
            if (d.getMode() === "horizontal") {
                f = [d.rtl ? c.getRight() : c.getLeft() + 1, c.getTop()]
            } else {
                f = [(c.getRight() + c.getLeft()) / 2, c.getTop()]
            }
            a = e.eventRecord.getEndDate();
            if (d.snapRelativeToEventStartDate) {
                g = d.getDateFromXY(f);
                g = d.timeAxis.roundDate(g, e.eventRecord.getStartDate())
            } else {
                g = d.getDateFromXY(f, "round")
            }
        } else {
            if (d.getMode() === "horizontal") {
                f = [d.rtl ? c.getLeft() : c.getRight(), c.getBottom()]
            } else {
                f = [(c.getRight() + c.getLeft()) / 2, c.getBottom()]
            }
            g = e.eventRecord.getStartDate();
            if (d.snapRelativeToEventStartDate) {
                a = d.getDateFromXY(f);
                a = d.timeAxis.roundDate(a, e.eventRecord.getEndDate())
            } else {
                a = d.getDateFromXY(f, "round")
            }
        }
        g = g || e.start;
        a = a || e.end;
        if (e.dateConstraints) {
            g = Sch.util.Date.constrain(g, e.dateConstraints.start, e.dateConstraints.end);
            a = Sch.util.Date.constrain(a, e.dateConstraints.start, e.dateConstraints.end)
        }
        return {start: g, end: a}
    },
    partialResize: function (o, t, p, u) {
        var m = this.schedulerView, g = u.type === "scroll" ? this.resizer.resizeTracker.lastXY : u.getXY(), n = this.getStartEndDates(g), d = n.start, c = n.end, b = o.eventRecord, l = m.getMode(), i = m.isHorizontal();
        if (i) {
            o.target.el.setY(o.target.parent().getY() + o.startYOffset)
        } else {
            o.target.el.setX(o.target.parent().getX() + o.startXOffset)
        }
        if (this.showTooltip) {
            var q = this.validatorFn.call(this.validatorFnScope || this, o.resourceRecord, b, d, c);
            var k = "";
            if (q && typeof q !== "boolean") {
                k = q.message;
                q = q.valid
            }
            this.getTipInstance().update(d, c, q !== false, k)
        }
        if (this.showExactResizePosition) {
            var v = o.target.el, h, j, f;
            if (o.isStart) {
                if (m.getMode() === "calendar") {
                    var a = m.calendar.getEventColumns(b)[0];
                    h = m.timeAxisViewModel.getDistanceBetweenDates(d, a.end)
                } else {
                    h = m.timeAxisViewModel.getDistanceBetweenDates(d, b.getEndDate())
                }
                if (i) {
                    j = m.getDateFromCoordinate(o.otherEdgeX - Math.min(t, o.maxWidth)) || d;
                    f = m.timeAxisViewModel.getDistanceBetweenDates(j, d);
                    v.setWidth(h);
                    v.setX(v.getX() + f)
                } else {
                    j = m.getDateFromCoordinate(o.otherEdgeY - Math.min(t, o.maxHeight)) || d;
                    f = m.timeAxisViewModel.getDistanceBetweenDates(j, d);
                    v.setHeight(h);
                    v.setY(v.getY() + f)
                }
            } else {
                h = m.timeAxisViewModel.getDistanceBetweenDates(b.getStartDate(), c);
                if (i) {
                    v.setWidth(h)
                } else {
                    v.setHeight(h)
                }
            }
        } else {
            if (!d || !c || ((o.start - d === 0) && (o.end - c === 0))) {
                return
            }
        }
        o.end = c;
        o.start = d;
        m.fireEvent("eventpartialresize", m, b, d, c, o.el)
    },
    onViewElScroll: function (b, a) {
        this.resizer.resizeTracker.onDrag.apply(this.resizer.resizeTracker, arguments);
        this.partialResize(this.resizer, 0, 0, b)
    },
    afterResize: function (b, n, g, i) {
        var k = this, j = b.resourceRecord, l = b.eventRecord, f = l.getStartDate(), q = l.getEndDate(), c = b.start || f, d = b.end || q, p = k.schedulerView, o = false, m = true, a = k.validatorFn.call(k.validatorFnScope || k, j, l, c, d, i);
        Sch.util.ScrollManager.deactivate();
        p.el.un("scroll", this.onViewElScroll, this);
        if (this.showTooltip) {
            this.getTipInstance().hide()
        }
        p.el.select("[id^=calendar-resizer-placeholder]").remove();
        delete Ext.cache[b.el.id];
        b.el.id = b.el.dom.id = b.el.id.substr(1);
        k.resizeContext = {
            resourceRecord: b.resourceRecord, eventRecord: l, start: c, end: d, finalize: function () {
                k.finalize.apply(k, arguments)
            }
        };
        if (a && typeof a !== "boolean") {
            a = a.valid
        }
        if (c && d && (d - c > 0) && ((c - f !== 0) || (d - q !== 0)) && a !== false) {
            m = p.fireEvent("beforeeventresizefinalize", k, k.resizeContext, i) !== false;
            o = true
        } else {
            p.repaintEventsForResource(j)
        }
        if (m) {
            k.finalize(o)
        }
    },
    finalize: function (a) {
        var b = this.schedulerView;
        var e = this.resizeContext;
        var d = false;
        var c = function () {
            d = true
        };
        b.eventStore.on("update", c);
        this.resizer.target.destroy();
        if (a) {
            if (this.resizer.isStart) {
                e.eventRecord.setStartDate(e.start, false, b.eventStore.skipWeekendsDuringDragDrop)
            } else {
                e.eventRecord.setEndDate(e.end, false, b.eventStore.skipWeekendsDuringDragDrop)
            }
            if (!d) {
                b.repaintEventsForResource(e.resourceRecord)
            }
        } else {
            b.repaintEventsForResource(e.resourceRecord)
        }
        this.resizer.destroy();
        b.eventStore.un("update", c);
        b.fireEvent("eventresizeend", b, e.eventRecord);
        this.resizeContext = null
    },
    cleanUp: function () {
        if (this.tipInstance) {
            this.tipInstance.destroy()
        }
    }
});
Ext.define("Sch.feature.ColumnLines", {
    extend: "Sch.plugin.Lines",
    requires: ["Ext.data.JsonStore"],
    cls: "sch-column-line",
    showTip: false,
    timeAxisViewModel: null,
    renderingDoneEvent: "columnlinessynced",
    init: function (a) {
        this.timeAxis = a.getTimeAxis();
        this.timeAxisViewModel = a.timeAxisViewModel;
        this.panel = a;
        this.store = new Ext.data.JsonStore({fields: ["Date"]});
        this.callParent(arguments);
        a.on({modechange: this.populate, destroy: this.onHostDestroy, scope: this});
        this.timeAxisViewModel.on("update", this.populate, this);
        this.populate()
    },
    onHostDestroy: function () {
        this.timeAxisViewModel.un("update", this.populate, this)
    },
    populate: function () {
        this.store.setData(this.getData())
    },
    getElementData: function () {
        var a = this.schedulerView;
        if (a.isHorizontal() && a.store.getCount() > 0) {
            return this.callParent(arguments)
        }
        return []
    },
    getData: function () {
        var a = this.panel, m = [];
        if (a.isHorizontal()) {
            var k = this.timeAxisViewModel;
            var g = k.columnLinesFor;
            var e = !!(k.headerConfig && k.headerConfig[g].cellGenerator);
            if (e) {
                var o = k.getColumnConfig()[g];
                for (var d = 1, b = o.length; d < b; d++) {
                    m.push({Date: o[d].start})
                }
            } else {
                var c, j, n = k.getColumnConfig(), f;
                if (g === "bottom") {
                    c = "middle"
                } else {
                    if (g === "middle") {
                        c = "top"
                    }
                }
                j = n[c];
                if (j) {
                    var h = k.headerConfig;
                    if (h[c].increment !== h[g].increment || h[c].unit !== h[g].unit) {
                        f = {};
                        Ext.Array.forEach(j, function (i) {
                            f[i.start.getTime()] = 1
                        })
                    }
                }
                k.forEachInterval(g, function (q, l, p) {
                    if (p > 0) {
                        m.push({Date: q, Cls: f && f[q.getTime()] ? "sch-column-line-solid" : ""})
                    }
                })
            }
        }
        return m
    }
});
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend: "Sch.plugin.Lines",
    alias: "plugin.scheduler_currenttimeline",
    mixins: ["Sch.mixin.Localizable"],
    requires: ["Ext.data.JsonStore"],
    updateInterval: 60000,
    showHeaderElements: true,
    autoUpdate: true,
    expandToFitView: true,
    timer: null,
    init: function (c) {
        if (Ext.getVersion("touch")) {
            this.showHeaderElements = false
        }
        var b = new Ext.data.JsonStore({
            fields: ["Date", "Cls", "Text"],
            data: [{Date: new Date(), Cls: "sch-todayLine", Text: this.L("tooltipText")}]
        });
        var a = b.first();
        if (this.autoUpdate) {
            this.timer = setInterval(function () {
                a.set("Date", new Date())
            }, this.updateInterval)
        }
        this.store = b;
        this.callParent(arguments)
    },
    destroy: function () {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null
        }
        if (this.store.autoDestroy) {
            this.store.destroy()
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.view.Horizontal", {
    requires: ["Ext.util.Region", "Ext.Element", "Sch.util.Date"],
    view: null,
    constructor: function (a) {
        Ext.apply(this, a)
    },
    translateToScheduleCoordinate: function (a) {
        var b = this.view;
        if (b.rtl) {
            return b.getHorizontalTimeAxisColumn().getEl().getRight() - a
        }
        return a - b.getEl().getX() + b.getScroll().left
    },
    translateToPageCoordinate: function (a) {
        var b = this.view;
        return a + b.getEl().getX() - b.getScroll().left
    },
    getDateFromXY: function (c, b, a) {
        var d = c[0];
        if (!a) {
            d = this.translateToScheduleCoordinate(d)
        }
        return this.view.timeAxisViewModel.getDateFromPosition(d, b)
    },
    getEventRenderData: function (a) {
        var f = a.getStartDate(), e = a.getEndDate() || f, h = this.view, c = h.timeAxis.getStart(), i = h.timeAxis.getEnd(), g = Math, d = h.getXFromDate(Sch.util.Date.max(f, c)), j = h.getXFromDate(Sch.util.Date.min(e, i)), b = {};
        if (this.view.rtl) {
            b.right = g.min(d, j)
        } else {
            b.left = g.min(d, j)
        }
        b.width = g.max(1, g.abs(j - d)) - h.eventBorderWidth;
        if (h.managedEventSizing) {
            b.top = g.max(0, (h.barMargin - ((Ext.isIE && !Ext.isStrict) ? 0 : h.eventBorderWidth - h.cellTopBorderWidth)));
            b.height = h.timeAxisViewModel.rowHeightHorizontal - (2 * h.barMargin) - h.eventBorderWidth
        }
        b.start = f;
        b.end = e;
        b.startsOutsideView = f < c;
        b.endsOutsideView = e > i;
        return b
    },
    getScheduleRegion: function (e, g) {
        var c = Ext.Element.prototype.getRegion ? "getRegion" : "getPageBox", j = this.view, i = e ? Ext.fly(j.getRowNode(e))[c]() : j.getTableRegion(), f = j.timeAxis.getStart(), l = j.timeAxis.getEnd(), b = j.getDateConstraints(e, g) || {
                start: f,
                end: l
            }, d = this.translateToPageCoordinate(j.getXFromDate(Sch.util.Date.max(f, b.start))), k = this.translateToPageCoordinate(j.getXFromDate(Sch.util.Date.min(l, b.end))), h = i.top + j.barMargin, a = i.bottom - j.barMargin - j.eventBorderWidth;
        return new Ext.util.Region(h, Math.max(d, k), a, Math.min(d, k))
    },
    getResourceRegion: function (j, e, i) {
        var m = this.view, d = m.getRowNode(j), f = Ext.fly(d).getOffsetsTo(m.getEl()), k = m.timeAxis.getStart(), o = m.timeAxis.getEnd(), c = e ? Sch.util.Date.max(k, e) : k, g = i ? Sch.util.Date.min(o, i) : o, h = m.getXFromDate(c), n = m.getXFromDate(g), l = f[1] + m.cellTopBorderWidth, a = f[1] + Ext.fly(d).getHeight() - m.cellBottomBorderWidth;
        if (!Ext.versions.touch) {
            var b = m.getScroll();
            l += b.top;
            a += b.top
        }
        return new Ext.util.Region(l, Math.max(h, n), a, Math.min(h, n))
    },
    columnRenderer: function (c, k, f, g, j) {
        var i = this.view;
        var b = i.eventStore.filterEventsForResource(f, function (l) {
            return i.timeAxis.isRangeInAxis(l)
        });
        if (b.length === 0) {
            return
        }
        var h = Ext.Array.map(b, function (l) {
            return i.generateTplData(l, f, g)
        });
        if (i.dynamicRowHeight) {
            var e = i.eventLayout.horizontal;
            var d = e.applyLayout(h, f, this.layoutEventVertically, this);
            var a = (d * i.timeAxisViewModel.rowHeightHorizontal) - ((d - 1) * i.barMargin);
            i.cellTopBorderWidth - i.cellBottomBorderWidth;
            k.rowHeight = a
        }
        return i.eventTpl.apply(h)
    },
    layoutEventVertically: function (d, b) {
        var a = this.view;
        var c = d === 0 ? a.barMargin : (d * a.timeAxisViewModel.rowHeightHorizontal - (d - 1) * a.barMargin);
        if (c >= a.cellBottomBorderWidth) {
            c -= a.cellBottomBorderWidth
        }
        return c
    },
    resolveResource: function (e) {
        var d = this, b = d.view, c, a;
        c = Ext.fly(e).is(b.eventSelector) && e || Ext.fly(e).up(b.eventSelector, null, true);
        if (c) {
            a = b.getResourceRecordFromDomId(c.id)
        } else {
            e = b.findRowByChild(e);
            a = e && b.getRecordForRowNode(e) || null
        }
        return a
    },
    getTimeSpanRegion: function (b, h, g) {
        var d = this.view, c = d.getXFromDate(b), e = h ? d.getXFromDate(h) : c, a, f;
        f = d.getTableRegion();
        if (g) {
            a = Math.max(f ? f.bottom - f.top : 0, d.getEl().dom.clientHeight)
        } else {
            a = f ? f.bottom - f.top : 0
        }
        return new Ext.util.Region(0, Math.max(c, e), a, Math.min(c, e))
    },
    getStartEndDatesFromRegion: function (g, d, c) {
        var b = this.view;
        var f = b.rtl;
        var a = b.getDateFromCoordinate(f ? g.right : g.left, d), e = b.getDateFromCoordinate(f ? g.left : g.right, d);
        if (a && e || c && (a || e)) {
            return {start: a, end: e}
        }
        return null
    },
    onEventAdd: function (q, p) {
        var o = this.view, h = {}, a, b, n, c, e, m, d, g, f;
        for (m = 0, d = p.length; m < d; m++) {
            a = p[m];
            b = a.getStartDate();
            n = a.getEndDate();
            if (b && n && o.timeAxis.timeSpanInAxis(b, n)) {
                c = p[m].getResources(o.eventStore);
                for (g = 0, f = c.length; g < f; g++) {
                    e = c[g];
                    h[e.getId()] = e
                }
            }
        }
        Ext.Object.each(h, function (j, i) {
            o.repaintEventsForResource(i)
        })
    },
    onEventRemove: function (i, d) {
        var f = this, g = f.view, h = f.resourceStore, c = g.eventStore, b, a;
        b = Ext.Array.unique(Ext.Array.flatten(Ext.Array.map(d, function (j) {
            return c.getResourcesForEvent(j)
        })));
        function e(j) {
            g.store.indexOf(j) >= 0 && g.repaintEventsForResource(j)
        }

        if (b.length > 1) {
            Ext.Array.forEach(b, e)
        } else {
            if (b.length == 1) {
                a = Ext.Array.flatten(Ext.Array.map(d, function (j) {
                    return g.getElementsFromEventRecord(j, null, null, true)
                }));
                a = new Ext.CompositeElementLite(a);
                a.fadeOut({
                    callback: function () {
                        e(b[0])
                    }
                })
            }
        }
    },
    onEventUpdate: function (d, e) {
        var h = e.previous || {};
        var j = this.view;
        var g = j.timeAxis;
        var a = e.getStartDate();
        var i = e.getEndDate();
        var b = h.StartDate || a;
        var f = h.EndDate || i;
        var k = b && f && g.timeSpanInAxis(b, f);
        var c;
        if (e.resourceIdField in h && k) {
            c = d.getResourceStore().getById(h[e.resourceIdField]);
            c && j.repaintEventsForResource(c, true)
        }
        if ((a && i && g.timeSpanInAxis(a, i)) || k) {
            Ext.Array.forEach(e.getResources(), function (l) {
                j.repaintEventsForResource(l, true)
            })
        }
    },
    setColumnWidth: function (c, b) {
        var a = this.view;
        a.getTimeAxisViewModel().setViewColumnWidth(c, b)
    },
    getVisibleDateRange: function () {
        var d = this.view;
        if (!d.getEl()) {
            return null
        }
        var c = d.getTableRegion(), b = d.timeAxis.getStart(), f = d.timeAxis.getEnd(), e = d.getWidth();
        if ((c.right - c.left) < e) {
            return {startDate: b, endDate: f}
        }
        var a = d.getScroll();
        return {
            startDate: d.getDateFromCoordinate(a.left, null, true),
            endDate: d.getDateFromCoordinate(a.left + e, null, true)
        }
    }
});
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: ["Sch.data.TimeAxis", "Sch.view.Horizontal"],
    selectedEventCls: "sch-event-selected",
    readOnly: false,
    horizontalViewClass: "Sch.view.Horizontal",
    timeCellCls: "sch-timetd",
    timeCellSelector: ".sch-timetd",
    eventBorderWidth: 1,
    timeAxis: null,
    timeAxisViewModel: null,
    eventPrefix: null,
    rowHeight: null,
    orientation: "horizontal",
    mode: "horizontal",
    horizontal: null,
    vertical: null,
    secondaryCanvasEl: null,
    panel: null,
    displayDateFormat: null,
    el: null,
    constructor: function (a) {
        if (a && a.orientation) {
            a.mode = this.mode = a.orientation
        }
        this.callParent([a])
    },
    _initializeTimelineView: function () {
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, {view: this})
        }
        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, {view: this})
        }
        if (this.calendarViewClass) {
            this.calendar = Ext.create(this.calendarViewClass, {view: this})
        }
        this.eventPrefix = (this.eventPrefix || this.getId()) + "-"
    },
    getTimeAxisViewModel: function () {
        return this.timeAxisViewModel
    },
    getFormattedDate: function (a) {
        return Ext.Date.format(a, this.getDisplayDateFormat())
    },
    getFormattedEndDate: function (c, a) {
        var b = this.getDisplayDateFormat();
        if (c.getHours() === 0 && c.getMinutes() === 0 && !(c.getYear() === a.getYear() && c.getMonth() === a.getMonth() && c.getDate() === a.getDate()) && !Sch.util.Date.hourInfoRe.test(b.replace(Sch.util.Date.stripEscapeRe, ""))) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, -1)
        }
        return Ext.Date.format(c, b)
    },
    getDisplayDateFormat: function () {
        return this.displayDateFormat
    },
    setDisplayDateFormat: function (a) {
        this.displayDateFormat = a
    },
    fitColumns: function (b) {
        if (this.mode === "horizontal") {
            this.getTimeAxisViewModel().fitToAvailableWidth(b)
        } else {
            var a = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(a, b)
        }
    },
    getElementFromEventRecord: function (b, d) {
        var c = this, a;
        a = c.getElementsFromEventRecord(b, d);
        if (a.length === 0) {
            a = null
        } else {
            if (a.length == 1) {
                a = a[0]
            } else {
                if (c.mode == "calendar") {
                    a = a[0]
                } else {
                    Ext.Error.raise("The method getElementFromEventRecord() is deprecated, it can't handle the situation when several DOM elements correspond to a single event record, please use getElementsFromEventRecord() method instead!")
                }
            }
        }
        return a
    },
    getElementsFromEventRecord: function (a, e, c, b) {
        var d = this, f;
        b = b || false;
        if (e && (c !== null && c !== undefined)) {
            f = "[id^=" + d.eventPrefix + a.internalId + "-" + e.internalId + "-" + c + "]"
        } else {
            if (e) {
                f = "[id^=" + d.eventPrefix + a.internalId + "-" + e.internalId + "-]"
            } else {
                f = "[id^=" + d.eventPrefix + a.internalId + "-]"
            }
        }
        return d.getEl().query(f, b)
    },
    getStartEndDatesFromRegion: function (c, b, a) {
        return this[this.mode].getStartEndDatesFromRegion(c, b, a)
    },
    getTimeResolution: function () {
        return this.timeAxis.getResolution()
    },
    setTimeResolution: function (b, a) {
        this.timeAxis.setResolution(b, a);
        if (this.getTimeAxisViewModel().snapToIncrement) {
            this.refreshKeepingScroll()
        }
    },
    getEventIdFromDomNodeId: function (a) {
        return a.substring(this.eventPrefix.length).split("-")[0]
    },
    getResourceIdFromDomNodeId: function (a) {
        return a.substring(this.eventPrefix.length).split("-")[1]
    },
    getDateFromDomEvent: function (b, a) {
        return this.getDateFromXY(b.getXY(), a)
    },
    getSnapPixelAmount: function () {
        return this.getTimeAxisViewModel().getSnapPixelAmount()
    },
    setSnapEnabled: function (a) {
        this.getTimeAxisViewModel().setSnapToIncrement(a)
    },
    setReadOnly: function (a) {
        this.readOnly = a;
        this[a ? "addCls" : "removeCls"](this._cmpCls + "-readonly")
    },
    isReadOnly: function () {
        return this.readOnly
    },
    setOrientation: function () {
        this.setMode.apply(this, arguments)
    },
    setMode: function (a) {
        this.mode = a;
        this.timeAxisViewModel.mode = a
    },
    getOrientation: function () {
        return this.getMode.apply(this, arguments)
    },
    getMode: function () {
        return this.mode
    },
    isHorizontal: function () {
        return this.getMode() === "horizontal"
    },
    isVertical: function () {
        return !this.isHorizontal()
    },
    getDateFromXY: function (c, b, a) {
        return this[this.mode].getDateFromXY(c, b, a)
    },
    getDateFromCoordinate: function (c, b, a) {
        if (!a) {
            c = this[this.mode].translateToScheduleCoordinate(c)
        }
        return this.timeAxisViewModel.getDateFromPosition(c, b)
    },
    getDateFromX: function (a, b) {
        return this.getDateFromCoordinate(a, b)
    },
    getDateFromY: function (b, a) {
        return this.getDateFromCoordinate(b, a)
    },
    getCoordinateFromDate: function (a, b) {
        var c = this.timeAxisViewModel.getPositionFromDate(a);
        if (b === false) {
            c = this[this.mode].translateToPageCoordinate(c)
        }
        return Math.round(c)
    },
    getXFromDate: function (a, b) {
        return this.getCoordinateFromDate(a, b)
    },
    getYFromDate: function (a, b) {
        return this.getCoordinateFromDate(a, b)
    },
    getTimeSpanDistance: function (a, b) {
        return this.timeAxisViewModel.getDistanceBetweenDates(a, b)
    },
    getTimeSpanRegion: function (a, b) {
        return this[this.mode].getTimeSpanRegion(a, b)
    },
    getScheduleRegion: function (b, a) {
        return this[this.mode].getScheduleRegion(b, a)
    },
    getTableRegion: function () {
        throw"Abstract method call"
    },
    getRowNode: function (a) {
        throw"Abstract method call"
    },
    getRecordForRowNode: function (a) {
        throw"Abstract method call"
    },
    getVisibleDateRange: function () {
        return this[this.mode].getVisibleDateRange()
    },
    setColumnWidth: function (b, a) {
        this[this.mode].setColumnWidth(b, a)
    },
    findRowByChild: function (a) {
        throw"Abstract method call"
    },
    setBarMargin: function (b, a) {
        this.barMargin = b;
        if (!a) {
            this.refreshKeepingScroll()
        }
    },
    getRowHeight: function () {
        return this.timeAxisViewModel.getViewRowHeight()
    },
    setRowHeight: function (a, b) {
        this.timeAxisViewModel.setViewRowHeight(a, b)
    },
    refreshKeepingScroll: function () {
        throw"Abstract method call"
    },
    scrollVerticallyTo: function (b, a) {
        throw"Abstract method call"
    },
    scrollHorizontallyTo: function (a, b) {
        throw"Abstract method call"
    },
    getVerticalScroll: function () {
        throw"Abstract method call"
    },
    getHorizontalScroll: function () {
        throw"Abstract method call"
    },
    getEl: Ext.emptyFn,
    getSecondaryCanvasEl: function () {
        if (!this.rendered) {
            throw"Calling this method too early"
        }
        if (!this.secondaryCanvasEl) {
            this.secondaryCanvasEl = (this.scrollerEl || this.getEl()).createChild({cls: "sch-secondary-canvas"})
        }
        return this.secondaryCanvasEl
    },
    getScroll: function () {
        throw"Abstract method call"
    },
    getOuterEl: function () {
        return this.getEl()
    },
    getRowContainerEl: function () {
        return this.getEl()
    },
    getScheduleCell: function (b, a) {
        return this.getCellByPosition({row: b, column: a})
    },
    getScrollEventSource: function () {
        return this.getEl()
    },
    getViewportHeight: function () {
        return this.getEl().getHeight()
    },
    getViewportWidth: function () {
        return this.getEl().getWidth()
    },
    getViewportCenterDate: function () {
        var a = this.getScroll(), b;
        if (this.getMode() === "vertical") {
            b = [0, a.top + this.getViewportHeight() / 2]
        } else {
            b = [a.left + this.getViewportWidth() / 2, 0]
        }
        return this.getDateFromXY(b, null, true)
    },
    getDateConstraints: Ext.emptyFn
});
Ext.apply(Sch, {VERSION: "3.0.7"});
Ext.define("Sch.mixin.TimelineView", {
    extend: "Sch.mixin.AbstractTimelineView",
    requires: ["Ext.tip.ToolTip", "Sch.patches.TouchScroll", "Sch.patches.PartnerScroll", "Sch.patches.View", "Sch.patches.TableView", "Sch.patches.Collection", "Sch.patches.ToolTip"],
    tip: null,
    overScheduledEventClass: "sch-event-hover",
    ScheduleBarEvents: ["mousedown", "mouseup", "click", "dblclick", "contextmenu"],
    ResourceRowEvents: ["keydown", "keyup"],
    preventOverCls: false,
    _initializeTimelineView: function () {
        this.callParent(arguments);
        this.on("destroy", this._onDestroy, this);
        this.on("afterrender", this._onAfterRender, this);
        this.panel.on("viewready", this._onViewReady, this);
        this.setMode(this.mode);
        this.enableBubble("columnwidthchange");
        this.addCls("sch-timelineview");
        if (this.readOnly) {
            this.addCls(this._cmpCls + "-readonly")
        }
        this.addCls(this._cmpCls);
        if (this.eventAnimations) {
            this.addCls("sch-animations-enabled")
        }
    },
    handleScheduleBarEvent: function (b, a) {
        this.fireEvent(this.scheduledEventName + b.type, this, this.resolveEventRecord(a), b)
    },
    handleResourceRowEvent: function (a, b) {
        this.fireEvent(this.scheduledEventName + a.type, this, this.resolveEventRecordFromResourceRow(b), a)
    },
    _onDestroy: function () {
        if (this.tip) {
            this.tip.destroy()
        }
    },
    _onViewReady: function () {
        if (this.touchScroll) {
            this.getSecondaryCanvasEl().insertBefore(this.getNodeContainer())
        }
    },
    _onAfterRender: function () {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true)
        }
        if (this.tooltipTpl) {
            if (typeof this.tooltipTpl === "string") {
                this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl)
            }
            this.el.on("mousemove", this.setupTooltip, this, {single: true})
        }
        var e = this.bufferedRenderer;
        if (e) {
            this.patchBufferedRenderingPlugin(e);
            this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer)
        }
        this.on("bufferedrefresh", this.onBufferedRefresh, this, {buffer: 10});
        this.setupTimeCellEvents();
        var d = this.getSecondaryCanvasEl();
        if (d.getStyle("position").toLowerCase() !== "absolute") {
            var c = Ext.Msg || window;
            c.alert("ERROR: The CSS file for the Bryntum component has not been loaded.")
        }
        var b = {delegate: this.eventSelector, scope: this};
        var a = {delegate: this.rowSelector, scope: this};
        Ext.Array.forEach(this.ScheduleBarEvents, function (f) {
            b[f] = this.handleScheduleBarEvent
        }, this);
        Ext.Array.forEach(this.ResourceRowEvents, function (f) {
            a[f] = this.handleResourceRowEvent
        }, this);
        this.el.on(b);
        this.el.on(a)
    },
    patchBufferedRenderingPlugin: function (c) {
        var b = this;
        var a = c.setBodyTop;
        c.setBodyTop = function (d, e) {
            var f = a.apply(this, arguments);
            b.fireEvent("bufferedrefresh", this);
            return f
        }
    },
    onBufferedRefresh: function () {
        var d = this.body.dom;
        if (!d) {
            return
        }
        var c = d.style;
        if (Ext.isIE9m) {
            this.getSecondaryCanvasEl().dom.style.top = this.body.dom.style.top
        } else {
            var b = c.transform || c.msTransform || c.webkitTransform;
            var a;
            if (b) {
                a = /\(-?\d+px,\s*(-?\d+px),\s*(-?\d+)px\)/.exec(b)
            }
            if (a) {
                this.getSecondaryCanvasEl().dom.style.top = b ? a[1] : d.style.top
            }
        }
    },
    setMouseOverEnabled: function (a) {
        this[a ? "mon" : "mun"](this.el, {
            mouseover: this.onEventMouseOver,
            mouseout: this.onEventMouseOut,
            delegate: this.eventSelector,
            scope: this
        })
    },
    onEventMouseOver: function (c, a) {
        if (a !== this.lastItem && !this.preventOverCls) {
            this.lastItem = a;
            Ext.fly(a).addCls(this.overScheduledEventClass);
            var b = this.resolveEventRecord(a);
            if (b) {
                this.fireEvent("eventmouseenter", this, b, c)
            }
        }
    },
    onEventMouseOut: function (b, a) {
        if (this.lastItem) {
            if (!b.within(this.lastItem, true, true)) {
                Ext.fly(this.lastItem).removeCls(this.overScheduledEventClass);
                this.fireEvent("eventmouseleave", this, this.resolveEventRecord(this.lastItem), b);
                delete this.lastItem
            }
        }
    },
    highlightItem: function (b) {
        if (b) {
            var a = this;
            a.clearHighlight();
            a.highlightedItem = b;
            Ext.fly(b).addCls(a.overItemCls)
        }
    },
    setupTooltip: function () {
        var b = this, a = Ext.apply({
            delegate: b.eventSelector,
            target: b.el,
            anchor: "b",
            rtl: b.rtl,
            show: function () {
                Ext.ToolTip.prototype.show.apply(this, arguments);
                if (this.triggerElement && b.getMode() === "horizontal") {
                    this.setX(this.targetXY[0] - 10);
                    var c = Ext.fly(this.triggerElement).getBox();
                    var d = c.top - this.getHeight() - 10;
                    this.setY(d < 0 ? c.bottom + 10 : d)
                }
            }
        }, b.tipCfg);
        b.tip = new Ext.ToolTip(a);
        b.tip.on({
            beforeshow: function (e) {
                if (!e.triggerElement || !e.triggerElement.id) {
                    return false
                }
                var c = this.resolveEventRecord(e.triggerElement);
                if (!c || this.fireEvent("beforetooltipshow", this, c) === false) {
                    return false
                }
                var f = this.getDataForTooltipTpl(c, e.triggerElement), d;
                if (!f) {
                    return false
                }
                d = this.tooltipTpl.apply(f);
                if (!d) {
                    return false
                }
                e.update(d)
            }, scope: this
        });
        if (Ext.supports.Touch) {
            b.el.un({touchmove: b.setupTooltip, mousemove: b.setupTooltip, scope: b})
        }
    },
    getHorizontalTimeAxisColumn: function () {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down("timeaxiscolumn");
            if (this.timeAxisColumn) {
                this.timeAxisColumn.on("destroy", function () {
                    this.timeAxisColumn = null
                }, this)
            }
        }
        return this.timeAxisColumn
    },
    getDataForTooltipTpl: function (a, b) {
        return Ext.apply({_record: a}, a.data)
    },
    refreshKeepingScroll: function () {
        Ext.suspendLayouts();
        this.saveScrollState();
        this.refresh();
        Ext.resumeLayouts(true);
        if (this.scrollState.left !== 0 || this.scrollState.top !== 0 || this.infiniteScroll) {
            this.restoreScrollState()
        }
    },
    setupTimeCellEvents: function () {
        this.mon(this.el, {
            click: this.handleScheduleEvent,
            dblclick: this.handleScheduleEvent,
            contextmenu: this.handleScheduleEvent,
            pinch: this.handleScheduleEvent,
            pinchstart: this.handleScheduleEvent,
            pinchend: this.handleScheduleEvent,
            scope: this
        })
    },
    getTableRegion: function () {
        var a = this.el.down("." + Ext.baseCSSPrefix + "grid-item-container");
        return (a || this.el).getRegion()
    },
    getRowNode: function (a) {
        return this.getNodeByRecord(a)
    },
    findRowByChild: function (a) {
        return this.findItemByChild(a)
    },
    getRecordForRowNode: function (a) {
        return this.getRecord(a)
    },
    refreshKeepingResourceScroll: function () {
        var a = this.getScroll();
        this.refresh();
        if (this.getMode() === "horizontal") {
            this.scrollVerticallyTo(a.top)
        } else {
            this.scrollHorizontallyTo(a.left)
        }
    },
    scrollHorizontallyTo: function (a, b) {
        var c = this.getEl();
        if (c && Ext.supports.Touch) {
            this.setScrollX(a)
        } else {
            if (c) {
                c.scrollTo("left", Math.max(0, a), b)
            }
        }
    },
    scrollVerticallyTo: function (c, a) {
        var b = this.getEl();
        if (b && Ext.supports.Touch) {
            this.setScrollY(c)
        } else {
            if (b) {
                b.scrollTo("top", Math.max(0, c), a)
            }
        }
    },
    getVerticalScroll: function () {
        var a = this.getEl();
        return a.getScroll().top
    },
    getHorizontalScroll: function () {
        var a = this.getEl();
        return a.getScroll().left
    },
    getScroll: function () {
        var a = this;
        return {top: a.getScrollY(), left: a.getScrollX()}
    },
    handleScheduleEvent: function () {
    },
    scrollElementIntoView: function (d, t, h, f, a, g, c) {
        var w = this, s = d.dom, m = Ext.getDom(w.getEl()), j = d.getOffsetsTo(m), b = w.getScroll(), e = j[0] + b.left, n = j[1] + b.top, k = n + s.offsetHeight, u = e + s.offsetWidth, o = m.clientHeight, i = parseInt(b.top, 10), v = parseInt(b.left, 10), p = i + o, l = v + m.clientWidth, r, q;
        a = a === null || a === undefined ? 20 : a;
        if (s.offsetHeight > o || n < i) {
            q = n - a
        } else {
            if (k > p) {
                q = k - o + a
            }
        }
        if (t !== false && s.offsetWidth > m.clientWidth || e < v) {
            r = e - a
        } else {
            if (t !== false && u > l) {
                r = u - m.clientWidth + a
            }
        }
        h = h === true && {} || h;
        f = f === true && {} || f;
        c = c || w;
        if (h && f) {
            h.listeners = Ext.apply(h.listeners || {}, {
                afteranimate: function () {
                    f.listeners = Ext.apply(f.listeners || {}, {
                        afteranimate: function () {
                            g && g.call(c);
                            g = null
                        }
                    });
                    Ext.fly(s).highlight(null, f)
                }
            })
        } else {
            if (h) {
                h.listeners = Ext.apply(h.listeners, {
                    afteranimate: function () {
                        g && g.call(c);
                        g = null
                    }
                })
            } else {
                if (f) {
                    f.listeners = Ext.apply(f.listeners || {}, {
                        afteranimate: function () {
                            g && g.call(c);
                            g = null
                        }
                    })
                }
            }
        }
        q !== undefined && w.setScrollY(q, h);
        r !== undefined && w.setScrollX(r, h);
        !h && f && Ext.fly(s).highlight(null, f);
        !h && !f && g && g.call(c)
    },
    disableViewScroller: function (b) {
        var a = this.getScrollable();
        if (a) {
            a.setDisabled(b)
        }
    }
});
Ext.define("Sch.view.TimelineGridView", {
    extend: "Ext.grid.View",
    mixins: ["Sch.mixin.TimelineView"],
    infiniteScroll: false,
    bufferCoef: 5,
    bufferThreshold: 0.2,
    cachedScrollLeftDate: null,
    boxIsReady: false,
    ignoreNextHorizontalScroll: false,
    constructor: function (a) {
        this.callParent(arguments);
        if (this.infiniteScroll) {
            this.on("boxready", this.setupInfiniteScroll, this)
        }
        if (this.timeAxisViewModel) {
            this.relayEvents(this.timeAxisViewModel, ["columnwidthchange"])
        }
    },
    setupInfiniteScroll: function () {
        var f = this.panel.ownerCt;
        this.cachedScrollLeftDate = f.startDate || this.timeAxis.getStart();
        if (Ext.supports.Touch && Ext.os.is.Windows) {
            var a = this.panel.headerCt.scrollable;
            var b = this.scrollable;
            try {
                Ext.GlobalEvents.un("idle", a.onIdle, a);
                Ext.GlobalEvents.un("idle", b.onIdle, b)
            } catch (d) {
                Ext.log("Cannot unsubscribe required listener, zooming may be broken")
            }
        }
        var c = this;
        f.calculateOptimalDateRange = function (g, e, j, h) {
            if (h) {
                return h
            }
            var i = Sch.preset.Manager.getPreset(j.preset);
            return c.calculateInfiniteScrollingDateRange(g, i.getBottomHeader().unit, j.increment, j.width)
        };
        this.bindInfiniteScrollListeners()
    },
    bindInfiniteScrollListeners: function () {
        if (this.scrollManager) {
            this.scrollManager.scroller.on("scroll", this.onHorizontalScroll, this)
        } else {
            this.el.on("scroll", this.onHorizontalScroll, this)
        }
        this.on("resize", this.onSelfResize, this)
    },
    unbindInfiniteScrollListeners: function () {
        if (this.scrollManager) {
            this.scrollManager.scroller.un("scroll", this.onHorizontalScroll, this)
        } else {
            this.el.un("scroll", this.onHorizontalScroll, this)
        }
        this.un("resize", this.onSelfResize, this)
    },
    onHorizontalScroll: function () {
        if (this.ignoreNextHorizontalScroll || this.cachedScrollLeftDate) {
            this.ignoreNextHorizontalScroll = false;
            return
        }
        var e = this.el.dom, c = this.getWidth(), d = this.getScroll().left, b = this.scrollManager ? this.scrollManager.scroller.getMaxPosition().x : e.scrollWidth, a = c * this.bufferThreshold * this.bufferCoef;
        if ((b - d - c < a) || d < a) {
            this.shiftToDate(this.getDateFromCoordinate(d, null, true));
            this.el.stopAnimation()
        }
    },
    refresh: function () {
        this.callParent(arguments);
        if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
            this.restoreScrollLeftDate()
        }
    },
    onSelfResize: function (c, d, a, b, e) {
        this.boxIsReady = true;
        if (d !== b) {
            this.shiftToDate(this.cachedScrollLeftDate || this.getVisibleDateRange().startDate, this.cachedScrollCentered)
        }
    },
    restoreScrollLeftDate: function () {
        if (this.cachedScrollLeftDate && this.boxIsReady) {
            this.ignoreNextHorizontalScroll = true;
            this.scrollToDate(this.cachedScrollLeftDate);
            this.cachedScrollLeftDate = null
        }
    },
    scrollToDate: function (a) {
        this.cachedScrollLeftDate = a;
        if (this.cachedScrollCentered) {
            this.panel.ownerCt.scrollToDateCentered(a)
        } else {
            this.panel.ownerCt.scrollToDate(a)
        }
        var b = this.getScroll().left;
        this.panel.scrollLeftPos = b;
        this.headerCt.el.dom.scrollLeft = b
    },
    saveScrollState: function () {
        this.scrollStateSaved = this.boxIsReady;
        this.callParent(arguments)
    },
    restoreScrollState: function () {
        this.scrollStateSaved = false;
        if (this.infiniteScroll && this.cachedScrollLeftDate) {
            this.restoreScrollLeftDate();
            this.el.dom.scrollTop = this.scrollState.top;
            return
        }
        this.callParent(arguments)
    },
    calculateInfiniteScrollingDateRange: function (e, f, b, a) {
        var g = this.timeAxis;
        var d = this.getWidth();
        a = a || this.timeAxisViewModel.getTickWidth();
        b = b || g.increment || 1;
        f = f || g.unit;
        var h = Sch.util.Date;
        var c = Math.ceil(d * this.bufferCoef / a);
        return {
            start: g.floorDate(h.add(e, f, -c * b), false, f, b),
            end: g.ceilDate(h.add(e, f, Math.ceil((d / a + c) * b)), false, f, b)
        }
    },
    shiftToDate: function (c, b) {
        var a = this.calculateInfiniteScrollingDateRange(c);
        this.cachedScrollLeftDate = c;
        this.cachedScrollCentered = b;
        this.timeAxis.setTimeSpan(a.start, a.end)
    },
    destroy: function () {
        if (this.infiniteScroll && this.rendered) {
            this.unbindInfiniteScrollListeners()
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.mixin.FilterableTreeView", {
    prevBlockRefresh: null, initTreeFiltering: function () {
        var a = function () {
            var b = this.store;
            this.mon(b, "nodestore-datachange-start", this.onFilterChangeStart, this);
            this.mon(b, "nodestore-datachange-end", this.onFilterChangeEnd, this);
            if (!b.allowExpandCollapseWhileFiltered) {
                this.mon(b, "filter-clear", this.onFilterCleared, this);
                this.mon(b, "filter-set", this.onFilterSet, this)
            }
        };
        if (this.rendered) {
            a.call(this)
        } else {
            this.on("beforerender", a, this, {single: true})
        }
    }, onFilterChangeStart: function () {
        this.prevBlockRefresh = this.blockRefresh;
        this.blockRefresh = true;
        Ext.suspendLayouts()
    }, onFilterChangeEnd: function () {
        Ext.resumeLayouts(true);
        this.blockRefresh = this.prevBlockRefresh
    }, onFilterCleared: function () {
        delete this.toggle;
        var a = this.getEl();
        if (a) {
            a.removeCls("sch-tree-filtered")
        }
    }, onFilterSet: function () {
        this.toggle = function () {
        };
        var a = this.getEl();
        if (a) {
            a.addCls("sch-tree-filtered")
        }
    }
});
Ext.define("Sch.mixin.Zoomable", {
    zoomLevels: [{
        width: 40,
        increment: 1,
        resolution: 1,
        preset: "manyYears",
        resolutionUnit: "YEAR"
    }, {width: 80, increment: 1, resolution: 1, preset: "manyYears", resolutionUnit: "YEAR"}, {
        width: 30,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    }, {width: 50, increment: 1, resolution: 1, preset: "year", resolutionUnit: "MONTH"}, {
        width: 100,
        increment: 1,
        resolution: 1,
        preset: "year",
        resolutionUnit: "MONTH"
    }, {width: 200, increment: 1, resolution: 1, preset: "year", resolutionUnit: "MONTH"}, {
        width: 100,
        increment: 1,
        resolution: 7,
        preset: "monthAndYear",
        resolutionUnit: "DAY"
    }, {width: 30, increment: 1, resolution: 1, preset: "weekDateAndMonth", resolutionUnit: "DAY"}, {
        width: 35,
        increment: 1,
        resolution: 1,
        preset: "weekAndMonth",
        resolutionUnit: "DAY"
    }, {width: 50, increment: 1, resolution: 1, preset: "weekAndMonth", resolutionUnit: "DAY"}, {
        width: 20,
        increment: 1,
        resolution: 1,
        preset: "weekAndDayLetter"
    }, {width: 50, increment: 1, resolution: 1, preset: "weekAndDay", resolutionUnit: "HOUR"}, {
        width: 100,
        increment: 1,
        resolution: 1,
        preset: "weekAndDay",
        resolutionUnit: "HOUR"
    }, {width: 50, increment: 6, resolution: 30, preset: "hourAndDay", resolutionUnit: "MINUTE"}, {
        width: 100,
        increment: 6,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    }, {width: 60, increment: 2, resolution: 30, preset: "hourAndDay", resolutionUnit: "MINUTE"}, {
        width: 60,
        increment: 1,
        resolution: 30,
        preset: "hourAndDay",
        resolutionUnit: "MINUTE"
    }, {width: 30, increment: 15, resolution: 5, preset: "minuteAndHour"}, {
        width: 60,
        increment: 15,
        resolution: 5,
        preset: "minuteAndHour"
    }, {width: 130, increment: 15, resolution: 5, preset: "minuteAndHour"}, {
        width: 60,
        increment: 5,
        resolution: 5,
        preset: "minuteAndHour"
    }, {width: 100, increment: 5, resolution: 5, preset: "minuteAndHour"}, {
        width: 50,
        increment: 2,
        resolution: 1,
        preset: "minuteAndHour"
    }, {width: 30, increment: 10, resolution: 5, preset: "secondAndMinute"}, {
        width: 60,
        increment: 10,
        resolution: 5,
        preset: "secondAndMinute"
    }, {width: 130, increment: 5, resolution: 5, preset: "secondAndMinute"}],
    minZoomLevel: null,
    maxZoomLevel: null,
    visibleZoomFactor: 5,
    zoomKeepsOriginalTimespan: false,
    cachedCenterDate: null,
    isFirstZoom: true,
    isZooming: false,
    initializeZooming: function () {
        this.zoomLevels = this.zoomLevels.slice();
        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);
        this.on("viewchange", this.clearCenterDateCache, this)
    },
    getZoomLevelUnit: function (a) {
        return Sch.preset.Manager.getPreset(a.preset).getBottomHeader().unit
    },
    getMilliSecondsPerPixelForZoomLevel: function (c, a) {
        var b = Sch.util.Date;
        return Math.round((b.add(new Date(1, 0, 1), this.getZoomLevelUnit(c), c.increment) - new Date(1, 0, 1)) / (a ? c.width : c.actualWidth || c.width))
    },
    presetToZoomLevel: function (b) {
        var a = Sch.preset.Manager.getPreset(b);
        return {
            preset: b,
            increment: a.getBottomHeader().increment || 1,
            resolution: a.timeResolution.increment,
            resolutionUnit: a.timeResolution.unit,
            width: a.timeColumnWidth
        }
    },
    zoomLevelToPreset: function (c) {
        var b = Sch.preset.Manager.getPreset(c.preset).clone();
        var a = b.getBottomHeader();
        a.increment = c.increment;
        b.timeColumnWidth = c.width;
        if (c.resolutionUnit || c.resolution) {
            b.timeResolution = {
                unit: c.resolutionUnit || b.timeResolution.unit || a.unit,
                increment: c.resolution || b.timeResolution.increment || 1
            }
        }
        return b
    },
    calculateCurrentZoomLevel: function () {
        var g = this.presetToZoomLevel(this.viewPreset), d = Number.MAX_VALUE, b = this.timeAxisViewModel, f = b.timeColumnWidth;
        g.width = f;
        g.increment = b.getBottomHeader().increment || 1;
        for (var c = 0, a = this.zoomLevels.length; c < a; c++) {
            var e = this.zoomLevels[c];
            if (e.preset !== g.preset) {
                continue
            }
            var h = Math.abs(e.width - f);
            if (h < d) {
                d = h;
                g.actualWidth = e.actualWidth;
                g.width = e.width
            }
        }
        return g
    },
    getCurrentZoomLevelIndex: function () {
        var f = this.calculateCurrentZoomLevel();
        var b = this.getMilliSecondsPerPixelForZoomLevel(f);
        var e = this.zoomLevels;
        for (var c = 0; c < e.length; c++) {
            var d = this.getMilliSecondsPerPixelForZoomLevel(e[c]);
            if (d == b) {
                return c
            }
            if (c === 0 && b > d) {
                return -0.5
            }
            if (c == e.length - 1 && b < d) {
                return e.length - 1 + 0.5
            }
            var a = this.getMilliSecondsPerPixelForZoomLevel(e[c + 1]);
            if (d > b && b > a) {
                return c + 0.5
            }
        }
        throw"Can't find current zoom level index"
    },
    setMaxZoomLevel: function (a) {
        if (a < 0 || a >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`")
        }
        this.maxZoomLevel = a
    },
    setMinZoomLevel: function (a) {
        if (a < 0 || a >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`")
        }
        this.minZoomLevel = a
    },
    getViewportCenterDateCached: function () {
        if (this.cachedCenterDate) {
            return this.cachedCenterDate
        }
        return this.cachedCenterDate = this.getViewportCenterDate()
    },
    clearCenterDateCache: function () {
        this.cachedCenterDate = null
    },
    zoomToLevel: function (b, r, e) {
        b = Ext.Number.constrain(b, this.minZoomLevel, this.maxZoomLevel);
        e = e || {};
        var q = this.calculateCurrentZoomLevel();
        var c = this.getMilliSecondsPerPixelForZoomLevel(q);
        var l = this.zoomLevels[b];
        var a = this.getMilliSecondsPerPixelForZoomLevel(l);
        if (c == a && !r) {
            return null
        }
        var s = this;
        var m = this.getSchedulingView();
        var h = m.getOuterEl();
        var i = this.mode == "vertical";
        var g = r ? new Date((r.start.getTime() + r.end.getTime()) / 2) : this.getViewportCenterDateCached();
        var n = i ? h.getHeight() : h.getWidth();
        var o = Sch.preset.Manager.getPreset(l.preset).clone();
        var p = o.getBottomHeader();
        var f = Boolean(r);
        r = this.calculateOptimalDateRange(g, n, l, r);
        o[i ? "timeRowHeight" : "timeColumnWidth"] = e.customWidth || l.width;
        p.increment = l.increment;
        this.isZooming = true;
        this.viewPreset = l.preset;
        var d = this.timeAxis;
        o.increment = l.increment;
        o.timeResolution.unit = Sch.util.Date.getUnitByName(l.resolutionUnit || o.timeResolution.unit || p.unit);
        o.timeResolution.increment = l.resolution;
        this.setViewPreset(o, r.start || this.getStart(), r.end || this.getEnd(), false, true);
        l.actualWidth = this.timeAxisViewModel.getTickWidth();
        if (f) {
            g = e.centerDate || new Date((d.getStart().getTime() + d.getEnd().getTime()) / 2)
        }
        var k = null, j = null;
        if (i) {
            j = m.getYFromDate(g, true) - n / 2;
            s.cachedCenterDate = g;
            m.getScrollable().scrollTo(null, j);
            m.headerCt.getScrollable().scrollTo(null, j)
        } else {
            k = m.getXFromDate(g, true) - n / 2;
            s.cachedCenterDate = g;
            m.getScrollable().scrollTo(k);
            m.headerCt.getScrollable().scrollTo(k)
        }
        s.isZooming = false;
        s.fireEvent("zoomchange", s, b, k, j);
        return b
    },
    setZoomLevel: function () {
        this.zoomToLevel.apply(this, arguments)
    },
    zoomToSpan: function (p, s) {
        s = s || {};
        if (s.leftMargin || s.rightMargin) {
            s.adjustStart = 0;
            s.adjustEnd = 0
        }
        Ext.applyIf(s, {leftMargin: 0, rightMargin: 0});
        if (p.start && p.end) {
            var g = p.start, d = p.end, e = s.adjustStart >= 0 && s.adjustEnd >= 0;
            if (e) {
                g = Sch.util.Date.add(g, this.timeAxis.mainUnit, -s.adjustStart);
                d = Sch.util.Date.add(d, this.timeAxis.mainUnit, s.adjustEnd)
            }
            if (g <= d) {
                var a = this.getSchedulingView().getTimeAxisViewModel().getAvailableWidth();
                var m = Math.floor(this.getCurrentZoomLevelIndex());
                if (m == -1) {
                    m = 0
                }
                var t = this.zoomLevels;
                var b = d - g || 1, j = this.getMilliSecondsPerPixelForZoomLevel(t[m], true), l = b / j + s.leftMargin + s.rightMargin > a ? -1 : 1, f = m + l;
                var o, h = null;
                while (f >= 0 && f <= t.length - 1) {
                    o = t[f];
                    j = this.getMilliSecondsPerPixelForZoomLevel(o, true);
                    var q = b / j + s.leftMargin + s.rightMargin;
                    if (l == -1) {
                        if (q <= a) {
                            h = f;
                            break
                        }
                    } else {
                        if (q <= a) {
                            if (m !== f - l) {
                                h = f
                            }
                        } else {
                            break
                        }
                    }
                    f += l
                }
                h = h !== null ? h : f - l;
                o = t[h];
                var c = Sch.preset.Manager.getPreset(o.preset).getBottomHeader().unit;
                if (s.leftMargin || s.rightMargin) {
                    g = new Date(g.getTime() - j * s.leftMargin);
                    d = new Date(d.getTime() + j * s.rightMargin)
                }
                var r = Sch.util.Date.getDurationInUnit(g, d, c, true) / o.increment;
                if (r === 0) {
                    return
                }
                var i = Math.floor(a / r);
                var k = new Date((g.getTime() + d.getTime()) / 2);
                var n;
                if (e) {
                    n = {start: g, end: d}
                } else {
                    n = this.calculateOptimalDateRange(k, a, o)
                }
                return this.zoomToLevel(h, n, {customWidth: i, centerDate: k})
            }
        }
        return null
    },
    zoomIn: function (a) {
        a = a || 1;
        var b = this.getCurrentZoomLevelIndex();
        if (b >= this.zoomLevels.length - 1) {
            return null
        }
        return this.zoomToLevel(Math.floor(b) + a)
    },
    zoomOut: function (a) {
        a = a || 1;
        var b = this.getCurrentZoomLevelIndex();
        if (b <= 0) {
            return null
        }
        return this.zoomToLevel(Math.ceil(b) - a)
    },
    zoomInFull: function () {
        return this.zoomToLevel(this.maxZoomLevel)
    },
    zoomOutFull: function () {
        return this.zoomToLevel(this.minZoomLevel)
    },
    calculateOptimalDateRange: function (c, h, e, j) {
        if (j) {
            return j
        }
        var g = this.timeAxis;
        if (this.zoomKeepsOriginalTimespan) {
            return {start: g.getStart(), end: g.getEnd()}
        }
        var b = Sch.util.Date;
        var i = this.getZoomLevelUnit(e);
        var d = Math.ceil(h / e.width * e.increment * this.visibleZoomFactor / 2);
        var a = b.add(c, i, -d);
        var f = b.add(c, i, d);
        return {start: g.floorDate(a, false, i, e.increment), end: g.ceilDate(f, false, i, e.increment)}
    }
});
Ext.define("Sch.mixin.AbstractTimelinePanel", {
    requires: ["Sch.data.TimeAxis", "Sch.view.model.TimeAxis", "Sch.feature.ColumnLines", "Sch.preset.Manager"],
    mixins: ["Sch.mixin.Zoomable"],
    orientation: "horizontal",
    snapToIncrement: false,
    readOnly: false,
    forceFit: false,
    eventResizeHandles: "both",
    timeAxis: null,
    autoAdjustTimeAxis: true,
    timeAxisViewModel: null,
    crudManager: null,
    viewPreset: "weekAndDay",
    calendarViewPreset: "week",
    trackHeaderOver: true,
    startDate: null,
    endDate: null,
    startTime: 0,
    endTime: 24,
    columnLines: true,
    getDateConstraints: Ext.emptyFn,
    snapRelativeToEventStartDate: false,
    trackMouseOver: false,
    readRowHeightFromPreset: true,
    eventBorderWidth: 1,
    getOrientation: function () {
        return this.getMode.apply(this, arguments)
    },
    getMode: function () {
        return this.mode
    },
    isHorizontal: function () {
        return this.getMode() === "horizontal"
    },
    isVertical: function () {
        return !this.isHorizontal()
    },
    cellBorderWidth: 1,
    cellTopBorderWidth: 1,
    cellBottomBorderWidth: 1,
    renderers: null,
    _initializeTimelinePanel: function () {
        this.mode = this.mode || this.orientation || "horizontal";
        if (this.mode === "calendar") {
            this.oldViewPreset = this.viewPreset;
            this.viewPreset = this.calendarViewPreset
        }
        var c = this.viewPreset && Sch.preset.Manager.getPreset(this.viewPreset);
        if (!c) {
            throw"You must define a valid view preset object. See Sch.preset.Manager class for reference"
        }
        this.initializeZooming();
        this.renderers = [];
        if (this.readRowHeightFromPreset) {
            this.readRowHeightFromPreset = !this.rowHeight
        }
        if (!this.timeAxis) {
            this.timeAxis = new Sch.data.TimeAxis({
                autoAdjust: this.autoAdjustTimeAxis,
                mode: this.mode === "calendar" ? "calendar" : "plain"
            })
        }
        if (!this.timeAxisViewModel || !(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            var a = Ext.apply({
                mode: this.mode,
                snapToIncrement: this.snapToIncrement,
                forceFit: this.forceFit,
                timeAxis: this.timeAxis,
                eventStore: this.getEventStore(),
                viewPreset: this.viewPreset
            }, this.timeAxisViewModel || {});
            this.timeAxisViewModel = new Sch.view.model.TimeAxis(a)
        }
        this.timeAxisViewModel.on("update", this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount++;
        this.on("destroy", this.onPanelDestroyed, this);
        var b;
        switch (this.mode) {
            case"horizontal":
                b = ["sch-horizontal"];
                break;
            case"vertical":
                b = ["sch-vertical", "sch-vertical-resource"];
                break;
            case"calendar":
                b = ["sch-vertical", "sch-calendar"];
                break
        }
        this.addCls([].concat.apply(["sch-timelinepanel"], b))
    },
    onTimeAxisViewModelUpdate: function () {
        var a = this.getSchedulingView();
        if (a && a.viewReady) {
            a.refreshKeepingScroll();
            this.fireEvent("viewchange", this)
        }
    },
    onPanelDestroyed: function () {
        var a = this.timeAxisViewModel;
        a.un("update", this.onTimeAxisViewModelUpdate, this);
        a.refCount--;
        if (a.refCount <= 0) {
            a.destroy()
        }
    },
    getSchedulingView: function () {
        throw"Abstract method call"
    },
    setReadOnly: function (a) {
        this.getSchedulingView().setReadOnly(a)
    },
    isReadOnly: function () {
        return this.getSchedulingView().isReadOnly()
    },
    switchViewPreset: function () {
        this.setViewPreset.apply(this, arguments)
    },
    setViewPreset: function (i, a, d, f, b) {
        var e = this.timeAxis;
        if (this.fireEvent("beforeviewchange", this, i, a, d) !== false) {
            var h = this.getMode() === "horizontal";
            if (Ext.isString(i)) {
                this.viewPreset = i;
                i = Sch.preset.Manager.getPreset(i)
            }
            if (!i) {
                throw"View preset not found"
            }
            if (!(f && e.isConfigured)) {
                var c = {
                    weekStartDay: this.weekStartDay !== undefined ? this.weekStartDay : (this.L ? this.L("weekStartDay") : 1),
                    startTime: this.startTime,
                    endTime: this.endTime
                };
                if (f) {
                    if (e.getCount() === 0 || a) {
                        c.start = a || new Date()
                    }
                } else {
                    c.start = a || e.getStart()
                }
                c.end = d;
                e.consumeViewPreset(i);
                e.reconfigure(c, true);
                this.timeAxisViewModel.reconfigure({
                    headerConfig: i.headerConfig,
                    columnLinesFor: i.columnLinesFor || "middle",
                    rowHeightHorizontal: this.readRowHeightFromPreset ? i.rowHeight : (this.rowHeight || this.timeAxisViewModel.getViewRowHeight()),
                    tickWidth: h ? i.timeColumnWidth : i.timeRowHeight || i.timeColumnWidth || 60,
                    timeColumnWidth: i.timeColumnWidth,
                    rowHeightVertical: i.timeRowHeight || i.timeColumnWidth || 60,
                    timeAxisColumnWidth: i.timeAxisColumnWidth,
                    resourceColumnWidth: this.resourceColumnWidth || i.resourceColumnWidth || 100
                })
            }
            var g = this.getSchedulingView();
            g.setDisplayDateFormat(i.displayDateFormat);
            if (this.getMode() === "vertical") {
                g.setColumnWidth(this.resourceColumnWidth || i.resourceColumnWidth || 100, true)
            }
            if (!b) {
                if (h) {
                    g.scrollHorizontallyTo(0)
                } else {
                    g.scrollVerticallyTo(0)
                }
            }
        }
    },
    getViewPreset: function () {
        return this.viewPreset
    },
    getStart: function () {
        return this.getStartDate()
    },
    getStartDate: function () {
        return this.timeAxis.getStart()
    },
    getEnd: function () {
        return this.getEndDate()
    },
    getEndDate: function () {
        return this.timeAxis.getEnd()
    },
    setTimeColumnWidth: function (b, a) {
        this.timeAxisViewModel.setTickWidth(b, a)
    },
    getTimeColumnWidth: function () {
        return this.timeAxisViewModel.getTickWidth()
    },
    getRowHeight: function () {
        return this.timeAxisViewModel.getViewRowHeight()
    },
    shiftNext: function (a) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftNext(a);
        this.suspendLayouts && this.resumeLayouts(true)
    },
    shiftPrevious: function (a) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftPrevious(a);
        this.suspendLayouts && this.resumeLayouts(true)
    },
    goToNow: function () {
        this.setTimeSpan(new Date())
    },
    setTimeSpan: function (b, a) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(b, a)
        }
    },
    setStart: function (a) {
        this.setTimeSpan(a)
    },
    setEnd: function (a) {
        this.setTimeSpan(null, a)
    },
    getTimeAxis: function () {
        return this.timeAxis
    },
    scrollToDate: function (c, b) {
        var a = this.getSchedulingView();
        var d = a.getCoordinateFromDate(c, true);
        this.scrollToCoordinate(d, c, b, false)
    },
    scrollToDateCentered: function (c, b) {
        var a = this.getSchedulingView();
        var e = 0;
        if (this.mode === "horizontal") {
            e = a.getBox().width / 2
        } else {
            e = a.getBox().height / 2
        }
        var d = Math.round(a.getCoordinateFromDate(c, true) - e);
        this.scrollToCoordinate(d, c, b, true)
    },
    scrollToCoordinate: function (g, e, d, c) {
        var b = this.getSchedulingView();
        var f = this;
        if (g < 0) {
            if (this.infiniteScroll) {
                b.shiftToDate(e, c)
            } else {
                var a = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;
                this.setTimeSpan(new Date(e.getTime() - a), new Date(e.getTime() + a));
                if (c) {
                    f.scrollToDateCentered(e, d)
                } else {
                    f.scrollToDate(e, d)
                }
            }
            return
        }
        if (this.mode === "horizontal") {
            b.scrollHorizontallyTo(g, d)
        } else {
            b.scrollVerticallyTo(g, d)
        }
        b.fireEvent("scroll", this, g)
    },
    getViewportCenterDate: function () {
        return this.getSchedulingView().getViewportCenterDate()
    },
    addCls: function () {
        throw"Abstract method call"
    },
    removeCls: function () {
        throw"Abstract method call"
    },
    registerRenderer: function (b, a) {
        this.renderers.push({fn: b, scope: a})
    },
    deregisterRenderer: function (b, a) {
        Ext.each(this.renderers, function (c, d) {
            if (b === c) {
                Ext.Array.removeAt(this.renderers, d);
                return false
            }
        })
    }
});
if (!Ext.ClassManager.get("Sch.mixin.TimelinePanel")) {
    Ext.define("Sch.mixin.TimelinePanel", {
        extend: "Sch.mixin.AbstractTimelinePanel",
        requires: ["Sch.column.timeAxis.Horizontal", "Sch.preset.Manager", "Sch.patches.NodeCache", "Sch.patches.BufferedRenderer", "Sch.patches.RowSynchronizer", "Sch.patches.Chrome"],
        mixins: ["Sch.mixin.Zoomable"],
        bufferCoef: 5,
        bufferThreshold: 0.2,
        infiniteScroll: false,
        showCrudManagerMask: true,
        waitingForAutoTimeSpan: false,
        columnLinesFeature: null,
        renderWaitListener: null,
        schedulePinchThreshold: 30,
        pinchStartDistanceX: null,
        pinchStartDistanceY: null,
        pinchDistanceX: null,
        pinchDistanceY: null,
        horizontalColumns: null,
        verticalColumns: null,
        calendarColumns: null,
        forceDefineTimeSpanByStore: false,
        tipCfg: {cls: "sch-tip", showDelay: 1000, hideDelay: 0, autoHide: true, anchor: "b"},
        inheritables: function () {
            return {
                columnLines: true,
                enableLocking: true,
                lockable: true,
                stateEvents: ["viewchange"],
                syncRowHeight: false,
                cellTopBorderWidth: 0,
                constructor: function (a) {
                    a = a || {};
                    if (this.layout === "border") {
                        a.layout = "border"
                    }
                    this.callParent([a])
                },
                initComponent: function () {
                    if (this.partnerTimelinePanel) {
                        if (typeof this.partnerTimelinePanel === "string") {
                            this.partnerTimelinePanel = Ext.getCmp(this.partnerTimelinePanel)
                        }
                        this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                        this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
                        this.startDate = this.timeAxis.getStart();
                        this.endDate = this.timeAxis.getEnd()
                    }
                    this._initializeTimelinePanel();
                    this.configureChildGrids();
                    this.forceFit = false;
                    this.configureColumns();
                    var c = this.normalViewConfig = this.normalViewConfig || {};
                    var d = this.getId();
                    Ext.apply(this.normalViewConfig, {
                        id: d + "-timelineview",
                        eventPrefix: this.autoGenId ? null : d,
                        timeAxisViewModel: this.timeAxisViewModel,
                        eventBorderWidth: this.eventBorderWidth,
                        timeAxis: this.timeAxis,
                        readOnly: this.readOnly,
                        mode: this.mode,
                        rtl: this.rtl,
                        cellBorderWidth: this.cellBorderWidth,
                        cellTopBorderWidth: this.cellTopBorderWidth,
                        cellBottomBorderWidth: this.cellBottomBorderWidth,
                        infiniteScroll: this.infiniteScroll,
                        bufferCoef: this.bufferCoef,
                        bufferThreshold: this.bufferThreshold
                    });
                    Ext.Array.forEach(["eventRendererScope", "eventRenderer", "dndValidatorFn", "resizeValidatorFn", "createValidatorFn", "tooltipTpl", "validatorFnScope", "eventResizeHandles", "enableEventDragDrop", "enableDragCreation", "resizeConfig", "createConfig", "tipCfg", "getDateConstraints"], function (e) {
                        if (e in this) {
                            c[e] = this[e]
                        }
                    }, this);
                    this.callParent(arguments);
                    this.patchNavigationModel(this);
                    this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);
                    if (!this.startDate) {
                        var a = this.getTimeSpanDefiningStore();
                        if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore ? a.getRootNode().childNodes.length : a.getCount()) {
                            this.applyStartEndDatesFromStore()
                        } else {
                            if (a.isLoading() || this.forceDefineTimeSpanByStore) {
                                this.bindAutoTimeSpanListeners()
                            }
                        }
                    }
                    var b = this.columnLines;
                    if (b) {
                        this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(b) ? b : undefined);
                        this.columnLinesFeature.init(this);
                        this.columnLines = true
                    }
                    this.relayEvents(this.getSchedulingView(), ["beforetooltipshow", "scheduleclick", "scheduledblclick", "schedulecontextmenu", "schedulepinch", "schedulepinchstart", "schedulepinchend"]);
                    this.on("boxready", this.__onBoxReady, this);
                    this.on("zoomchange", function () {
                        this.normalGrid.scrollTask.cancel()
                    });
                    if (this.crudManager && !this.crudManager.autoSync && this.showCrudManagerMask) {
                        this.mon(this.crudManager, {
                            beforesend: this.beforeCrudOperationStart,
                            synccanceled: this.onCrudOperationComplete,
                            loadcanceled: this.onCrudOperationComplete,
                            load: this.onCrudOperationComplete,
                            sync: this.onCrudOperationComplete,
                            loadfail: this.onCrudOperationComplete,
                            syncfail: this.onCrudOperationComplete,
                            scope: this
                        });
                        if (this.crudManager.isLoading()) {
                            this.beforeCrudOperationStart(this.crudManager, null, "load")
                        }
                    }
                    this.afterInitComponent()
                },
                getState: function () {
                    var a = this, b = a.callParent(arguments);
                    Ext.apply(b, {
                        viewPreset: a.viewPreset,
                        startDate: a.getStart(),
                        endDate: a.getEnd(),
                        zoomMinLevel: a.zoomMinLevel,
                        zoomMaxLevel: a.zoomMaxLevel,
                        currentZoomLevel: a.currentZoomLevel
                    });
                    return b
                },
                applyState: function (b) {
                    var a = this;
                    a.callParent(arguments);
                    if (b && b.viewPreset) {
                        a.setViewPreset(b.viewPreset, b.startDate, b.endDate)
                    }
                    if (b && b.currentZoomLevel) {
                        a.zoomToLevel(b.currentZoomLevel)
                    }
                },
                setTimeSpan: function () {
                    if (this.waitingForAutoTimeSpan) {
                        this.unbindAutoTimeSpanListeners()
                    }
                    this.callParent(arguments);
                    if (!this.normalGrid.getView().viewReady) {
                        this.getView().refresh()
                    }
                }
            }
        },
        bindAutoTimeSpanListeners: function () {
            var a = this.getTimeSpanDefiningStore();
            this.waitingForAutoTimeSpan = true;
            this.normalGrid.getView().on("beforerefresh", this.refreshStopper, this);
            this.lockedGrid.getView().on("beforerefresh", this.refreshStopper, this);
            this.mon(a, "load", this.applyStartEndDatesFromStore, this);
            if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore) {
                this.mon(a, "rootchange", this.applyStartEndDatesFromStore, this);
                this.mon(a, "nodeappend", this.applyStartEndDatesAfterTreeAppend, this)
            } else {
                this.mon(a, "add", this.applyStartEndDatesFromStore, this)
            }
        },
        refreshStopper: function (a) {
            return a.store.getCount() === 0
        },
        getTimeSpanDefiningStore: function () {
            throw"Abstract method called"
        },
        unbindAutoTimeSpanListeners: function () {
            this.waitingForAutoTimeSpan = false;
            var a = this.getTimeSpanDefiningStore();
            this.normalGrid.getView().un("beforerefresh", this.refreshStopper, this);
            this.lockedGrid.getView().un("beforerefresh", this.refreshStopper, this);
            a.un("load", this.applyStartEndDatesFromStore, this);
            if (Ext.data.TreeStore && a instanceof Ext.data.TreeStore) {
                a.un("rootchange", this.applyStartEndDatesFromStore, this);
                a.un("nodeappend", this.applyStartEndDatesAfterTreeAppend, this)
            } else {
                a.un("add", this.applyStartEndDatesFromStore, this)
            }
        },
        applyStartEndDatesAfterTreeAppend: function () {
            var a = this.getTimeSpanDefiningStore();
            if (!a.isSettingRoot && !a.__loading) {
                this.applyStartEndDatesFromStore()
            }
        },
        applyStartEndDatesFromStore: function () {
            var a = this.getTimeSpanDefiningStore();
            var b = a.getTotalTimeSpan();
            if (b.end && b.start && b.end - b.start === 0) {
                b.start = Sch.util.Date.add(b.start, this.timeAxis.mainUnit, -1);
                b.end = Sch.util.Date.add(b.end, this.timeAxis.mainUnit, 1)
            }
            this.setTimeSpan(b.start || new Date(), b.end)
        },
        onLockedGridItemDblClick: function (b, a, c, e, d) {
            if (this.mode === "vertical" && a) {
                this.fireEvent("timeheaderdblclick", this, a.get("start"), a.get("end"), e, d)
            }
        },
        getSchedulingView: function () {
            return this.normalGrid.getView()
        },
        getHorizontalTimeAxisColumn: function () {
            return this.getSchedulingView().getHorizontalTimeAxisColumn()
        },
        configureColumns: function () {
            var a = this.columns || [];
            if (a.items) {
                a = a.items
            } else {
                a = this.columns = a.slice()
            }
            var c = [];
            var b = [];
            Ext.Array.forEach(a, function (d) {
                if (d.position === "right") {
                    if (!Ext.isNumber(d.width)) {
                        Ext.Error.raise('"Right" columns must have a fixed width')
                    }
                    d.locked = false;
                    b.push(d)
                } else {
                    d.locked = true;
                    c.push(d)
                }
                d.lockable = false
            });
            Ext.Array.erase(a, 0, a.length);
            Ext.Array.insert(a, 0, c.concat({
                xtype: "timeaxiscolumn",
                timeAxisViewModel: this.timeAxisViewModel,
                trackHeaderOver: this.trackHeaderOver,
                renderer: this.mainRenderer,
                scope: this
            }).concat(b));
            this.horizontalColumns = Ext.Array.clone(a);
            this.verticalColumns = [Ext.apply({
                xtype: "verticaltimeaxis",
                width: 100,
                timeAxis: this.timeAxis,
                timeAxisViewModel: this.timeAxisViewModel,
                cellTopBorderWidth: this.cellTopBorderWidth,
                cellBottomBorderWidth: this.cellBottomBorderWidth
            }, this.timeAxisColumnCfg || {})];
            this.calendarColumns = [Ext.apply({
                xtype: "verticaltimeaxis",
                width: 60,
                timeAxis: this.timeAxis,
                timeAxisViewModel: this.timeAxisViewModel,
                cellTopBorderWidth: this.cellTopBorderWidth,
                cellBottomBorderWidth: this.cellBottomBorderWidth
            }, this.calendarTimeAxisCfg || {})];
            if (this.mode === "vertical") {
                this.columns = this.verticalColumns.concat(this.createResourceColumns(this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth));
                this.store = this.timeAxis
            } else {
                if (this.mode === "calendar") {
                    this.columns = [];
                    this.store = null;
                    this.on("afterrender", this.refreshCalendarColumns, this)
                }
            }
        },
        mainRenderer: function (b, l, g, j, k) {
            var c = this.renderers, d = this.mode === "horizontal" || this.mode === "calendar" ? g : this.resourceStore.getAt(k), a = "&nbsp;";
            l.rowHeight = null;
            for (var e = 0; e < c.length; e++) {
                a += c[e].fn.call(c[e].scope || this, b, l, d, j, k) || ""
            }
            if (this.variableRowHeight) {
                var h = this.getSchedulingView();
                var f = this.getRowHeight();
                l.style = "height:" + ((l.rowHeight || f) - h.cellTopBorderWidth - h.cellBottomBorderWidth) + "px"
            }
            return a
        },
        __onBoxReady: function () {
            var a = this;
            a.normalGrid.on({collapse: a.onNormalGridCollapse, expand: a.onNormalGridExpand, scope: a});
            a.lockedGrid.on({collapse: a.onLockedGridCollapse, itemdblclick: a.onLockedGridItemDblClick, scope: a});
            if (this.partnerTimelinePanel) {
                if (this.partnerTimelinePanel.rendered) {
                    this.setupPartnerTimelinePanel()
                } else {
                    this.partnerTimelinePanel.on("boxready", this.setupPartnerTimelinePanel, this)
                }
            }
            if (Ext.supports.Touch) {
                this.getSchedulingView().on({
                    schedulepinchstart: this.onSchedulePinchStart,
                    schedulepinch: this.onSchedulePinch,
                    schedulepinchend: this.onSchedulePinchEnd,
                    scope: this
                })
            }
        },
        onLockedGridCollapse: function () {
            if (this.normalGrid.collapsed) {
                this.normalGrid.expand()
            }
        },
        onNormalGridCollapse: function () {
            var a = this;
            if (!a.normalGrid.reExpander) {
                a.normalGrid.reExpander = a.normalGrid.placeholder
            }
            if (!a.lockedGrid.rendered) {
                a.lockedGrid.on("render", a.onNormalGridCollapse, a, {delay: 1})
            } else {
                a.lockedGrid.flex = 1;
                a.lockedGrid.updateLayout();
                if (a.lockedGrid.collapsed) {
                    a.lockedGrid.expand()
                }
                a.addCls("sch-normalgrid-collapsed")
            }
        },
        onNormalGridExpand: function () {
            this.removeCls("sch-normalgrid-collapsed");
            delete this.lockedGrid.flex;
            this.lockedGrid.updateLayout()
        },
        onPartnerCollapseExpand: function (a) {
            if (a.getCollapsed()) {
                this.lockedGrid.collapse()
            } else {
                this.lockedGrid.expand()
            }
        },
        setupPartnerTimelinePanel: function () {
            var h = this.partnerTimelinePanel;
            var i = h.down("splitter");
            var a = this.down("splitter");
            if (i) {
                i.on("dragend", function () {
                    this.lockedGrid.setWidth(h.lockedGrid.getWidth())
                }, this)
            }
            if (a) {
                a.on("dragend", function () {
                    h.lockedGrid.setWidth(this.lockedGrid.getWidth())
                }, this)
            }
            var d = h.isVisible() ? h.lockedGrid.getWidth() : h.lockedGrid.width;
            if (h.lockedGrid.getCollapsed()) {
                h.lockedGrid.on("viewready", function (l) {
                    this.lockedGrid.setWidth(l.getWidth())
                }, this)
            } else {
                this.lockedGrid.setWidth(d)
            }
            this.on("afterlayout", function () {
                if (h.lockedGrid.getCollapsed()) {
                    this.lockedGrid.collapse()
                } else {
                    this.lockedGrid.expand();
                    this.lockedGrid.setWidth(d)
                }
            }, this, {single: true});
            h.lockedGrid.on({
                collapse: this.onPartnerCollapseExpand,
                expand: this.onPartnerCollapseExpand,
                scope: this
            });
            this.lockedGrid.on({
                collapse: this.onPartnerCollapseExpand,
                expand: this.onPartnerCollapseExpand,
                scope: h
            });
            var j = h.getSchedulingView(), f = j.scrollManager ? j.scrollManager.scroller : j.getEl(), b = this.getSchedulingView(), k = b.scrollManager ? b.scrollManager.scroller : b.getEl(), g, e = Ext.Function.createBuffered(function () {
                g = null
            }, 300);
            var c = function (o, n) {
                var l = n.id === b.id ? b : j;
                var m = n.id === b.id ? j : b;
                if (!g) {
                    g = l
                }
                e();
                if (m !== g) {
                    m.setScrollX(l.getScroll().left)
                }
            };
            j.mon(k, "scroll", c);
            b.mon(f, "scroll", c);
            this.on("viewchange", function () {
                h.viewPreset = this.viewPreset
            }, this);
            h.on("viewchange", function () {
                this.viewPreset = h.viewPreset
            }, this)
        },
        beforeCrudOperationStart: function (a, c, b) {
            if (this.rendered) {
                this.setLoading({msg: b === "load" ? this.L("loadingText") : this.L("savingText")})
            } else {
                Ext.destroy(this.renderWaitListener);
                this.renderWaitListener = this.on("render", Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {
                    delay: 1,
                    destroyable: true
                })
            }
        },
        onCrudOperationComplete: function () {
            Ext.destroy(this.renderWaitListener);
            this.setLoading(false)
        },
        onSchedulePinchStart: function (a, b) {
            this.pinchStartDistanceX = Math.abs(b.touches[0].pageX - b.touches[1].pageX);
            this.pinchStartDistanceY = Math.abs(b.touches[0].pageY - b.touches[1].pageY)
        },
        onSchedulePinch: function (a, b) {
            this.pinchDistanceX = Math.abs(b.touches[0].pageX - b.touches[1].pageX);
            this.pinchDistanceY = Math.abs(b.touches[0].pageY - b.touches[1].pageY)
        },
        onSchedulePinchEnd: function (a, g) {
            var f = this.pinchDistanceX;
            var d = this.pinchDistanceY;
            var h = this.getMode()[0] === "h";
            if (Math.abs(f - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
                var c = Math.abs(f / this.pinchStartDistanceX);
                if (h) {
                    c > 1 ? this.zoomIn() : this.zoomOut()
                } else {
                    this.timeAxisViewModel.setViewColumnWidth(c * this.timeAxisViewModel.resourceColumnWidth)
                }
            }
            if (Math.abs(d - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
                var b = Math.abs(d / this.pinchStartDistanceY);
                a.setRowHeight(a.getRowHeight() * b)
            }
            this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null
        },
        patchNavigationModel: function (c) {
            c.getView().getNavigationModel().focusItem = function (d) {
                d.addCls(this.focusCls);
                if ((Ext.isIE && !d.hasCls("sch-timetd")) || (!Ext.isIE && c.getOrientation() === "horizontal")) {
                    d.focus()
                }
            };
            var b = c.lockedGrid.getView();
            var a = c.normalGrid.getView();
            b.on("rowclick", function (e, d, f, g) {
                if (a.lastFocused) {
                    a.lastFocused.rowIdx = g;
                    a.lastFocused.record = d
                }
            });
            a.on("rowclick", function (e, d, f, g) {
                if (b.lastFocused) {
                    b.lastFocused.rowIdx = g;
                    b.lastFocused.record = d
                }
            })
        },
        configureChildGrids: function () {
            var a = this;
            a.lockedGridConfig = Ext.apply({}, a.lockedGridConfig || {});
            a.normalGridConfig = Ext.apply({}, a.schedulerConfig || a.normalGridConfig || {});
            var c = a.lockedGridConfig, b = a.normalGridConfig;
            if (a.lockedXType) {
                c.xtype = a.lockedXType
            }
            if (a.normalXType) {
                b.xtype = a.normalXType
            }
            Ext.applyIf(c, {
                useArrows: true,
                split: true,
                animCollapse: false,
                collapseDirection: "left",
                trackMouseOver: false,
                region: "west"
            });
            Ext.applyIf(b, {
                viewType: a.viewType,
                layout: "fit",
                enableColumnMove: false,
                enableColumnResize: false,
                enableColumnHide: false,
                trackMouseOver: false,
                collapseDirection: "right",
                collapseMode: "placeholder",
                animCollapse: false,
                region: "center"
            });
            if (a.mode === "vertical") {
                c.store = b.store = a.timeAxis
            }
            if (c.width) {
                a.syncLockedWidth = Ext.emptyFn;
                c.scroll = Ext.supports.Touch ? "both" : "horizontal";
                c.scrollerOwner = true
            }
        },
        afterInitComponent: function () {
            var d = this;
            var c = d.lockedGrid.getView();
            var b = d.normalGrid.getView();
            var a = Ext.data.TreeStore && d.store instanceof Ext.data.TreeStore;
            if (d.normalGrid.collapsed) {
                d.normalGrid.collapsed = false;
                b.on("boxready", function () {
                    d.normalGrid.collapse()
                }, d, {delay: 10})
            }
            if (d.lockedGrid.collapsed) {
                d.lockedGrid.collapsed = false;
                c.on("boxready", function () {
                    d.lockedGrid.collapse()
                }, d, {delay: 10});
                if (c.bufferedRenderer) {
                    c.bufferedRenderer.disabled = true
                }
            }
            if (Ext.getScrollbarSize().width === 0) {
                c.addCls("sch-ganttpanel-force-locked-scroll")
            }
            if (a) {
                this.setupLockableFilterableTree()
            }
            this.on("afterrender", function () {
                var e = this.lockedGrid.headerCt.showMenuBy;
                this.lockedGrid.headerCt.showMenuBy = function () {
                    e.apply(this, arguments);
                    d.showMenuBy.apply(this, arguments)
                }
            })
        },
        setupLockableFilterableTree: function () {
            var c = this;
            var b = c.lockedGrid.getView();
            var a = Sch.mixin.FilterableTreeView.prototype;
            b.initTreeFiltering = a.initTreeFiltering;
            b.onFilterChangeStart = a.onFilterChangeStart;
            b.onFilterChangeEnd = a.onFilterChangeEnd;
            b.onFilterCleared = a.onFilterCleared;
            b.onFilterSet = a.onFilterSet;
            b.initTreeFiltering()
        },
        showMenuBy: function (b, f) {
            var e = this.getMenu(), c = e.down("#unlockItem"), d = e.down("#lockItem"), a = c.prev();
            a.hide();
            c.hide();
            d.hide()
        },
        zoomToFit: function (a) {
            a = Ext.apply({adjustStart: 1, adjustEnd: 1}, a);
            var b = this.getEventStore();
            var c = b.getTotalTimeSpan();
            if (this.zoomToSpan(c, a) === null) {
                this.getSchedulingView().fitColumns()
            }
        }
    }, function () {
        var a = "5.1.0";
        Ext.apply(Sch, {VERSION: "3.0.7"});
        if (Ext.versions.extjs.isLessThan(a)) {
            var b = console;
            b && b.log("The Ext JS version you are using needs to be updated to at least " + a)
        }
    })
}
Ext.define("Sch.panel.TimelineGridPanel", {
    extend: "Ext.grid.Panel",
    mixins: ["Sch.mixin.Localizable", "Sch.mixin.TimelinePanel"],
    subGridXType: "gridpanel",
    initComponent: function () {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView()
    }
}, function () {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {})
});
if (!Ext.ClassManager.get("Sch.panel.TimelineTreePanel")) {
    Ext.define("Sch.panel.TimelineTreePanel", {
        extend: "Ext.tree.Panel",
        requires: ["Ext.grid.Panel", "Ext.data.TreeStore", "Sch.mixin.FilterableTreeView", "Sch.patches.ColumnResizeTree"],
        mixins: ["Sch.mixin.Localizable", "Sch.mixin.TimelinePanel"],
        useArrows: true,
        rootVisible: false,
        lockedXType: "treepanel",
        initComponent: function () {
            this.callParent(arguments);
            this.getSchedulingView()._initializeTimelineView()
        }
    }, function () {
        this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {})
    })
}
Ext.define("Sch.plugin.Printable", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.scheduler_printable",
    requires: ["Ext.XTemplate"],
    lockableScope: "top",
    docType: "<!DOCTYPE HTML>",
    beforePrint: Ext.emptyFn,
    afterPrint: Ext.emptyFn,
    autoPrintAndClose: true,
    fakeBackgroundColor: true,
    scheduler: null,
    mainTpl: null,
    constructor: function (a) {
        Ext.apply(this, a);
        if (!this.mainTpl) {
            this.mainTpl = new Ext.XTemplate('{docType}<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /><title>{title}</title>{styles}</head><body class="sch-print-body {bodyClasses}"><div class="sch-print-ct {componentClasses}" style="width:{totalWidth}px"><div class="sch-print-headerbg" style="border-left-width:{totalWidth}px;height:{headerHeight}px;"></div><div class="sch-print-header-wrap">{[this.printLockedHeader(values)]}{[this.printNormalHeader(values)]}</div>{[this.printLockedGrid(values)]}{[this.printNormalGrid(values)]}</div><script type="text/javascript">{setupScript}<\/script></body></html>', {
                printLockedHeader: function (b) {
                    var c = "";
                    if (b.lockedGrid) {
                        c += '<div style="left:-' + b.lockedScroll + "px;margin-right:-" + b.lockedScroll + "px;width:" + (b.lockedWidth + b.lockedScroll) + 'px"';
                        c += 'class="sch-print-lockedheader ' + b.lockedGrid.headerCt.el.dom.className + '">';
                        c += b.lockedHeader;
                        c += "</div>"
                    }
                    return c
                }, printNormalHeader: function (b) {
                    var c = "";
                    if (b.normalGrid) {
                        c += '<div style="left:' + (b.lockedGrid ? b.lockedWidth : "0") + "px;width:" + b.normalWidth + 'px;" class="sch-print-normalheader ' + b.normalGrid.headerCt.el.dom.className + '">';
                        c += '<div style="margin-left:-' + b.normalScroll + 'px">' + b.normalHeader + "</div>";
                        c += "</div>"
                    }
                    return c
                }, printLockedGrid: function (b) {
                    var c = "";
                    if (b.lockedGrid) {
                        c += '<div id="lockedRowsCt" style="left:-' + b.lockedScroll + "px;margin-right:-" + b.lockedScroll + "px;width:" + (b.lockedWidth + b.lockedScroll) + "px;top:" + b.headerHeight + 'px;" class="sch-print-locked-rows-ct ' + b.innerLockedClasses + " " + Ext.baseCSSPrefix + 'grid-inner-locked">';
                        c += b.lockedRows;
                        c += "</div>"
                    }
                    return c
                }, printNormalGrid: function (b) {
                    var c = "";
                    if (b.normalGrid) {
                        c += '<div id="normalRowsCt" style="left:' + (b.lockedGrid ? b.lockedWidth : "0") + "px;top:" + b.headerHeight + "px;width:" + b.normalWidth + 'px" class="sch-print-normal-rows-ct ' + b.innerNormalClasses + '">';
                        c += '<div style="position:relative;overflow:visible;margin-left:-' + b.normalScroll + 'px">' + b.normalRows + "</div>";
                        c += "</div>"
                    }
                    return c
                }
            })
        }
    },
    init: function (a) {
        this.scheduler = a;
        a.print = Ext.Function.bind(this.print, this)
    },
    getGridContent: function (n) {
        var m = n.normalGrid, e = n.lockedGrid, o = e.getView(), g = m.getView(), j, d, l, i, k, b, h;
        this.beforePrint(n);
        if (e.collapsed && !m.collapsed) {
            b = e.getWidth() + m.getWidth()
        } else {
            b = m.getWidth();
            h = e.getWidth()
        }
        var c = o.store.getRange();
        d = o.tpl.apply(o.collectData(c, 0));
        l = g.tpl.apply(g.collectData(c, 0));
        i = o.el.getScroll().left;
        k = g.el.getScroll().left;
        var a = document.createElement("div");
        a.innerHTML = d;
        a.firstChild.style.width = o.el.dom.style.width;
        d = a.innerHTML;
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var f = (n.plugins || []).concat(n.normalGrid.plugins || []).concat(n.columnLinesFeature || []);
            Ext.each(f, function (p) {
                if (p instanceof Sch.feature.AbstractTimeSpan && p.generateMarkup) {
                    l = p.generateMarkup(true) + l
                }
            })
        }
        this.afterPrint(n);
        return {
            normalHeader: m.headerCt.el.dom.innerHTML,
            lockedHeader: e.headerCt.el.dom.innerHTML,
            lockedGrid: e.collapsed ? false : e,
            normalGrid: m.collapsed ? false : m,
            lockedRows: d,
            normalRows: l,
            lockedScroll: i,
            normalScroll: k,
            lockedWidth: h - (Ext.isWebKit ? 1 : 0),
            normalWidth: b,
            headerHeight: m.headerCt.getHeight(),
            innerLockedClasses: e.view.el.dom.className,
            innerNormalClasses: m.view.el.dom.className + (this.fakeBackgroundColor ? " sch-print-fake-background" : ""),
            width: n.getWidth()
        }
    },
    getStylesheets: function () {
        return Ext.getDoc().select('link[rel="stylesheet"]')
    },
    print: function () {
        var g = this.scheduler;
        if (!(this.mainTpl instanceof Ext.Template)) {
            var a = 22;
            this.mainTpl = new Ext.XTemplate(this.mainTpl, {compiled: true, disableFormats: true})
        }
        var h = g.getView(), i = this.getStylesheets(), e = Ext.get(Ext.core.DomHelper.createDom({tag: "div"})), b;
        i.each(function (j) {
            e.appendChild(j.dom.cloneNode(true))
        });
        b = e.dom.innerHTML + "";
        var f = this.getGridContent(g), c = this.mainTpl.apply(Ext.apply({
            waitText: this.waitText,
            docType: this.docType,
            htmlClasses: Ext.getBody().parent().dom.className,
            bodyClasses: Ext.getBody().dom.className,
            componentClasses: g.el.dom.className,
            title: (g.title || ""),
            styles: b,
            totalWidth: g.getWidth(),
            setupScript: ("window.onload = function(){ (" + this.setupScript.toString() + ")(" + g.syncRowHeight + ", " + this.autoPrintAndClose + ", " + Ext.isChrome + ", " + Ext.isIE + "); };")
        }, f));
        var d = window.open("", "printgrid");
        if (!d || !d.document) {
            return false
        }
        this.printWindow = d;
        d.document.write(c);
        d.document.close()
    },
    setupScript: function (e, a, d, b) {
        var c = function () {
            if (e) {
                var f = document.getElementById("lockedRowsCt"), o = document.getElementById("normalRowsCt"), g = f && f.getElementsByTagName("tr"), m = o && o.getElementsByTagName("tr"), k = m && g ? m.length : 0;
                for (var j = 0; j < k; j++) {
                    var h = m[j].clientHeight;
                    var l = g[j].clientHeight;
                    var n = Math.max(h, l) + "px";
                    g[j].style.height = m[j].style.height = n
                }
            }
            document._loaded = true;
            if (a) {
                window.print();
                if (!d) {
                    window.close()
                }
            }
        };
        if (b) {
            setTimeout(c, 0)
        } else {
            c()
        }
    }
});
Ext.define("Sch.plugin.exporter.AbstractExporter", {
    extend: "Ext.util.Observable",
    requires: ["Ext.dom.Element", "Ext.core.DomHelper"],
    mixins: ["Sch.mixin.Localizable"],
    pageHeaderHeight: 41,
    pageFooterHeight: 0,
    bufferedHeightMargin: 25,
    paperWidth: 0,
    paperHeight: 0,
    printHeight: 0,
    lockedRowsHeight: 0,
    normalRowsHeight: 0,
    iterateTimeout: 10,
    tableSelector: undefined,
    currentPage: undefined,
    headerTplDataFn: null,
    footerTplDataFn: null,
    headerTplDataFnScope: null,
    footerTplDataFnScope: null,
    config: {
        exporterId: "abstractexporter",
        name: "",
        translateURLsToAbsolute: true,
        expandAllBeforeExport: false,
        headerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        tpl: '<!DOCTYPE html><html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /><title>{title}</title>{styles}</head><body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">{header}<div class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">{HTML}</div>{footer}</body></html>',
        footerTpl: ""
    },
    callbacks: undefined,
    error: undefined,
    extractedPages: undefined,
    numberOfPages: 0,
    constructor: function (a) {
        var b = this;
        a = a || {};
        b.callParent(arguments);
        delete a.getUserHeaderTplData;
        delete a.getUserFooterTplData;
        b.initConfig(a);
        if (!a.tableSelector) {
            b.tableSelector = "." + Ext.baseCSSPrefix + "grid-item-container"
        }
        if (!a.name) {
            b.setName(b.L("name"))
        }
    },
    setHeaderTpl: function (a) {
        this.headerTpl = this.getTplInstance(a)
    },
    getHeaderTpl: function () {
        return this.headerTpl
    },
    setTpl: function (a) {
        this.tpl = this.getTplInstance(a)
    },
    getTpl: function () {
        return this.tpl
    },
    setFooterTpl: function (a) {
        this.footerTpl = this.getTplInstance(a)
    },
    getFooterTpl: function () {
        return this.footerTpl
    },
    getTplInstance: function (a) {
        return (a && !a.isTemplate) ? new Ext.XTemplate(a, {disableFormats: true}) : a
    },
    getBodyClasses: function () {
        var b = new RegExp(Ext.baseCSSPrefix + "ie\\d?|" + Ext.baseCSSPrefix + "gecko", "g"), a = Ext.getBody().dom.className.replace(b, "");
        if (Ext.isIE) {
            a += " sch-ie-export"
        }
        return a
    },
    getComponentClasses: function () {
        return this.getComponent().el.dom.className
    },
    setComponent: function (a) {
        var b = this;
        b.component = a;
        b.view = a.getSchedulingView();
        b.normalGrid = a.normalGrid;
        b.lockedGrid = a.lockedGrid;
        b.normalView = a.normalGrid.view;
        b.lockedView = a.lockedGrid.view;
        b.lockedBodySelector = "#" + b.lockedView.getId();
        b.normalBodySelector = "#" + b.normalView.getId();
        b.lockedHeader = b.lockedGrid.headerCt;
        b.normalHeader = b.normalGrid.headerCt;
        b.headerHeight = b.normalHeader.getHeight();
        b.printHeight = Math.floor(b.paperHeight) - b.headerHeight - (b.exportConfig.showHeader ? b.pageHeaderHeight : 0) - (b.exportConfig.showFooter ? b.pageFooterHeight : 0);
        b.saveComponentState(a)
    },
    getComponent: function () {
        return this.component
    },
    setPaperSize: function (a, b) {
        var c = this;
        if (b === "landscape") {
            c.paperWidth = a.height;
            c.paperHeight = a.width
        } else {
            c.paperWidth = a.width;
            c.paperHeight = a.height
        }
    },
    getPaperFormat: function () {
        return this.exportConfig.format
    },
    isBuffered: function () {
        return !!this.getBufferedRenderer()
    },
    getBufferedRenderer: function () {
        return this.view.bufferedRenderer
    },
    setComponentRange: function (d) {
        var f = this, c = f.getComponent(), b = f.view, a, e;
        if (d.range !== "complete") {
            switch (d.range) {
                case"date":
                    a = new Date(d.dateFrom);
                    e = new Date(d.dateTo);
                    if (Sch.util.Date.getDurationInDays(a, e) < 1) {
                        e = Sch.util.Date.add(e, Sch.util.Date.DAY, 1)
                    }
                    a = Sch.util.Date.constrain(a, c.getStart(), c.getEnd());
                    e = Sch.util.Date.constrain(e, c.getStart(), c.getEnd());
                    break;
                case"current":
                    var g = b.getVisibleDateRange();
                    a = g.startDate;
                    e = g.endDate || b.timeAxis.getEnd();
                    if (d.cellSize) {
                        var h = d.cellSize;
                        f.timeColumnWidth = h[0];
                        if (f.timeColumnWidth) {
                            c.setTimeColumnWidth(f.timeColumnWidth)
                        }
                        if (h.length > 1) {
                            f.view.setRowHeight(h[1])
                        }
                    }
                    break
            }
            c.setTimeSpan(a, e)
        }
        f.ticks = c.timeAxis.getTicks()
    },
    getStylesheets: function () {
        var d = this.translateURLsToAbsolute, c = Ext.getDoc().select('link[rel="stylesheet"]'), a = Ext.get(Ext.core.DomHelper.createDom({tag: "div"})), b;
        c.each(function (e) {
            var f = e.dom.cloneNode(true);
            d && f.setAttribute("href", e.dom.href);
            a.appendChild(f)
        });
        b = a.dom.innerHTML + "";
        return b
    },
    forEachTimeSpanPlugin: function (c, f, e) {
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var h = this;
            var b = (c.plugins || []).concat(c.normalGrid.plugins || []).concat(c.columnLinesFeature || []);
            for (var d = 0, a = b.length; d < a; d++) {
                var g = b[d];
                if (g instanceof Sch.feature.AbstractTimeSpan) {
                    f.call(e || h, g)
                }
            }
        }
    },
    prepareComponent: function (b, a) {
        var c = this;
        b = b || c.getComponent();
        c.suspendInfiniteScroll(b);
        c.forEachTimeSpanPlugin(b, function (d) {
            d._renderDelay = d.renderDelay;
            d.renderDelay = 0
        });
        b.getSchedulingView().timeAxisViewModel.suppressFit = true;
        b.timeAxis.autoAdjust = false;
        b.normalGrid.expand();
        b.lockedGrid.expand();
        c.prepareColumnConfig(a.columns);
        c.setComponentRange(a);
        if (c.expandAllBeforeExport && b.expandAll) {
            b.expandAll()
        }
        c.fitComponentIntoPage();
        if (c.isBuffered() && Ext.isIE8) {
            c.normalView.bufferedRenderer.variableRowHeight = false;
            c.lockedView.bufferedRenderer.variableRowHeight = false
        }
    },
    prepareColumnConfig: function (a) {
        var b = this;
        if (a) {
            b.lockedGrid.headerCt.items.each(function (c) {
                if (Ext.Array.contains(a, c)) {
                    c.show()
                } else {
                    c.hide()
                }
            })
        }
    },
    restoreComponent: function (a) {
        var b = this;
        a = a || b.getComponent();
        b.forEachTimeSpanPlugin(a, function (c) {
            c.renderDelay = c._renderDelay;
            delete c._renderDelay
        });
        b.restoreComponentState(a);
        b.restoreInfiniteScroll(a);
        b.exportConfig.afterExport && b.exportConfig.afterExport(a)
    },
    saveComponentState: function (b) {
        b = b || this.getComponent();
        var d = this, a = b.getSchedulingView(), e = b.normalGrid, f = b.lockedGrid;
        var c = [];
        f.headerCt.items.each(function (g) {
            c.push({column: g, visible: !g.isHidden()})
        });
        d.restoreSettings = {
            width: b.getWidth(),
            height: b.getHeight(),
            rowHeight: a.timeAxisViewModel.getViewRowHeight(),
            columnWidth: a.timeAxisViewModel.getTickWidth(),
            startDate: b.getStart(),
            endDate: b.getEnd(),
            normalWidth: e.getWidth(),
            normalLeft: e.getEl().getStyle("left"),
            lockedWidth: f.getWidth(),
            lockedCollapse: f.collapsed,
            normalCollapse: e.collapsed,
            columns: c,
            autoAdjust: b.timeAxis.autoAdjust,
            suppressFit: a.timeAxisViewModel.suppressFit,
            startIndex: a.all ? a.all.startIndex : 0
        }
    },
    restoreComponentState: function (c) {
        var d = this;
        c = c || d.getComponent();
        var b = d.restoreSettings, a = c.getSchedulingView();
        c.timeAxis.autoAdjust = b.autoAdjust;
        c.normalGrid.show();
        c.setWidth(b.width);
        c.setHeight(b.height);
        c.setTimeSpan(b.startDate, b.endDate);
        c.setTimeColumnWidth(b.columnWidth, true);
        a.setRowHeight(b.rowHeight);
        c.lockedGrid.show();
        Ext.Array.each(b.columns, function (e) {
            e.column.setVisible(e.visible)
        });
        c.normalGrid.setWidth(b.normalWidth);
        c.normalGrid.getEl().setStyle("left", b.normalLeft);
        c.lockedGrid.setWidth(b.lockedWidth);
        a.timeAxisViewModel.suppressFit = b.suppressFit;
        a.timeAxisViewModel.setTickWidth(b.columnWidth);
        if (b.lockedCollapse) {
            c.lockedGrid.collapse()
        }
        if (b.normalCollapse) {
            c.normalGrid.collapse()
        }
        if (d.getBufferedRenderer()) {
            d.scrollTo(b.startIndex);
            if (Ext.isIE8) {
                d.normalView.bufferedRenderer.variableRowHeight = true;
                d.lockedView.bufferedRenderer.variableRowHeight = true
            }
        }
    },
    extractPages: function (b, a, e, c) {
        var d = this;
        d.exportConfig = a;
        d.normalRows = [];
        d.lockedRows = [];
        d.extractedPages = [];
        d.numberOfPages = 0;
        d.lockedRowsHeight = 0;
        d.normalRowsHeight = 0;
        d.setPaperSize(a.pageSize, a.orientation);
        d.setComponent(b, a);
        d.prepareComponent(b, a);
        a.beforeExport && a.beforeExport(b, d.ticks);
        d.callbacks = {success: e || Ext.emptyFn, scope: c || d};
        setTimeout(function () {
            d.collectRows(d.onRowsCollected, d)
        }, 1)
    },
    onPagesExtracted: function (a) {
        var b = this;
        b.restoreComponent();
        b.submitPages(a)
    },
    submitPages: function (a) {
        var c = this, b = c.callbacks;
        b.success.call(b.scope, c.renderPages(a))
    },
    getCurrentPage: function () {
        return this.currentPage
    },
    setCurrentPage: function (a) {
        this.currentPage = a
    },
    getExpectedNumberOfPages: Ext.emptyFn,
    commitPage: function (a) {
        var b = this;
        b.numberOfPages++;
        var d = b.preparePageToCommit(a);
        var c = Ext.apply({html: d.dom.innerHTML, number: b.numberOfPages}, a);
        b.extractedPages.push(c);
        b.fireEvent("commitpage", b, c, b.numberOfPages, b.getExpectedNumberOfPages())
    },
    collectLockedRow: function (d, c) {
        var b = Ext.fly(d).getHeight();
        this.lockedRowsHeight += b;
        var a = {height: b, row: d.cloneNode(true), record: this.lockedView.getRecord(c)};
        this.lockedRows.push(a);
        return a
    },
    collectNormalRow: function (d, c) {
        var b = Ext.fly(d).getHeight();
        this.normalRowsHeight += b;
        var a = {height: Ext.fly(d).getHeight(), row: d.cloneNode(true), record: this.normalView.getRecord(c)};
        this.normalRows.push(a);
        return a
    },
    onRowsCollected: function () {
        throw"Sch.plugin.exporter.AbstractExporter: [onRowsCollected] Abstract method called."
    },
    iterateAsync: function (c, b) {
        var d = this;
        b = b || d;
        var a = function () {
            var f = arguments;
            var e = setInterval(function () {
                clearInterval(e);
                c.apply(b, [].concat.apply([a], f))
            }, d.iterateTimeout)
        };
        a.apply(d, Ext.Array.slice(arguments, 2))
    },
    callAsync: function (c, b) {
        b = b || this;
        var a = setInterval(function () {
            clearInterval(a);
            c.apply(b, Ext.Array.slice(arguments, 2))
        }, this.iterateTimeout)
    },
    collectRows: function (c, a) {
        var b = this;
        if (b.isBuffered()) {
            setTimeout(function () {
                b.scrollTo(0, function () {
                    b.iterateAsync(b.collectRowsStep, b, 0, c, a)
                })
            }, 1)
        } else {
            setTimeout(function () {
                b.collectRowsStep(null, 0, c, a)
            }, 1)
        }
    },
    collectRowsStep: function (d, h, j, k) {
        var g = this, c = g.normalView.all.endIndex, e = g.component.store.getCount(), f = g.normalView.all.slice(h), a = g.lockedView.all.slice(h);
        for (var b = 0; b < a.length; b++) {
            g.collectLockedRow(a[b], h + b)
        }
        for (b = 0; b < f.length; b++) {
            g.collectNormalRow(f[b], h + b)
        }
        g.fireEvent("collectrows", g, h, c, e);
        if (g.isBuffered()) {
            if (c + 1 < e) {
                g.callAsync(function () {
                    g.scrollTo(c + 1, function () {
                        d(c + 1, j, k)
                    })
                })
            } else {
                g.callAsync(function () {
                    g.scrollTo(0, function () {
                        j.call(k || g, g.lockedRows, g.normalRows)
                    })
                })
            }
        } else {
            j.call(k || g, g.lockedRows, g.normalRows)
        }
    },
    renderPages: function (a) {
        var d = this;
        a = a || d.extractedPages;
        for (var c = 0, b = a.length; c < b; c++) {
            var e = a[c];
            e.html = d.applyPageTpl(e)
        }
        return a
    },
    applyPageTpl: function (a) {
        var b = this;
        return b.getTpl().apply(b.getPageTplData(a))
    },
    applyHeaderTpl: function (b) {
        var c = this, e = c.getHeaderTpl();
        if (c.exportConfig.showHeader && e) {
            var a = c.headerTplDataFn;
            var d = a && a.call(c.headerTplDataFnScope || c, b);
            return e.apply(Ext.apply(c.getHeaderTplData(b), d))
        }
        return ""
    },
    applyFooterTpl: function (b) {
        var c = this, e = c.getFooterTpl();
        if (c.exportConfig.showFooter && e) {
            var a = c.footerTplDataFn;
            var d = a && a.call(c.footerTplDataFnScope || c, b);
            return e.apply(Ext.apply(c.getFooterTplData(b), d))
        }
        return ""
    },
    getHeaderTplData: function (a) {
        var b = this;
        return {width: b.paperWidth, height: b.pageHeaderHeight, totalPages: b.numberOfPages, pageNo: a.number}
    },
    getFooterTplData: function (a) {
        var b = this;
        return {width: b.paperWidth, height: b.pageFooterHeight, totalPages: b.numberOfPages, pageNo: a.number}
    },
    getPageTplData: function (a) {
        var b = this;
        return {
            bodyClasses: b.getBodyClasses(),
            bodyHeight: b.printHeight + b.headerHeight,
            componentClasses: b.getComponentClasses(),
            styles: b.getStylesheets(),
            showHeader: b.exportConfig.showHeader,
            showFooter: b.exportConfig.showFooter,
            header: b.applyHeaderTpl(a),
            HTML: a.html,
            footer: b.applyFooterTpl(a),
            totalWidth: b.paperWidth,
            title: a.number + " of " + b.numberOfPages
        }
    },
    fitComponentIntoPage: Ext.emptyFn,
    getLockedGridBody: function (a) {
        a = a || this.getCurrentPage();
        return a.select(this.lockedBodySelector + " > " + this.tableSelector).first()
    },
    getNormalGridBody: function (a) {
        a = a || this.getCurrentPage();
        return a.select(this.normalBodySelector + " > " + this.tableSelector).first()
    },
    emptyLockedGrid: function (a) {
        this.getLockedGridBody(a).select(this.lockedView.getItemSelector()).remove()
    },
    fillGrids: function (c, b, e, a) {
        var d = this;
        d.fillLockedGrid(c, e, a);
        d.fillNormalGrid(b, e, a)
    },
    fillLockedGrid: function (c, d, a) {
        var b = this;
        if (!a) {
            b.emptyLockedGrid()
        }
        b.appendRows(b.getLockedGridBody(), c || b.lockedRows, d)
    },
    fillNormalGrid: function (c, d, a) {
        var b = this;
        if (!a) {
            b.emptyNormalGrid()
        }
        b.appendRows(b.getNormalGridBody(), c || b.normalRows, d)
    },
    appendRows: function (d, c, f) {
        var e = d.dom;
        for (var b = 0, a = c.length; b < a; b++) {
            e.appendChild(f ? c[b].row.cloneNode(true) : c[b].row)
        }
    },
    emptyNormalGrid: function (a) {
        this.getNormalGridBody(a).select(this.normalView.getItemSelector()).remove()
    },
    getRowHeight: function () {
        return this.view.timeAxisViewModel.getViewRowHeight()
    },
    getTotalSize: function () {
        return {width: this.getTotalWidth(), height: this.getTotalHeight()}
    },
    getTotalHeight: function () {
        var b = this, a;
        if (b.isBuffered()) {
            a = b.bufferedHeightMargin + b.normalRowsHeight
        } else {
            a = b.lockedView.getEl().down(b.tableSelector).getHeight()
        }
        return b.headerHeight + a
    },
    getTotalWidth: function () {
        return this.getLockedGridWidth() + this.normalGrid.body.down(this.tableSelector).getWidth()
    },
    getLockedGridWidth: function () {
        return this.lockedHeader.getEl().first().getWidth()
    },
    getNormalGridWidth: function () {
        return this.normalHeader.getEl().first().getWidth()
    },
    preparePageToCommit: function () {
        var i = this.getCurrentPage(), g = this.component, c = g.lockedGrid, f = g.normalGrid;
        i.el.select(".sch-remove").remove();
        var b = function (l) {
            var k = i.select("#" + l).first();
            return k && k.dom
        }, j = function (k) {
            if (k) {
                k.style.width = "100%"
            }
        }, e = function (k) {
            if (k) {
                k.style.height = "100%"
            }
        };
        var a = i.select(this.normalBodySelector).first();
        a.dom.style.top = "0px";
        var h = i.select(this.lockedBodySelector).first();
        h.dom.style.top = "0px";
        var d = [b(g.id + "-targetEl"), b(g.id + "-innerCt"), b(c.id), b(c.body.id), b(c.view.el.id)];
        Ext.Array.forEach(d, e);
        j(d[0]);
        j(d[1]);
        j(b(f.headerCt.id));
        Ext.Array.forEach([b(f.id), b(f.body.id), b(f.getView().id)], function (k) {
            if (k) {
                k.style.height = k.style.width = "100%"
            }
        });
        return i
    },
    cloneElement: function (a) {
        return new Ext.dom.Element(Ext.core.DomHelper.createDom({tag: "div", html: a.dom.innerHTML}))
    },
    startPage: function (b) {
        var a = this;
        var c = a.cloneElement(b || a.getComponent().body);
        a.setCurrentPage(c)
    },
    scrollTo: function (a, d) {
        var c = this;
        if (c.component.ensureVisible) {
            var b = c.component.store.getAt(a);
            c.component.ensureVisible(b, {
                callback: function () {
                    if (d && this.isLocked === false) {
                        d.apply(c)
                    }
                }, select: false, focus: false, animate: false
            })
        } else {
            c.lockedView.bufferedRenderer.scrollTo(a, false, function () {
                c.normalView.bufferedRenderer.scrollTo(a, false, d)
            })
        }
    },
    removeNode: function (b) {
        if (b && b.parentNode) {
            b.parentNode.removeChild(b)
        } else {
            if (b.elements) {
                for (var a = 0; a < b.elements.length; a++) {
                    var c = b.elements[a];
                    c.parentNode.removeChild(c)
                }
            }
        }
    },
    restoreInfiniteScroll: function (b) {
        var a = b.getSchedulingView();
        if (b.infiniteScroll && a.rendered) {
            b.timeAxis.setTimeSpan(this._oldStart, this._oldEnd);
            a.setScrollX(this._oldScrollX);
            a.bindInfiniteScrollListeners()
        }
    },
    suspendInfiniteScroll: function (b) {
        var a = b.getSchedulingView();
        if (b.infiniteScroll && a.rendered) {
            a.unbindInfiniteScrollListeners();
            this._oldStart = b.timeAxis.getStart();
            this._oldEnd = b.timeAxis.getEnd();
            this._oldScrollX = a.getScrollX();
            var c = b.getEventStore().getTotalTimeSpan();
            b.setTimeSpan(c.start, c.end)
        }
    }
});
Ext.define("Sch.plugin.exporter.SinglePage", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {
        exporterId: "singlepage",
        headerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"></div>'
    },
    getExpectedNumberOfPages: function () {
        return 1
    },
    getPaperFormat: function () {
        var e = this, c = e.getTotalSize(), b = e.exportConfig.DPI, d = Ext.Number.toFixed(c.width / b, 1), a = Ext.Number.toFixed(c.height / b, 1);
        return d + "in*" + a + "in"
    },
    onRowsCollected: function () {
        var a = this;
        a.startPage();
        a.fillGrids();
        a.commitPage();
        a.onPagesExtracted()
    },
    getPageTplData: function () {
        var b = this, a = b.getTotalSize();
        return Ext.apply(b.callParent(arguments), {bodyHeight: a.height, showHeader: false, totalWidth: a.width})
    },
    getHeaderTplData: function (a) {
        var b = this;
        return {width: b.getTotalWidth(), height: b.pageHeaderHeight}
    },
    fitComponentIntoPage: function () {
        var a = this, b = a.lockedGrid;
        b.setWidth(b.headerCt.getEl().first().getWidth())
    },
    preparePageToCommit: function () {
        var e = this, f = e.callParent(arguments), d = f.select(".sch-secondary-canvas").first(), c = d.select(".sch-zone"), b = d.select(".sch-column-line");
        var a = e.getTotalHeight();
        d.setTop(0);
        c.setHeight(a);
        b.setHeight(a);
        return f
    }
});
Ext.define("Sch.plugin.exporter.MultiPage", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {exporterId: "multipage"},
    rowPageIndex: 0,
    columnPageIndex: 0,
    pagesPerColumn: 0,
    extractPages: function () {
        this.enableGarbageCollector = Ext.enableGarbageCollector;
        Ext.enableGarbageCollector = false;
        Ext.dom.GarbageCollector.pause();
        return this.callParent(arguments)
    },
    onRowsCollected: function (b, a) {
        var c = this;
        c.rowPageIndex = 0;
        c.columnPageIndex = 0;
        c.pagesPerColumn = 0;
        c.buildPageFrames(function () {
            c.buildPages(function () {
                c.onPagesExtracted.apply(c, arguments);
                Ext.enableGarbageCollector = c.enableGarbageCollector;
                Ext.dom.GarbageCollector.resume()
            }, c, b, a)
        })
    },
    buildPages: function (f, c, b, a) {
        var d = this, e = d.pageFrames[0];
        d.startPage(e, true);
        this.iterateAsync(d.rowIteratorStep, d, {
            rowIndex: 0,
            pageFrame: e,
            rowsHeight: 0,
            leftHeight: this.printHeight,
            lockeds: [],
            normals: [],
            lockedRows: b,
            normalRows: a,
            callback: f,
            scope: c || d
        })
    },
    rowIteratorStep: function (g, a) {
        var j = this, k = a.rowIndex, b = a.lockedRows, h = a.normalRows, i = a.leftHeight, d = a.lockeds, l = a.normals, c = true;
        if (k < b.length) {
            var f = b[k], e = h[k];
            if (f.height <= i) {
                d.push(f);
                l.push(e);
                a.leftHeight -= f.height;
                a.rowsHeight += f.height;
                c = false
            } else {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({rowsHeight: a.rowsHeight});
                j.startPage(a.pageFrame);
                a.lockeds = [f];
                a.normals = [e];
                a.leftHeight = j.printHeight - f.height;
                a.rowsHeight = f.height
            }
            a.rowIndex++
        } else {
            if (j.columnPageIndex < j.pageFrames.length) {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({rowsHeight: a.rowsHeight});
                a.pageFrame = j.pageFrames[j.columnPageIndex];
                j.startPage(a.pageFrame, true);
                a.leftHeight = j.printHeight;
                a.rowsHeight = 0;
                a.lockeds = [];
                a.normals = [];
                a.rowIndex = 0
            } else {
                j.fillGrids(d, l, a.pageFrame);
                j.commitPage({rowsHeight: a.rowsHeight});
                a.callback.call(a.scope);
                return
            }
        }
        if (c) {
            g(a)
        } else {
            j.rowIteratorStep(g, a)
        }
    },
    fillGrids: function (e, d, f) {
        var c = this, b = c.lockedColumnPages[c.columnPageIndex - 1], a = !b || (b && b.leftWidth);
        if (b) {
            c.fillLockedGrid(e, true);
            c.removeHiddenLockedColumns(b)
        }
        if (a) {
            c.fillNormalGrid(d, true);
            c.removeInvisibleEvents(-f.normalGridOffset, -f.normalGridOffset + f.normalGridWidth)
        }
    },
    buildPageFrame: function (h, b) {
        var f = this, j = f.lockedColumnPages[h];
        if (j) {
            f.lockedGrid.setWidth(f.showLockedColumns(j.start, j.end) + (j.startOffset || 0));
            if (j.leftWidth) {
                f.normalGrid.show()
            } else {
                f.normalGrid.hide()
            }
        } else {
            f.lockedGrid.setWidth(0);
            f.lockedGrid.hide();
            f.normalGrid.show()
        }
        var a = f.cloneElement(f.getComponent().body);
        a.normalGridOffset = b;
        a.lockedGridOffset = j && j.startOffset || 0;
        a.normalGridWidth = f.normalGrid.getWidth();
        a.lockedGridWidth = f.lockedGrid.getWidth();
        a.select(f.lockedBodySelector).first().dom.style.position = "";
        a.select("#" + f.lockedView.id).first().dom.style.overflow = "visible";
        if (!f.normalGrid.hidden) {
            var i = a.select(f.normalBodySelector).first();
            i.dom.style.position = "";
            i.dom.style.top = "0px";
            var d = f.getNormalGridBody(a);
            var c = a.select("#" + f.normalView.headerCt.id).first();
            var e = a.select(".sch-secondary-canvas").first();
            var g = a.select("#" + f.normalView.id).first();
            d.dom.style.left = b + "px";
            c.dom.style.left = b + "px";
            c.dom.style.overflow = "visible";
            e.dom.style.left = b + "px";
            g.dom.style.overflow = "visible"
        }
        return a
    },
    buildPageFrames: function (e, c) {
        var d = this;
        c = c || d;
        d.lockedColumnPages = d.calculateLockedColumnPages();
        var a = Math.ceil(d.getTotalWidth() / d.paperWidth), b = d.pageFrames = [];
        d.iterateAsync(function (h, g, i) {
            if (g >= a) {
                e.call(c, b);
                return
            }
            b.push(d.buildPageFrame(g, i));
            var f = d.lockedColumnPages[g];
            if (f) {
                i -= f.leftWidth || 0
            } else {
                i -= d.paperWidth
            }
            h(g + 1, i)
        }, d, 0, 0)
    },
    startPage: function (c, a) {
        var b = this;
        if (a) {
            if (b.columnPageIndex == 1) {
                b.pagesPerColumn = b.extractedPages.length
            }
            b.rowPageIndex = 0;
            b.columnPageIndex++
        }
        b.rowPageIndex++;
        b.callParent(arguments);
        b.emptyNormalGrid();
        b.emptyLockedGrid()
    },
    commitPage: function (a) {
        var b = this;
        b.callParent([Ext.apply({row: b.rowPageIndex, column: b.columnPageIndex}, a)])
    },
    getExpectedPagesPerColumn: function () {
        return this.pagesPerColumn || Math.ceil((this.lockedRowsHeight || this.component.store.count() * this.component.getRowHeight()) / this.printHeight)
    },
    getExpectedColumnsNumber: function () {
        return this.pageFrames ? this.pageFrames.length : Math.ceil((this.lockedGrid.getWidth() + this.ticks.length * this.view.timeAxisViewModel.getTickWidth()) / this.paperWidth)
    },
    getExpectedNumberOfPages: function () {
        return this.getExpectedColumnsNumber() * this.getExpectedPagesPerColumn()
    },
    calculateLockedColumnPages: function () {
        var h = this, j = [], c = h.lockedColumns, e = h.paperWidth, g;
        for (var f = 0, d = c.length; f < d; f++) {
            var b = c[f], a = b.width;
            g = g || {start: f, end: f};
            e -= a;
            if (e < 0) {
                j.push(g);
                if (e) {
                    g = {start: f, end: f}
                }
                e = h.paperWidth - a + e
            } else {
                g.end = f
            }
        }
        if (g) {
            g.leftWidth = e;
            j.push(g)
        }
        return j
    },
    getPageTplData: function (a) {
        return Ext.apply(this.callParent(arguments), {title: a.number + " of " + this.numberOfPages + " (column: " + a.column + ", row: " + a.row + ")"})
    },
    showLockedColumns: function (e, g) {
        var f = this, b = f.lockedColumns, d = 0;
        e = e || 0;
        g = g || b.length - 1;
        for (var a = 0; a < b.length; a++) {
            var c = b[a];
            if (a >= e && a <= g) {
                c.column.show();
                d += c.width
            } else {
                c.column.hide()
            }
        }
        return d
    },
    removeInvisibleEvents: function (b, h) {
        var j = this, d = j.getNormalGridBody(), e = j.normalView.eventCls;
        var a = d.select("." + e).elements;
        for (var g = 0; g < a.length; g++) {
            var c = parseInt(a[g].style.left, 10), f = c + parseInt(a[g].style.width, 10);
            if (f < b || c > h) {
                j.removeNode(a[g])
            }
        }
    },
    removeHiddenLockedColumns: function (b) {
        var j = this, h = j.getCurrentPage(), a = j.getLockedGridBody();
        for (var f = 0; f < j.lockedColumns.length; f++) {
            var c = j.lockedColumns[f].column;
            if (f < b.start || f > b.end) {
                var d = "#" + c.getId();
                var g = h.select(d);
                j.removeNode(g);
                var e = c.getCellSelector();
                var k = a.select(e);
                j.removeNode(k)
            }
        }
    },
    fitComponentIntoPage: function () {
        var a = this;
        a.getComponent().setWidth(a.paperWidth)
    },
    prepareComponent: function (b, a) {
        var d = this, c = d.lockedColumns = [];
        d.callParent(arguments);
        d.lockedGrid.headerCt.items.each(function (e) {
            if (!e.hidden) {
                c.push({column: e, width: e.getWidth()})
            }
        })
    },
    restoreComponentState: function () {
        this.callParent(arguments);
        this.showLockedColumns()
    }
});
Ext.define("Sch.plugin.exporter.MultiPageVertical", {
    extend: "Sch.plugin.exporter.AbstractExporter",
    config: {exporterId: "multipagevertical"},
    minRowHeight: 20,
    visibleColumns: null,
    visibleColumnsWidth: 0,
    onRowsCollected: function (b, a) {
        var c = this;
        c.iterateAsync(function (g, j) {
            if (j === b.length) {
                c.onPagesExtracted();
                return
            }
            var h = j, f = c.printHeight, l = 0, e = [], k = [], i, d = false;
            c.startPage();
            while (!d && h < b.length) {
                i = a[h];
                f -= i.height;
                if (f > 0) {
                    l += i.height;
                    e.push(b[h]);
                    k.push(i);
                    h++
                } else {
                    d = true
                }
            }
            c.fillGrids(e, k);
            c.commitPage({rowIndex: h, rowsHeight: l});
            g(h)
        }, c, 0)
    },
    startPage: function () {
        var b = this;
        b.callParent(arguments);
        var a = b.getCurrentPage().select("#" + b.lockedView.id).first();
        a.dom.style.overflow = "visible"
    },
    getExpectedNumberOfPages: function () {
        return Math.ceil(this.lockedRowsHeight / this.printHeight)
    },
    prepareComponent: function (c, b) {
        var d = this, a = d.visibleColumns = [];
        d.callParent(arguments);
        d.visibleColumnsWidth = 0;
        d.lockedGrid.headerCt.items.each(function (e) {
            if (!e.hidden) {
                a.push({column: e, width: e.getWidth()});
                d.visibleColumnsWidth += e.getWidth()
            }
        })
    },
    fitComponentIntoPage: function () {
        var i = this, j = i.getComponent(), h = j.normalGrid, c = j.lockedGrid, f = i.getTotalWidth(), k = i.ticks, e = i.timeColumnWidth || i.restoreSettings.columnWidth;
        var d = Math.floor((i.visibleColumnsWidth / f) * i.paperWidth);
        var b = Math.floor((k.length * e / f) * i.paperWidth);
        var g = Math.floor(b / k.length);
        var a = (g / e) * i.getRowHeight();
        i.view.setRowHeight(a < i.minRowHeight ? i.minRowHeight : a);
        j.setWidth(i.paperWidth);
        h.setWidth(b);
        c.setWidth(d);
        i.fitLockedColumnWidth(d);
        j.setTimeColumnWidth(g)
    },
    fitLockedColumnWidth: function (a) {
        var b = this.visibleColumns;
        if (b.length) {
            var d = a / b.length;
            for (var c = 0; c < b.length; c++) {
                b[c].column.setWidth(d)
            }
            this._restoreColumnWidth = true
        }
    },
    restoreComponentState: function () {
        this.callParent(arguments);
        if (this._restoreColumnWidth) {
            var b = this.visibleColumns;
            for (var c = 0; c < b.length; c++) {
                var a = b[c];
                a.column.setWidth(a.width)
            }
        }
    }
});
Ext.define("Sch.plugin.Export", {
    extend: "Ext.util.Observable",
    alternateClassName: "Sch.plugin.PdfExport",
    alias: "plugin.scheduler_export",
    mixins: ["Ext.AbstractPlugin", "Sch.mixin.Localizable"],
    requires: ["Ext.XTemplate", "Sch.plugin.exporter.SinglePage", "Sch.plugin.exporter.MultiPage", "Sch.plugin.exporter.MultiPageVertical"],
    lockableScope: "top",
    pageSizes: {
        A5: {width: 5.8, height: 8.3},
        A4: {width: 8.3, height: 11.7},
        A3: {width: 11.7, height: 16.5},
        Letter: {width: 8.5, height: 11},
        Legal: {width: 8.5, height: 14}
    },
    DPI: 72,
    printServer: undefined,
    timeout: 60000,
    headerTpl: null,
    headerTplDataFn: null,
    headerTplDataFnScope: null,
    tpl: null,
    footerTpl: null,
    footerTplDataFn: null,
    footerTplDataFnScope: null,
    exportDialogClassName: "Sch.widget.ExportDialog",
    exportDialogConfig: {},
    exporterConfig: null,
    exportConfig: {format: "A4", orientation: "portrait", range: "complete", showHeader: true, showFooter: false},
    expandAllBeforeExport: false,
    translateURLsToAbsolute: true,
    openAfterExport: true,
    beforeExport: Ext.emptyFn,
    afterExport: Ext.emptyFn,
    fileFormat: "pdf",
    defaultExporter: "multipage",
    exporters: undefined,
    callbacks: undefined,
    constructor: function (a) {
        var b = this;
        a = a || {};
        b.exportersIndex = {};
        if (a.exportDialogConfig) {
            Ext.Object.each(this.exportConfig, function (d, c, f) {
                var e = a.exportDialogConfig[d];
                if (e) {
                    f[d] = e
                }
            })
        }
        b.callParent([a]);
        b.setFileFormat(b.fileFormat);
        if (!b.exporters) {
            b.exporters = b.buildExporters()
        }
        b.initExporters();
        b.bindExporters()
    },
    init: function (a) {
        var b = this;
        a.showExportDialog = Ext.Function.bind(b.showExportDialog, b);
        a.doExport = Ext.Function.bind(b.doExport, b);
        b.scheduler = a
    },
    initExporters: function () {
        var c = this, b = c.exporters;
        for (var a = 0; a < b.length; a++) {
            if (!(b[a]instanceof Sch.plugin.exporter.AbstractExporter)) {
                b[a] = c.createExporter(b[a])
            }
        }
    },
    bindExporters: function () {
        var b = this.exporters;
        for (var a = 0; a < b.length; a++) {
            this.bindExporter(b[a])
        }
    },
    bindExporter: function (b) {
        var a = this;
        a.mon(b, {commitpage: a.onPageCommit, collectrows: a.onRowCollected, scope: a})
    },
    unbindExporter: function (b) {
        var a = this;
        a.mun(b, {commitpage: a.onPageCommit, collectrows: a.onRowCollected, scope: a})
    },
    buildExporters: function () {
        return ["Sch.plugin.exporter.SinglePage", "Sch.plugin.exporter.MultiPage", "Sch.plugin.exporter.MultiPageVertical"]
    },
    getExporterConfig: function (c, b) {
        var d = this;
        var a = Ext.apply({
            translateURLsToAbsolute: d.translateURLsToAbsolute,
            expandAllBeforeExport: d.expandAllBeforeExport,
            DPI: d.DPI
        }, d.exporterConfig);
        if (d.headerTpl) {
            a.headerTpl = d.headerTpl
        }
        if (d.headerTplDataFn) {
            a.headerTplDataFn = d.headerTplDataFn;
            a.headerTplDataFnScope = d.headerTplDataFnScope
        }
        if (d.tpl) {
            a.tpl = d.tpl
        }
        if (d.footerTpl) {
            a.footerTpl = d.footerTpl
        }
        if (d.footerTplDataFn) {
            a.footerTplDataFn = d.footerTplDataFn;
            a.footerTplDataFnScope = d.footerTplDataFnScope
        }
        return a
    },
    createExporter: function (b, a) {
        var c = this, d = c.getExporterConfig(b, a);
        if (Ext.isObject(b)) {
            return Ext.create(Ext.apply(d, b))
        } else {
            return Ext.create(b, Ext.apply(d, a))
        }
    },
    registerExporter: function (b, a) {
        if (!(b instanceof Sch.plugin.exporter.AbstractExporter)) {
            b = this.createExporter.apply(this, arguments)
        }
        this.exporters.push(b);
        this.bindExporter(b)
    },
    getExporter: function (b) {
        if (!b) {
            return
        }
        var a = this.exportersIndex[b];
        if (a) {
            return a
        }
        a = this.exportersIndex[b] = Ext.Array.findBy(this.exporters, function (c) {
            return c.getExporterId() == b
        });
        return a
    },
    getExporters: function () {
        return this.exporters
    },
    setFileFormat: function (a) {
        if (typeof a !== "string") {
            this.fileFormat = "pdf"
        } else {
            a = a.toLowerCase();
            if (a === "png") {
                this.fileFormat = a
            } else {
                this.fileFormat = "pdf"
            }
        }
    },
    showExportDialog: function () {
        var b = this, a = b.scheduler.getSchedulingView();
        if (b.win) {
            b.win.destroy();
            b.win = null
        }
        b.win = Ext.create(b.exportDialogClassName, {
            plugin: b,
            exportDialogConfig: Ext.apply({
                startDate: b.scheduler.getStart(),
                endDate: b.scheduler.getEnd(),
                rowHeight: a.timeAxisViewModel.getViewRowHeight(),
                columnWidth: a.timeAxisViewModel.getTickWidth(),
                defaultExporter: b.defaultExporter,
                exporters: b.exporters,
                exportConfig: b.exportConfig
            }, b.exportDialogConfig)
        });
        b.win.show()
    },
    getExportConfig: function (b) {
        var c = this;
        var a = Ext.apply({
            fileFormat: c.fileFormat,
            exporterId: c.defaultExporter,
            beforeExport: Ext.Function.bind(c.beforeExport, c),
            afterExport: Ext.Function.bind(c.afterExport, c)
        }, b, c.exportConfig);
        a.DPI = a.DPI || c.DPI;
        a.pageSize = Ext.apply({}, c.pageSizes[a.format]);
        a.pageSize.width *= a.DPI;
        a.pageSize.height *= a.DPI;
        return a
    },
    doExport: function (d, h, a, e) {
        var f = this, c = f.scheduler, b = f.getExportConfig(d);
        f.callbacks = {success: h || Ext.emptyFn, failure: a || Ext.emptyFn, scope: e || f};
        var g = f.exporter = f.getExporter(b.exporterId);
        if (g && f.fireEvent("beforeexport", c, g, b) !== false) {
            f.mask();
            f.exporter.extractPages(c, b, function (i) {
                f.fireEvent("updateprogressbar", 0.8, this.L("requestingPrintServer"));
                f.doRequest(i, b)
            }, f)
        }
    },
    onRowCollected: function (c, d, b, a) {
        this.fireEvent("updateprogressbar", 0.2 * (b + 1) / a, Ext.String.format(this.L("fetchingRows"), b + 1, a))
    },
    onPageCommit: function (d, c, b, a) {
        a = Math.max(b, a);
        this.fireEvent("updateprogressbar", 0.2 + 0.6 * b / a, Ext.String.format(this.L("builtPage"), b, a))
    },
    onExportSuccess: function (a) {
        var e = this, f = e.getWin(), d = e.callbacks, c = d && d.success, b = d && d.scope || e;
        e.fireEvent("updateprogressbar", 1);
        e.unmask();
        c && c.apply(b, arguments);
        setTimeout(function () {
            e.fireEvent("hidedialogwindow", a);
            if (e.openAfterExport) {
                window.open(a.url, "ExportedPanel")
            }
        }, f ? f.hideTime : 3000)
    },
    onExportFailure: function (f, a) {
        var e = this, g = this.getWin(), d = e.callbacks, c = d && d.failure, b = d && d.scope || e;
        c && c.call(b, f);
        e.fireEvent("showdialogerror", g, f, a);
        e.unmask()
    },
    doRequest: function (a, b) {
        var f = this, g = f.scheduler;
        if (!f.test && !f.debug) {
            if (f.printServer) {
                var j = {
                    type: "POST",
                    url: f.printServer,
                    timeout: f.timeout,
                    params: Ext.apply({
                        html: {array: Ext.JSON.encode(a)},
                        startDate: g.getStartDate(),
                        endDate: g.getEndDate(),
                        format: f.exporter.getPaperFormat(),
                        orientation: b.orientation,
                        range: b.range,
                        fileFormat: f.fileFormat
                    }, this.getParameters()),
                    success: f.onRequestSuccess,
                    failure: f.onRequestFailure,
                    scope: f
                };
                Ext.apply(j, this.getAjaxConfig(j));
                Ext.Ajax.request(j)
            } else {
                f.onExportFailure("Print server URL is not defined, please specify printServer config")
            }
        } else {
            if (f.debug) {
                var c = a || [];
                for (var e = 0, d = c.length; e < d; e++) {
                    var h = window.open();
                    h.document.write(c[e].html);
                    h.document.close()
                }
            }
            f.onExportSuccess(f.testResponse || {success: true, url: "foo", htmlArray: a})
        }
    },
    onRequestSuccess: function (b) {
        var c = this, a;
        try {
            a = Ext.JSON.decode(b.responseText)
        } catch (d) {
            c.onExportFailure("Wrong server response received");
            return
        }
        if (a.success) {
            c.onExportSuccess(a)
        } else {
            c.onExportFailure(a.msg, a)
        }
    },
    onRequestFailure: function (a) {
        var b = this, c = a.status === 200 ? a.responseText : a.statusText;
        b.onExportFailure(c, a)
    },
    getParameters: function () {
        return {}
    },
    getAjaxConfig: function (a) {
        return {}
    },
    getWin: function () {
        return this.win || null
    },
    mask: function () {
        var a = Ext.getBody().mask();
        a.addCls("sch-export-mask")
    },
    unmask: function () {
        Ext.getBody().unmask()
    },
    destroy: function () {
        this.callParent(arguments);
        if (this.win) {
            this.win.destroy()
        }
    }
});
Ext.define("Sch.plugin.HeaderZoom", {
    extend: "Sch.util.DragTracker",
    mixins: ["Ext.AbstractPlugin"],
    alias: "plugin.scheduler_headerzoom",
    lockableScope: "top",
    scheduler: null,
    proxy: null,
    headerRegion: null,
    init: function (a) {
        this.scheduler = a;
        this.onModeChange();
        a.on("modechange", this.onModeChange, this)
    },
    onOrientationChange: function () {
        return this.onModeChange.apply(this, arguments)
    },
    onModeChange: function () {
        var a = this.scheduler.down("timeaxiscolumn");
        if (a) {
            if (a.rendered) {
                this.onTimeAxisColumnRender(a)
            } else {
                a.on({afterrender: this.onTimeAxisColumnRender, scope: this})
            }
        }
    },
    onTimeAxisColumnRender: function (a) {
        this.proxy = a.el.createChild({cls: "sch-drag-selector"});
        this.initEl(a.el)
    },
    onStart: function (a) {
        this.proxy.show();
        this.headerRegion = this.scheduler.normalGrid.headerCt.getRegion()
    },
    onDrag: function (b) {
        var c = this.headerRegion;
        var a = this.getRegion().constrainTo(c);
        a.top = c.top;
        a.bottom = c.bottom;
        this.proxy.setBox(a)
    },
    onEnd: function (h) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);
            var c = this.scheduler;
            var g = this.getRegion();
            var b = c.getSchedulingView().getStartEndDatesFromRegion(g);
            if (b) {
                var f = c.timeAxis;
                var d = c.getSchedulingView().timeAxisViewModel.getBottomHeader().unit;
                var i = f.floorDate(b.start, false, d, 1);
                var a = f.ceilDate(b.end, false, d, 1);
                if (this.fireEvent("beforeheaderzoom", this, c, i, a) !== false) {
                    c.zoomToSpan({start: i, end: a})
                }
            }
        }
    },
    destroy: function () {
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null
        }
        this.callParent(arguments)
    }
});
Ext.define("Sch.widget.ColumnPicker", {
    extend: "Ext.form.field.ComboBox",
    requires: ["Ext.data.Store", "Ext.panel.Table"],
    multiSelect: true,
    valueField: "id",
    displayField: "name",
    forceSelection: true,
    editable: false,
    listConfig: {cls: "sch-columnpicker-list"},
    columns: null,
    store: {proxy: "memory", fields: ["id", "name", "column"]},
    initComponent: function () {
        var a = this;
        Ext.applyIf(a.store, {data: this.processColumns(this.columns)});
        this.callParent(arguments)
    },
    processColumns: function (a) {
        var c = [], b = [];
        Ext.Array.forEach(a, function (d) {
            c.push({id: d.id, name: d.text, column: d});
            if (!d.isHidden()) {
                b.push(d.id)
            }
        });
        this.value = this.value || b;
        return c
    },
    getSelectedColumns: function () {
        var a = this, b = a.getValue();
        b = Ext.isArray(b) ? b : [b];
        return Ext.Array.map(b, function (c) {
            return a.store.getById(c).get("column")
        })
    }
});
Ext.define("Sch.widget.ResizePicker", {
    extend: "Ext.Panel",
    alias: "widget.dualrangepicker",
    width: 200,
    height: 200,
    border: true,
    collapsible: false,
    bodyStyle: "position:absolute; margin:5px",
    verticalCfg: {height: 120, value: 24, increment: 2, minValue: 20, maxValue: 80, reverse: true, disabled: true},
    horizontalCfg: {width: 120, value: 100, minValue: 25, increment: 5, maxValue: 200, disable: true},
    initComponent: function () {
        var a = this;
        a.horizontalCfg.value = a.dialogConfig.columnWidth;
        a.verticalCfg.value = a.dialogConfig.rowHeight;
        a.verticalCfg.disabled = a.dialogConfig.scrollerDisabled || false;
        a.dockedItems = [a.vertical = new Ext.slider.Single(Ext.apply({
            dock: "left",
            style: "margin-top:10px",
            vertical: true,
            listeners: {change: a.onSliderChange, changecomplete: a.onSliderChangeComplete, scope: a}
        }, a.verticalCfg)), a.horizontal = new Ext.slider.Single(Ext.apply({
            dock: "top",
            style: "margin-left:28px",
            listeners: {change: a.onSliderChange, changecomplete: a.onSliderChangeComplete, scope: a}
        }, a.horizontalCfg))];
        a.callParent(arguments)
    },
    afterRender: function () {
        var b = this;
        b.addCls("sch-ux-range-picker");
        b.valueHandle = this.body.createChild({cls: "sch-ux-range-value", cn: {tag: "span"}});
        b.valueSpan = this.valueHandle.down("span");
        var a = new Ext.dd.DD(this.valueHandle);
        Ext.apply(a, {
            startDrag: function () {
                b.dragging = true;
                this.constrainTo(b.body)
            }, onDrag: function () {
                b.onHandleDrag.apply(b, arguments)
            }, endDrag: function () {
                b.onHandleEndDrag.apply(b, arguments);
                b.dragging = false
            }, scope: this
        });
        this.setValues(this.getValues());
        this.callParent(arguments);
        this.body.on("click", this.onBodyClick, this)
    },
    onBodyClick: function (c, a) {
        var b = [c.getXY()[0] - 8 - this.body.getX(), c.getXY()[1] - 8 - this.body.getY()];
        this.valueHandle.setLeft(Ext.Number.constrain(b[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(b[1], 0, this.getAvailableHeight()));
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
        this.onSliderChangeComplete()
    },
    getAvailableWidth: function () {
        return this.body.getWidth() - 18
    },
    getAvailableHeight: function () {
        return this.body.getHeight() - 18
    },
    onHandleDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]))
    },
    onHandleEndDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]))
    },
    getValuesFromXY: function (d) {
        var c = d[0] / this.getAvailableWidth();
        var a = d[1] / this.getAvailableHeight();
        var e = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * c);
        var b = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * a) + this.verticalCfg.minValue;
        return [e + this.horizontalCfg.minValue, b]
    },
    getXYFromValues: function (d) {
        var b = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var f = this.verticalCfg.maxValue - this.verticalCfg.minValue;
        var a = Math.round((d[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / b);
        var c = d[1] - this.verticalCfg.minValue;
        var e = Math.round(c * this.getAvailableHeight() / f);
        return [a, e]
    },
    updatePosition: function () {
        var a = this.getValues();
        var b = this.getXYFromValues(a);
        this.valueHandle.setLeft(Ext.Number.constrain(b[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled) {
            this.valueHandle.setTop(this.dialogConfig.rowHeight)
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(b[1], 0, this.getAvailableHeight()))
        }
        this.positionValueText();
        this.setValueText(a)
    },
    positionValueText: function () {
        var a = this.valueHandle.getTop(true);
        var b = this.valueHandle.getLeft(true);
        this.valueSpan.setLeft(b > 30 ? -30 : 10);
        this.valueSpan.setTop(a > 10 ? -20 : 20)
    },
    setValueText: function (a) {
        if (this.verticalCfg.disabled) {
            a[1] = this.dialogConfig.rowHeight
        }
        this.valueSpan.update("[" + a.toString() + "]")
    },
    setValues: function (a) {
        this.horizontal.setValue(a[0]);
        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled) {
                this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - a[1])
            }
        } else {
            if (!this.verticalCfg.disabled) {
                this.vertical.setValue(a[1])
            }
        }
        if (!this.dragging) {
            this.updatePosition()
        }
        this.positionValueText();
        this.setValueText(a)
    },
    getValues: function () {
        if (!this.verticalCfg.disabled) {
            var a = this.vertical.getValue();
            if (this.verticalCfg.reverse) {
                a = this.verticalCfg.maxValue - a + this.verticalCfg.minValue
            }
            return [this.horizontal.getValue(), a]
        }
        return [this.horizontal.getValue()]
    },
    onSliderChange: function () {
        this.fireEvent("change", this, this.getValues());
        if (!this.dragging) {
            this.updatePosition()
        }
    },
    onSliderChangeComplete: function () {
        this.fireEvent("changecomplete", this, this.getValues())
    },
    afterLayout: function () {
        this.callParent(arguments);
        this.updatePosition()
    }
});
Ext.define("Sch.widget.ExportDialogForm", {
    extend: "Ext.form.Panel",
    requires: ["Ext.data.Store", "Ext.XTemplate", "Ext.ProgressBar", "Ext.form.field.ComboBox", "Ext.form.field.Date", "Ext.form.FieldContainer", "Ext.form.field.Checkbox", "Sch.widget.ResizePicker", "Sch.widget.ColumnPicker"],
    border: false,
    bodyPadding: "10 10 0 10",
    autoHeight: true,
    initComponent: function () {
        var a = this;
        a.fieldDefaults = Ext.applyIf(a.fieldDefaults || {}, {labelAlign: "left", labelWidth: 120, anchor: "99%"});
        a.items = a.createFields();
        a.items.push(a.progressBar || a.createProgressBar());
        a.callParent(arguments);
        a.onRangeChange(null, a.dialogConfig.exportConfig.range);
        a.onExporterChange(a.exportersField, a.exportersField.getValue());
        a.on({
            hideprogressbar: a.hideProgressBar,
            showprogressbar: a.showProgressBar,
            updateprogressbar: a.updateProgressBar,
            scope: a
        })
    },
    isValid: function () {
        var a = this;
        if (a.rangeField.getValue() === "date") {
            return a.dateFromField.isValid() && a.dateToField.isValid()
        }
        return true
    },
    getValues: function (e, c, d, b) {
        var a = this.callParent(arguments);
        a.showHeader = !!a.showHeader;
        a.showFooter = !!a.showFooter;
        var f = this.resizePicker.getValues();
        if (!e) {
            a.cellSize = f
        } else {
            a += "&cellSize[0]=" + f[0] + "&cellSize[1]=" + f[1]
        }
        if (this.dialogConfig.showColumnPicker) {
            a.columns = this.columnPicker.getSelectedColumns()
        }
        return a
    },
    createFields: function () {
        var e = this, a = e.dialogConfig, g = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">', f = '<td><div class="sch-fieldcontainer-separator"></div></table>', b = [];
        e.rangeField = new Ext.form.field.ComboBox({
            value: a.exportConfig.range,
            triggerAction: "all",
            cls: "sch-export-dialog-range",
            forceSelection: true,
            editable: false,
            fieldLabel: a.rangeFieldLabel,
            name: "range",
            queryMode: "local",
            displayField: "name",
            valueField: "value",
            store: new Ext.data.Store({
                fields: ["name", "value"],
                data: [{name: a.completeViewText, value: "complete"}, {
                    name: a.dateRangeText,
                    value: "date"
                }, {name: a.currentViewText, value: "current"}]
            }),
            listeners: {change: e.onRangeChange, scope: e}
        });
        e.resizePicker = new Sch.widget.ResizePicker({dialogConfig: a, margin: "10 20"});
        e.resizerHolder = new Ext.form.FieldContainer({
            fieldLabel: a.scrollerDisabled ? a.adjustCols : a.adjustColsAndRows,
            labelAlign: "top",
            hidden: true,
            labelSeparator: "",
            beforeLabelTextTpl: g,
            afterLabelTextTpl: f,
            layout: "vbox",
            defaults: {flex: 1, allowBlank: false},
            items: [e.resizePicker]
        });
        e.dateFromField = new Ext.form.field.Date({
            fieldLabel: a.dateRangeFromText,
            baseBodyCls: "sch-exportdialogform-date",
            name: "dateFrom",
            format: a.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank: false,
            maxValue: a.endDate,
            minValue: a.startDate,
            value: a.startDate
        });
        e.dateToField = new Ext.form.field.Date({
            fieldLabel: a.dateRangeToText,
            name: "dateTo",
            format: a.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls: "sch-exportdialogform-date",
            allowBlank: false,
            maxValue: a.endDate,
            minValue: a.startDate,
            value: a.endDate
        });
        e.datesHolder = new Ext.form.FieldContainer({
            fieldLabel: a.specifyDateRange,
            labelAlign: "top",
            hidden: true,
            labelSeparator: "",
            beforeLabelTextTpl: g,
            afterLabelTextTpl: f,
            layout: "vbox",
            defaults: {flex: 1, allowBlank: false},
            items: [e.dateFromField, e.dateToField]
        });
        if (a.showColumnPicker) {
            e.columnPicker = new Sch.widget.ColumnPicker(Ext.apply({
                fieldLabel: a.columnPickerLabel,
                cls: "sch-export-dialog-columns",
                columns: a.scheduler.lockedGrid.query("gridcolumn")
            }, a.columnPickerConfig))
        }
        if (a.showHeaderField) {
            e.showHeaderField = new Ext.form.field.Checkbox({
                fieldLabel: e.dialogConfig.showHeaderLabel,
                cls: "sch-export-dialog-header",
                name: "showHeader",
                checked: !!a.exportConfig.showHeader,
                checkedValue: true,
                uncheckedValue: false
            })
        }
        if (a.showFooterField) {
            e.showFooterField = new Ext.form.field.Checkbox({
                fieldLabel: e.dialogConfig.showFooterLabel,
                cls: "sch-export-dialog-footer",
                name: "showFooter",
                checked: !!a.exportConfig.showFooter,
                checkedValue: true,
                uncheckedValue: false
            })
        }
        e.exportersField = new Ext.form.field.ComboBox({
            value: a.defaultExporter,
            triggerAction: "all",
            cls: "sch-export-dialog-exporter",
            forceSelection: true,
            editable: false,
            fieldLabel: a.exportersFieldLabel,
            name: "exporterId",
            queryMode: "local",
            displayField: "name",
            valueField: "value",
            store: {
                fields: ["name", "value"], data: Ext.Array.map(a.exporters, function (h) {
                    return {name: h.getName(), value: h.getExporterId()}
                })
            },
            listeners: {change: e.onExporterChange, scope: e}
        });
        e.formatField = new Ext.form.field.ComboBox({
            value: a.exportConfig.format,
            triggerAction: "all",
            forceSelection: true,
            editable: false,
            fieldLabel: a.formatFieldLabel,
            name: "format",
            queryMode: "local",
            store: a.pageFormats || ["A5", "A4", "A3", "Letter", "Legal"]
        });
        var d = a.exportConfig.orientation === "portrait" ? 'class="sch-none"' : "", c = a.exportConfig.orientation === "landscape" ? 'class="sch-none"' : "";
        e.orientationField = new Ext.form.field.ComboBox({
            value: a.exportConfig.orientation,
            triggerAction: "all",
            componentCls: "sch-exportdialogform-orientation",
            forceSelection: true,
            editable: false,
            fieldLabel: e.dialogConfig.orientationFieldLabel,
            afterSubTpl: new Ext.XTemplate('<span id="sch-exportdialog-imagePortrait" ' + c + '></span><span id="sch-exportdialog-imageLandscape" ' + d + "></span>"),
            name: "orientation",
            displayField: "name",
            valueField: "value",
            queryMode: "local",
            store: new Ext.data.Store({
                fields: ["name", "value"],
                data: [{name: a.orientationPortraitText, value: "portrait"}, {
                    name: a.orientationLandscapeText,
                    value: "landscape"
                }]
            }),
            listeners: {
                change: function (i, h) {
                    switch (h) {
                        case"landscape":
                            Ext.fly("sch-exportdialog-imagePortrait").toggleCls("sch-none");
                            Ext.fly("sch-exportdialog-imageLandscape").toggleCls("sch-none");
                            break;
                        case"portrait":
                            Ext.fly("sch-exportdialog-imagePortrait").toggleCls("sch-none");
                            Ext.fly("sch-exportdialog-imageLandscape").toggleCls("sch-none");
                            break
                    }
                }
            }
        });
        b.push(e.rangeField);
        b.push(e.resizerHolder);
        b.push(e.datesHolder);
        b.push(e.exportersField);
        b.push(e.formatField);
        b.push(e.orientationField);
        if (a.showColumnPicker) {
            b.push(e.columnPicker)
        }
        if (a.showHeaderField) {
            b.push(e.showHeaderField)
        }
        if (a.showFooterField) {
            b.push(e.showFooterField)
        }
        return b
    },
    createProgressBar: function () {
        return this.progressBar = new Ext.ProgressBar({
            text: this.config.progressBarText,
            animate: true,
            hidden: true,
            margin: "4px 0 10px 0"
        })
    },
    onRangeChange: function (b, a) {
        switch (a) {
            case"complete":
                this.datesHolder.hide();
                this.resizerHolder.hide();
                break;
            case"date":
                this.datesHolder.show();
                this.resizerHolder.hide();
                break;
            case"current":
                this.datesHolder.hide();
                this.resizerHolder.show();
                this.resizePicker.expand(true);
                break
        }
    },
    onExporterChange: function (b, a) {
        switch (a) {
            case"singlepage":
                this.disableFields(true);
                break;
            default:
                this.disableFields(false)
        }
    },
    disableFields: function (b) {
        var a = this;
        if (a.showHeaderField) {
            a.showHeaderField.setDisabled(b)
        }
        a.formatField.setDisabled(b);
        a.orientationField.setDisabled(b)
    },
    showProgressBar: function () {
        if (this.progressBar) {
            this.progressBar.show()
        }
    },
    hideProgressBar: function () {
        if (this.progressBar) {
            this.progressBar.hide()
        }
    },
    updateProgressBar: function (a, b) {
        if (this.progressBar) {
            this.progressBar.updateProgress(a);
            if (b) {
                this.progressBar.updateText(b)
            }
        }
    }
});
Ext.define("Sch.widget.ExportDialog", {
    alternateClassName: "Sch.widget.PdfExportDialog",
    extend: "Ext.window.Window",
    requires: ["Sch.widget.ExportDialogForm"],
    mixins: ["Sch.mixin.Localizable"],
    alias: "widget.exportdialog",
    modal: false,
    width: 350,
    cls: "sch-exportdialog",
    frame: false,
    layout: "fit",
    draggable: true,
    padding: 0,
    myConfig: null,
    plugin: null,
    buttonsPanel: null,
    buttonsPanelScope: null,
    progressBar: null,
    dateRangeFormat: "",
    showHeaderField: true,
    showFooterField: false,
    showColumnPicker: false,
    columnPickerConfig: undefined,
    constructor: function (a) {
        Ext.apply(this, a.exportDialogConfig);
        this.plugin = a.plugin;
        this.title = this.L("title");
        this.myConfig = Ext.apply({
            progressBarText: this.L("progressBarText"),
            dateRangeToText: this.L("dateRangeToText"),
            pickerText: this.L("pickerText"),
            dateRangeFromText: this.L("dateRangeFromText"),
            dateRangeText: this.L("dateRangeText"),
            currentViewText: this.L("currentViewText"),
            formatFieldLabel: this.L("formatFieldLabel"),
            orientationFieldLabel: this.L("orientationFieldLabel"),
            rangeFieldLabel: this.L("rangeFieldLabel"),
            showHeaderLabel: this.L("showHeaderLabel"),
            showFooterLabel: this.L("showFooterLabel"),
            exportersFieldLabel: this.L("exportersFieldLabel"),
            orientationPortraitText: this.L("orientationPortraitText"),
            orientationLandscapeText: this.L("orientationLandscapeText"),
            completeViewText: this.L("completeViewText"),
            adjustCols: this.L("adjustCols"),
            adjustColsAndRows: this.L("adjustColsAndRows"),
            specifyDateRange: this.L("specifyDateRange"),
            columnPickerLabel: this.L("columnPickerLabel"),
            dateRangeFormat: this.dateRangeFormat,
            exportConfig: this.exportConfig,
            showColumnPicker: this.showColumnPicker,
            columnPickerConfig: this.columnPickerConfig,
            showHeaderField: this.showHeaderField,
            showFooterField: this.showFooterField,
            pageFormats: this.getPageFormats(),
            scheduler: this.plugin && this.plugin.scheduler
        }, a.exportDialogConfig);
        this.callParent(arguments)
    },
    getPageFormats: function () {
        var b = this.plugin.pageSizes, d = [];
        Ext.Object.each(b, function (e, f) {
            d.push({width: f.width, height: f.height, name: e})
        });
        d.sort(function (f, e) {
            return f.width - e.width
        });
        var a = [];
        for (var c = 0; c < d.length; c++) {
            a.push(d[c].name)
        }
        return a
    },
    initComponent: function () {
        var b = this, a = {
            hidedialogwindow: b.destroy,
            showdialogerror: b.showError,
            updateprogressbar: function (c, d) {
                if (arguments.length == 2) {
                    b.fireEvent("updateprogressbar", c, undefined)
                } else {
                    b.fireEvent("updateprogressbar", c, d)
                }
            },
            scope: this
        };
        b.form = b.buildForm(b.myConfig);
        Ext.apply(this, {items: b.form, fbar: b.buildButtons(b.buttonsPanelScope || b)});
        b.callParent(arguments);
        b.plugin.on(a)
    },
    afterRender: function () {
        var a = this;
        a.relayEvents(a.form.resizePicker, ["change", "changecomplete", "select"]);
        a.form.relayEvents(a, ["updateprogressbar", "hideprogressbar", "showprogressbar"]);
        a.callParent(arguments)
    },
    buildButtons: function (a) {
        return [{
            xtype: "button", scale: "medium", text: this.L("exportButtonText"), handler: function () {
                if (this.form.isValid()) {
                    this.fireEvent("showprogressbar");
                    var c = this.form.getValues();
                    c.exporterId = c.exporterId;
                    var b = this.dateRangeFormat || Ext.Date.defaultFormat;
                    if (c.dateFrom && !Ext.isDate(c.dateFrom)) {
                        c.dateFrom = Ext.Date.parse(c.dateFrom, b)
                    }
                    if (c.dateTo && !Ext.isDate(c.dateTo)) {
                        c.dateTo = Ext.Date.parse(c.dateTo, b)
                    }
                    this.plugin.doExport(c)
                }
            }, scope: a
        }, {
            xtype: "button", scale: "medium", text: this.L("cancelButtonText"), handler: function () {
                this.destroy()
            }, scope: a
        }]
    },
    buildForm: function (a) {
        return new Sch.widget.ExportDialogForm({progressBar: this.progressBar, dialogConfig: a})
    },
    showError: function (b, a) {
        var c = b, d = a || c.L("generalError");
        c.fireEvent("hideprogressbar");
        Ext.Msg.alert("", d)
    }
});
Ext.define("Gnt.patches.TreeColumn", {
    extend: "Sch.util.Patch",
    requires: "Ext.tree.Column",
    target: "Ext.tree.Column",
    minVersion: "5.1.1",
    overrides: {
        initComponent: function () {
            var a = this;
            a._rendererScope = a.scope || a;
            a.callParent(arguments);
            a.rendererScope = a._rendererScope
        }
    }
});
Ext.define("Gnt.patches.TaskStore", {
    extend: "Ext.Mixin", onClassMixedIn: function (a) {
        if (Ext.getVersion().isGreaterThan("5.1.1")) {
            Ext.override(a, {
                onTasksLoad: function () {
                    if (!this._refreshCalled) {
                        this.onTasksLoaded()
                    }
                    this.un("refresh", this.onTaskStoreRefresh, this)
                }, onTasksBeforeLoad: function () {
                    this._refreshCalled = false;
                    this.on("refresh", this.onTaskStoreRefresh, this, {priority: 100})
                }, onTaskStoreRefresh: function () {
                    this._refreshCalled = true;
                    this.onTasksLoaded()
                }, setupListeners: function () {
                    this.callParent(arguments);
                    this.on("beforeload", this.onTasksBeforeLoad, this, {priority: 100});
                    this.un({load: this.onTasksLoaded, rootchanged: this.onTasksLoaded, scope: this});
                    this.on({load: this.onTasksLoad, rootchanged: this.onTasksLoad, scope: this})
                }
            })
        }
    }
});
Ext.define("Gnt.locale.En", {
    extend: "Sch.locale.Locale",
    requires: "Sch.locale.En",
    singleton: true,
    constructor: function (a) {
        Ext.apply(this, {
            l10n: {
                "Gnt.util.DurationParser": {
                    unitsRegex: {
                        MILLI: /^ms$|^mil/i,
                        SECOND: /^s$|^sec/i,
                        MINUTE: /^m$|^min/i,
                        HOUR: /^h$|^hr$|^hour/i,
                        DAY: /^d$|^day/i,
                        WEEK: /^w$|^wk|^week/i,
                        MONTH: /^mo|^mnt/i,
                        QUARTER: /^q$|^quar|^qrt/i,
                        YEAR: /^y$|^yr|^year/i
                    }
                },
                "Gnt.util.DependencyParser": {typeText: {SS: "SS", SF: "SF", FS: "FS", FF: "FF"}},
                "Gnt.field.ConstraintType": {none: "None"},
                "Gnt.field.Duration": {invalidText: "Invalid value"},
                "Gnt.field.Effort": {invalidText: "Invalid value"},
                "Gnt.field.Percent": {invalidText: "Invalid value"},
                "Gnt.field.SchedulingMode": {
                    Normal: "Normal",
                    FixedDuration: "Fixed duration",
                    EffortDriven: "Effort driven",
                    DynamicAssignment: "Dynamic assignment"
                },
                "Gnt.feature.DependencyDragDrop": {fromText: "From", toText: "To", startText: "Start", endText: "End"},
                "Gnt.Tooltip": {startText: "Starts: ", endText: "Ends: ", durationText: "Duration: "},
                "Gnt.plugin.TaskContextMenu": {
                    taskInformation: "Task information...",
                    projectInformation: "Project information...",
                    newTaskText: "New task",
                    deleteTask: "Delete task(s)",
                    editLeftLabel: "Edit left label",
                    editRightLabel: "Edit right label",
                    add: "Add...",
                    deleteDependency: "Delete dependency...",
                    addTaskAbove: "Task above",
                    addTaskBelow: "Task below",
                    addMilestone: "Milestone",
                    addSubtask: "Sub-task",
                    addSuccessor: "Successor",
                    addPredecessor: "Predecessor",
                    convertToMilestone: "Convert to milestone",
                    convertToRegular: "Convert to regular task",
                    splitTask: "Split task"
                },
                "Gnt.plugin.DependencyEditor": {
                    fromText: "From",
                    toText: "To",
                    typeText: "Type",
                    lagText: "Lag",
                    endToStartText: "Finish-To-Start",
                    startToStartText: "Start-To-Start",
                    endToEndText: "Finish-To-Finish",
                    startToEndText: "Start-To-Finish"
                },
                "Gnt.widget.calendar.Calendar": {
                    dayOverrideNameHeaderText: "Name",
                    overrideName: "Name",
                    startDate: "Start Date",
                    endDate: "End Date",
                    error: "Error",
                    dateText: "Date",
                    addText: "Add",
                    editText: "Edit",
                    removeText: "Remove",
                    workingDayText: "Working day",
                    weekendsText: "Weekends",
                    overriddenDayText: "Overridden day",
                    overriddenWeekText: "Overridden week",
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time",
                    dayOverridesText: "Day overrides",
                    weekOverridesText: "Week overrides",
                    okText: "OK",
                    cancelText: "Cancel",
                    parentCalendarText: "Parent calendar",
                    noParentText: "No parent",
                    selectParentText: "Select parent",
                    newDayName: "[Without name]",
                    calendarNameText: "Calendar name",
                    tplTexts: {
                        tplWorkingHours: "Working hours for",
                        tplIsNonWorking: "is non-working",
                        tplOverride: "override",
                        tplInCalendar: "in calendar",
                        tplDayInCalendar: "standard day in calendar",
                        tplBasedOn: "Based on"
                    },
                    overrideErrorText: "There is already an override for this day",
                    overrideDateError: "There is already a week override on this date: {0}",
                    startAfterEndError: "Start date should be less than end date",
                    weeksIntersectError: "Week overrides should not intersect"
                },
                "Gnt.widget.calendar.AvailabilityGrid": {
                    startText: "Start",
                    endText: "End",
                    addText: "Add",
                    removeText: "Remove",
                    error: "Error"
                },
                "Gnt.widget.calendar.DayEditor": {
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time"
                },
                "Gnt.widget.calendar.WeekEditor": {
                    defaultTimeText: "Default time",
                    workingTimeText: "Working time",
                    nonworkingTimeText: "Non-working time",
                    error: "Error",
                    noOverrideError: "Week override contains only 'default' days - can't save it"
                },
                "Gnt.widget.calendar.ResourceCalendarGrid": {name: "Name", calendar: "Calendar"},
                "Gnt.widget.calendar.CalendarWindow": {ok: "Ok", cancel: "Cancel"},
                "Gnt.widget.calendar.CalendarManager": {
                    addText: "Add",
                    removeText: "Remove",
                    add_child: "Add child",
                    add_node: "Add calendar",
                    add_sibling: "Add sibling",
                    remove: "Remove",
                    calendarName: "Calendar",
                    confirm_action: "Confirm action",
                    confirm_message: "Calendar has unsaved changes. Would you like to save your changes?"
                },
                "Gnt.widget.calendar.CalendarManagerWindow": {
                    title: "Calendar manager",
                    ok: "Apply changes",
                    cancel: "Close",
                    confirm_action: "Confirm action",
                    confirm_message: "Calendar has unsaved changes. Would you like to save your changes?"
                },
                "Gnt.field.Assignment": {cancelText: "Cancel", closeText: "Save and Close"},
                "Gnt.column.AssignmentUnits": {text: "Units"},
                "Gnt.column.Duration": {text: "Duration"},
                "Gnt.column.Effort": {text: "Effort"},
                "Gnt.column.EndDate": {text: "Finish"},
                "Gnt.column.PercentDone": {text: "% Done"},
                "Gnt.column.ResourceAssignment": {text: "Assigned Resources"},
                "Gnt.column.ResourceName": {text: "Resource Name"},
                "Gnt.column.Rollup": {text: "Rollup task", no: "No", yes: "Yes"},
                "Gnt.field.ManuallyScheduled": {yes: "Yes", no: "No"},
                "Gnt.field.ReadOnly": {yes: "Yes", no: "No"},
                "Gnt.column.ManuallyScheduled": {text: "Manual mode"},
                "Gnt.column.SchedulingMode": {text: "Mode"},
                "Gnt.column.Predecessor": {text: "Predecessors"},
                "Gnt.column.Successor": {text: "Successors"},
                "Gnt.column.StartDate": {text: "Start"},
                "Gnt.column.WBS": {text: "WBS"},
                "Gnt.column.Sequence": {text: "#"},
                "Gnt.column.Calendar": {text: "Calendar"},
                "Gnt.widget.taskeditor.ProjectForm": {
                    projectText: "Project",
                    nameText: "Name",
                    datesText: "Dates",
                    startText: "Start",
                    finishText: "Finish",
                    calendarText: "Calendar",
                    readOnlyText: "Readonly",
                    allowDependenciesText: "Allow cross-project dependencies"
                },
                "Gnt.widget.taskeditor.TaskForm": {
                    taskNameText: "Name",
                    durationText: "Duration",
                    datesText: "Dates",
                    baselineText: "Baseline",
                    startText: "Start",
                    finishText: "Finish",
                    percentDoneText: "Percent Complete",
                    baselineStartText: "Start",
                    baselineFinishText: "Finish",
                    baselinePercentDoneText: "Percent Complete",
                    effortText: "Effort",
                    invalidEffortText: "Invalid effort value",
                    calendarText: "Calendar",
                    manuallyScheduledText: "Manually Scheduled",
                    schedulingModeText: "Scheduling Mode",
                    rollupText: "Rollup",
                    wbsCodeText: "WBS code",
                    "Constraint Type": "Constraint Type",
                    "Constraint Date": "Constraint Date"
                },
                "Gnt.widget.DependencyGrid": {
                    idText: "ID",
                    snText: "SN",
                    taskText: "Task Name",
                    blankTaskText: "Please select task",
                    invalidDependencyText: "Invalid dependency",
                    parentChildDependencyText: "Dependency between child and parent found",
                    duplicatingDependencyText: "Duplicate dependency found",
                    transitiveDependencyText: "Transitive dependency",
                    cyclicDependencyText: "Cyclic dependency",
                    typeText: "Type",
                    lagText: "Lag",
                    clsText: "CSS class",
                    endToStartText: "Finish-To-Start",
                    startToStartText: "Start-To-Start",
                    endToEndText: "Finish-To-Finish",
                    startToEndText: "Start-To-Finish"
                },
                "Gnt.widget.AssignmentEditGrid": {
                    confirmAddResourceTitle: "Confirm",
                    confirmAddResourceText: "Resource &quot;{0}&quot; not found in list. Would you like to add it?",
                    noValueText: "Please select resource to assign",
                    noResourceText: "No resource &quot;{0}&quot; found in the list"
                },
                "Gnt.widget.taskeditor.ProjectEditor": {generalText: "General", descriptionText: "Description"},
                "Gnt.widget.taskeditor.TaskEditor": {
                    generalText: "General",
                    resourcesText: "Resources",
                    dependencyText: "Predecessors",
                    addDependencyText: "Add new",
                    dropDependencyText: "Remove",
                    notesText: "Notes",
                    advancedText: "Advanced",
                    addAssignmentText: "Add new",
                    dropAssignmentText: "Remove"
                },
                "Gnt.plugin.taskeditor.BaseEditor": {
                    title: "Task Information",
                    alertCaption: "Information",
                    alertText: "Please correct marked errors to save changes",
                    okText: "Ok",
                    cancelText: "Cancel"
                },
                "Gnt.plugin.taskeditor.ProjectEditor": {title: "Project Information"},
                "Gnt.field.EndDate": {endBeforeStartText: "End date is before start date"},
                "Gnt.column.Note": {text: "Note"},
                "Gnt.column.AddNew": {text: "Add new column..."},
                "Gnt.column.EarlyStartDate": {text: "Early Start"},
                "Gnt.column.EarlyEndDate": {text: "Early Finish"},
                "Gnt.column.LateStartDate": {text: "Late Start"},
                "Gnt.column.LateEndDate": {text: "Late Finish"},
                "Gnt.field.Calendar": {calendarNotApplicable: "Task calendar has no overlapping with assigned resources calendars"},
                "Gnt.column.Slack": {text: "Slack"},
                "Gnt.column.Name": {text: "Task Name"},
                "Gnt.column.BaselineStartDate": {text: "Baseline Start Date"},
                "Gnt.column.BaselineEndDate": {text: "Baseline End Date"},
                "Gnt.column.Milestone": {text: "Milestone"},
                "Gnt.field.Milestone": {yes: "Yes", no: "No"},
                "Gnt.field.Dependency": {
                    invalidFormatText: "Invalid dependency format",
                    invalidDependencyText: "Invalid dependency found, please make sure you have no cyclic paths between your tasks",
                    invalidDependencyType: "Invalid dependency type {0}. Allowed values are: {1}."
                },
                "Gnt.constraint.Base": {
                    name: "A constraint",
                    "Remove the constraint": "Remove the constraint",
                    "Cancel the change and do nothing": "Cancel the change and do nothing"
                },
                "Gnt.constraint.FinishNoEarlierThan": {
                    name: "Finish no earlier than",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.FinishNoLaterThan": {
                    name: "Finish no later than",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.MustFinishOn": {
                    name: "Must finish on",
                    "Move the task to finish on {0}": "Move the task to finish on {0}"
                },
                "Gnt.constraint.MustStartOn": {
                    name: "Must start on",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.constraint.StartNoEarlierThan": {
                    name: "Start no earlier than",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.constraint.StartNoLaterThan": {
                    name: "Start no later than",
                    "Move the task to start at {0}": "Move the task to start at {0}"
                },
                "Gnt.column.ConstraintDate": {text: "Constraint date"},
                "Gnt.column.ConstraintType": {text: "Constraint"},
                "Gnt.widget.ConstraintResolutionForm": {
                    dateFormat: "m/d/Y",
                    OK: "OK",
                    Cancel: "Cancel",
                    "Resolution options": "Resolution options",
                    "Don't ask again": "Don't ask again",
                    "Task {0} violates constraint {1}": 'Task "{0}" violates constraint {1}',
                    "Task {0} violates constraint {1} {2}": 'Task "{0}" violates constraint {1} {2}'
                },
                "Gnt.widget.ConstraintResolutionWindow": {"Constraint violation": "Constraint violation"},
                "Gnt.panel.ResourceHistogram": {resourceText: "Resource"}
            }
        });
        this.callParent(arguments)
    }
});
Ext.define("Gnt.mixin.Localizable", {extend: "Sch.mixin.Localizable", requires: ["Gnt.locale.En"]});
Ext.define("Gnt.constraint.Base", {
    mixins: ["Gnt.mixin.Localizable"], isSatisfied: function (b, c, a) {
        throw"Abstract method"
    }, getResolution: function (f, a, b) {
        var e = this, d = false;
        b = b || a.getConstraintDate();
        var c = function () {
            if (!d) {
                d = true;
                f.apply(this, arguments)
            }
        };
        return {
            title: e.L("name"),
            task: a,
            date: b,
            resolutions: this.getResolutionOptions(c, a, b),
            getCancelActionOption: function () {
                return this.resolutions[0]
            },
            cancelAction: function () {
                return this.getCancelActionOption().resolve()
            },
            proceedAction: function () {
                c()
            },
            getResolution: function (g) {
                return Ext.Array.findBy(this.resolutions, function (h) {
                    return h.id == g
                })
            }
        }
    }, getResolutionOptions: function (d, b, c, a) {
        return [{
            id: "cancel", title: this.L("Cancel the change and do nothing"), resolve: function () {
                d(true)
            }
        }]
    }, hasThisConstraintApplied: function (a) {
        return a.getConstraintClass() === this
    }, getInitialConstraintDate: function (a) {
        return a.getConstraintDate()
    }, getDisplayableConstraintDateForFormat: function (b, c, a) {
        return b
    }, adjustConstraintDateFromDisplayableWithFormat: function (b, c, a) {
        return b
    }, shiftToNearestValidConstraintDate: function (b, c, a) {
        return b
    }, statics: {
        getConstraintClass: function (b) {
            var a = !Ext.isEmpty(b) && Ext.ClassManager.getByAlias("gntconstraint." + b);
            return a || null
        }
    }
});
Ext.define("Gnt.constraint.StartNoEarlierThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.startnoearlierthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return !d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) !== -1)
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to start at {0}"), resolve: function () {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.StartNoLaterThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.startnolaterthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return !d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) !== 1)
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to start at {0}"), resolve: function () {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.FinishNoEarlierThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.finishnoearlierthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (a, b) {
        var c = a.getEndDate();
        b = b || a.getConstraintDate();
        return !b || !c || c >= b
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to finish on {0}"), resolve: function () {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.constraint.FinishNoLaterThan", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.finishnolaterthan",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (b, c, a) {
        var d = b.getEndDate();
        c = c || b.getConstraintDate();
        return !c || !d || (Sch.util.Date.compareWithPrecision(d, c, a) !== 1)
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to finish on {0}"), resolve: function () {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.constraint.MustStartOn", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.muststarton",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (c, d, b) {
        var a = c.getStartDate();
        d = d || c.getConstraintDate();
        return !d || !a || (Sch.util.Date.compareWithPrecision(a, d, b) === 0)
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        this.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to start at {0}"), resolve: function () {
                c.setStartDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getStartDate()
    }
});
Ext.define("Gnt.constraint.MustFinishOn", {
    extend: "Gnt.constraint.Base",
    alias: "gntconstraint.mustfinishon",
    singleton: true,
    requires: ["Sch.util.Date"],
    isSatisfied: function (b, c, a) {
        var d = b.getEndDate();
        c = c || b.getConstraintDate();
        return !c || !d || (Sch.util.Date.compareWithPrecision(d, c, a) === 0)
    },
    getResolutionOptions: function (f, c, d, b) {
        var e = this, a = e.callParent(arguments);
        d = d || c.getConstraintDate();
        e.hasThisConstraintApplied(c) && a.push({
            id: "remove-constraint",
            title: e.L("Remove the constraint"),
            resolve: function () {
                c.setConstraintType("");
                f()
            }
        });
        a.push({
            id: "move-task", title: e.L("Move the task to finish on {0}"), resolve: function () {
                c.setEndDateWithoutPropagation(d, true);
                f()
            }
        });
        return a
    },
    getInitialConstraintDate: function (a) {
        return a.getEndDate()
    },
    getDisplayableConstraintDateForFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, -1)
        }
        return b
    },
    adjustConstraintDateFromDisplayableWithFormat: function (b, c, a) {
        if (b && !Ext.Date.formatContainsHourInfo(c) && (b - Ext.Date.clearTime(b, true) === 0)) {
            b = Sch.util.Date.add(b, Sch.util.Date.DAY, 1)
        }
        return b
    }
});
Ext.define("Gnt.model.mixin.ProjectableModel", function () {
    var e = {};

    function c() {
        Ext.override(this, e)
    }

    function a(g) {
        return this.data[g]
    }

    function d() {
        var i = this, h = i.getTreeStore && i.getTreeStore() || i.store, g = h && h.getProjection && h.getProjection();
        return g && g.hasOwnProperty(i.internalId) ? true : false
    }

    e.get = function b(m) {
        var j = this, i = j.getTreeStore && j.getTreeStore() || j.store, g = i && i.getProjection && i.getProjection(), h = j.internalId, l, k;
        if (g && g.hasOwnProperty(h)) {
            l = g[h];
            if (m in l) {
                k = l[m]
            } else {
                k = j.callParent([m])
            }
        } else {
            k = j.callParent([m])
        }
        return k
    };
    e.set = function f(q, n) {
        var m = this, o = m.getTreeStore && m.getTreeStore() || m.store, j = o && o.getProjection && o.getProjection(), k = m.internalId, i, g, r, p, h, l;
        if (j) {
            r = [];
            if (arguments.length == 1) {
                for (g in q) {
                    if (q.hasOwnProperty(g)) {
                        n = q[g];
                        p = m.get(g);
                        l = (n !== undefined && n !== null) ? (n).valueOf() : n;
                        h = (p !== undefined && p !== null) ? (p).valueOf() : p;
                        if (((l === undefined || l === null) && l !== h) || l != h) {
                            i = j[k] = j.hasOwnProperty(k) && j[k] || {};
                            i[g] = n;
                            r.push(g)
                        }
                    }
                }
            } else {
                if (arguments.length > 1) {
                    p = m.get(q);
                    l = (n !== undefined && n !== null) ? (n).valueOf() : n;
                    h = (p !== undefined && p !== null) ? (p).valueOf() : p;
                    if (((l === undefined || l === null) && l !== h) || l != h) {
                        i = j[k] = j.hasOwnProperty(k) && j[k] || {};
                        i[q] = n;
                        r.push(q)
                    }
                }
            }
        } else {
            r = m.callParent(arguments)
        }
        return r
    };
    return {initProjectable: c, getUnprojected: a, isProjected: d}
});
Ext.define("Gnt.data.mixin.ProjectableStore", function () {
    function b(h, i) {
        return h.byInternalIdMap && h.byInternalIdMap[i] || h.getByInternalId(i)
    }

    function d() {
        var i = this, h = i.projectionStack;
        return h && h[h.length - 1]
    }

    function c() {
        var i = this, h = i.projectionStack;
        return h && h.length || 0
    }

    function g(k) {
        var l, h, j;
        k = [].concat(k);
        for (j = false, l = 0, h = k.length; !j && l < h; l++) {
            j = k[l].isProjected()
        }
        return j
    }

    function a() {
        var j = this, i = j.projectionStack, k, h;
        if (!i) {
            j.projectionStack = [{}]
        } else {
            h = i[i.length - 1];
            k = {};
            Ext.Object.each(h, function (n, m) {
                var l = function () {
                };
                l.prototype = m;
                k[n] = new l()
            });
            i.push(k)
        }
    }

    function e() {
        var p = this, i = p.projectionStack, m, l, h, j, n, o, k;
        if (i.length === 1) {
            l = i[0];
            p.projectionStack = null;
            for (o in l) {
                if (l.hasOwnProperty(o)) {
                    k = b(p, o);
                    if (k) {
                        j = l[o];
                        n = false;
                        for (h in j) {
                            if (j.hasOwnProperty(h)) {
                                n = true;
                                break
                            }
                        }
                        n && k.set(j)
                    }
                }
            }
        } else {
            l = i.pop();
            m = i[i.length - 1];
            for (o in l) {
                if (l.hasOwnProperty(o)) {
                    if (!m.hasOwnProperty(o)) {
                        m[o] = l[o]
                    } else {
                        m[o] = Ext.apply(m[o], l[o])
                    }
                }
            }
        }
        this.fireEvent("projectioncommit", this, i && i[i.length - 1], l)
    }

    function f() {
        var j = this, i = j.projectionStack, h = i.pop();
        if (i.length === 0) {
            j.projectionStack = null
        }
        this.fireEvent("projectionreject", this, i && i[i.length - 1], h)
    }

    return {
        projectionStack: null,
        getProjection: d,
        areProjected: g,
        getProjectionLevel: c,
        startProjection: a,
        commitProjection: e,
        rejectProjection: f
    }
});
Ext.define("Gnt.model.Calendar", {
    extend: "Sch.model.Customizable",
    requires: ["Ext.data.NodeInterface"],
    idProperty: "Id",
    calendar: null,
    nameField: "Name",
    daysPerMonthField: "DaysPerMonth",
    daysPerWeekField: "DaysPerWeek",
    hoursPerDayField: "HoursPerDay",
    weekendsAreWorkdaysField: "WeekendsAreWorkdays",
    weekendFirstDayField: "WeekendFirstDay",
    weekendSecondDayField: "WeekendSecondDay",
    defaultAvailabilityField: "DefaultAvailability",
    daysField: "Days",
    calendarClassField: "CalendarClass",
    phantomIdField: "PhantomId",
    phantomParentIdField: "PhantomParentId",
    customizableFields: [{name: "Name"}, {name: "DaysPerMonth", type: "integer"}, {
        name: "DaysPerWeek",
        type: "integer"
    }, {name: "HoursPerDay", type: "integer"}, {name: "WeekendsAreWorkdays", type: "boolean"}, {
        name: "WeekendFirstDay",
        type: "integer"
    }, {
        name: "WeekendSecondDay",
        type: "integer"
    }, {name: "DefaultAvailability"}, {name: "Days"}, {
        name: "CalendarClass",
        defaultValue: "Gnt.data.Calendar"
    }, {name: "PhantomId"}, {name: "PhantomParentId"}],
    constructor: function (b, e, c) {
        var a = b || c || {};
        var d = a.calendar || a.Days;
        b && delete b.calendar;
        c && delete c.calendar;
        this.callParent(arguments);
        this.setDays(d);
        this.data[this.phantomIdField] = this.getId()
    },
    get: function (a) {
        if (a === "Days") {
            return this.getCalendar() || this.data[this.daysField]
        } else {
            return this.callParent(arguments)
        }
    },
    set: function (b, a) {
        if (b === "Days") {
            if (a instanceof Gnt.data.Calendar) {
                this.setCalendar(a)
            } else {
                this.data[this.daysField] = a
            }
        } else {
            return this.callParent(arguments)
        }
    },
    getCalendar: function () {
        return this.calendar
    },
    setCalendar: function (a) {
        this.calendar = a
    },
    getCalendarConfig: function () {
        return {
            calendarId: this.getId(),
            daysPerMonth: this.getDaysPerMonth(),
            daysPerWeek: this.getDaysPerWeek(),
            defaultAvailability: this.getDefaultAvailability(),
            hoursPerDay: this.getHoursPerDay(),
            name: this.getName(),
            parent: this.parentNode && this.parentNode.getCalendar(),
            weekendFirstDay: this.getWeekendFirstDay(),
            weekendSecondDay: this.getWeekendSecondDay(),
            weekendsAreWorkdays: this.getWeekendsAreWorkdays()
        }
    },
    getModelConfig: function (c, b) {
        var a = {};
        if (!b) {
            a.parentId = c.parent && c.parent.calendarId;
            a.calendar = c
        }
        a[this.daysPerMonthField] = c.daysPerMonth;
        a[this.daysPerWeekField] = c.daysPerWeek;
        a[this.defaultAvailabilityField] = c.defaultAvailability;
        a[this.hoursPerDayField] = c.hoursPerDay;
        a[this.nameField] = c.name;
        a[this.weekendFirstDayField] = c.weekendFirstDay;
        a[this.weekendSecondDayField] = c.weekendSecondDay;
        a[this.weekendsAreWorkdaysField] = c.weekendsAreWorkdays;
        a[this.calendarClassField] = Ext.getClassName(c);
        return a
    },
    setCalendarManager: function (a) {
        this.calendarManager = a
    },
    getCalendarManager: function () {
        return this.calendarManager
    },
    getParentCalendarClass: function () {
        var b = this.parentNode, a;
        while (b && !a) {
            a = b.getCalendarClass();
            b = b.parentNode
        }
        return a
    },
    fillNodeFromPrototype: function (d) {
        var a = d[this.calendarClassField] || this.treeStore && this.treeStore.getCalendarClass() || this.getCalendarClass() || this.getParentCalendarClass() || this.getField(this.calendarClassField).getDefaultValue();
        if (a) {
            Ext.applyIf(d, this.getModelConfig(Ext.ClassManager.get(a).prototype, true));
            var c = d.children;
            if (c && c.length) {
                for (var b = 0; b < c.length; b++) {
                    this.fillNodeFromPrototype(c[b])
                }
            }
        }
    },
    prepareCalendarNode: function (a) {
        if (a instanceof Gnt.data.Calendar) {
            a = this.getModelConfig(a)
        } else {
            if (Ext.isObject(a)) {
                this.fillNodeFromPrototype(a)
            }
        }
        a = this.createNode(a);
        if (this.phantom) {
            if (this.getId() !== a.data[this.phantomParentIdField]) {
                a.modified = a.modified || {};
                a.modified[this.phantomParentIdField] = a.data[this.phantomParentIdField];
                a.data[this.phantomParentIdField] = this.getId()
            }
        }
        return a
    }
}, function () {
    Ext.data.NodeInterface.decorate(this);
    this.override({
        insertBefore: function (a) {
            a = this.prepareCalendarNode(a);
            return this.callParent(arguments)
        }, appendChild: function (b) {
            if (b instanceof Array) {
                for (var a = 0; a < b.length; a++) {
                    b[a] = this.prepareCalendarNode(b[a])
                }
            } else {
                b = this.prepareCalendarNode(b)
            }
            return this.callParent(arguments)
        }
    })
});
Ext.define("Gnt.model.CalendarDay", {
    requires: ["Ext.data.Types"],
    extend: "Sch.model.Customizable",
    idProperty: "Id",
    customizableFields: [{
        name: "Date", type: "date", dateFormat: "c", persist: true, convert: function (b, a) {
            if (!b) {
                return
            }
            var c = Ext.data.Types.DATE.convert.call(this, b);
            if (c) {
                Ext.Date.clearTime(c)
            }
            return c
        }
    }, {name: "Weekday", type: "int"}, {
        name: "OverrideStartDate",
        type: "date",
        dateFormat: "c"
    }, {name: "OverrideEndDate", type: "date", dateFormat: "c"}, {
        name: "Type",
        defaultValue: "DAY"
    }, {name: "IsWorkingDay", type: "boolean", defaultValue: false}, {
        name: "Cls",
        defaultValue: "gnt-holiday"
    }, "Name", {
        name: "Availability", persist: true, convert: function (b, a) {
            if (b) {
                return Ext.typeOf(b) === "string" ? [b] : b
            } else {
                return []
            }
        }
    }],
    availabilityCache: null,
    weekDayField: "Weekday",
    overrideStartDateField: "OverrideStartDate",
    overrideEndDateField: "OverrideEndDate",
    typeField: "Type",
    dateField: "Date",
    isWorkingDayField: "IsWorkingDay",
    clsField: "Cls",
    nameField: "Name",
    availabilityField: "Availability",
    setDate: function (a) {
        if (a) {
            a = Ext.Date.clearTime(a, true)
        }
        this.set(this.dateField, a)
    },
    clearDate: function () {
        this.set(this.dateField, null)
    },
    getAvailability: function (b) {
        var c = this;
        if (b) {
            return this.get(this.availabilityField)
        }
        if (this.availabilityCache) {
            return this.availabilityCache
        }
        var a = [];
        Ext.Array.each(this.get(this.availabilityField), function (d) {
            a.push(Ext.typeOf(d) === "string" ? c.parseInterval(d) : d)
        });
        this.verifyAvailability(a);
        return this.availabilityCache = a
    },
    setAvailability: function (a) {
        this.availabilityCache = null;
        this.set(this.availabilityField, this.stringifyIntervals(a));
        this.getAvailability()
    },
    verifyAvailability: function (b) {
        b.sort(function (f, e) {
            return f.startTime - e.startTime
        });
        Ext.Array.each(b, function (e) {
            if (e.startTime > e.endTime) {
                throw new Error("Start time " + Ext.Date.format(e.startTime, "H:i") + " is greater than end time " + Ext.Date.format(e.endTime, "H:i"))
            }
        });
        for (var a = 1; a < b.length; a++) {
            var c = b[a - 1];
            var d = b[a];
            if (c.endTime > d.startTime) {
                throw new Error("Availability intervals should not intersect: [" + this.stringifyInterval(c) + "] and [" + this.stringifyInterval(d) + "]")
            }
        }
    },
    prependZero: function (a) {
        return a < 10 ? "0" + a : a
    },
    stringifyInterval: function (b) {
        var c = b.startTime;
        var a = b.endTime;
        return this.prependZero(c.getHours()) + ":" + this.prependZero(c.getMinutes()) + "-" + (a.getDate() == 1 ? 24 : this.prependZero(a.getHours())) + ":" + this.prependZero(a.getMinutes())
    },
    stringifyIntervals: function (b) {
        var c = this;
        var a = [];
        Ext.Array.each(b, function (d) {
            if (Ext.typeOf(d) === "string") {
                a.push(d)
            } else {
                a.push(c.stringifyInterval(d))
            }
        });
        return a
    },
    parseInterval: function (b) {
        var a = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(b);
        if (!a) {
            throw"Invalid format for availability string: " + b + ". It should have exact format: hh:mm-hh:mm"
        }
        return {startTime: new Date(0, 0, 0, a[1], a[2]), endTime: new Date(0, 0, 0, a[3], a[4])}
    },
    getTotalHours: function () {
        return this.getTotalMS() / 1000 / 60 / 60
    },
    getTotalMS: function () {
        var a = 0;
        Ext.Array.each(this.getAvailability(), function (b) {
            a += b.endTime - b.startTime
        });
        return a
    },
    addAvailabilityInterval: function (d, b) {
        var a;
        if (d instanceof Date) {
            a = {startTime: d, endTime: b}
        } else {
            a = this.parseInterval(d + (b ? "-" + b : ""))
        }
        var c = this.getAvailability().concat(a);
        this.verifyAvailability(c);
        this.setAvailability(c)
    },
    removeAvailbilityInterval: function (a) {
        var b = this.getAvailability();
        b.splice(a, 1);
        this.setAvailability(b)
    },
    getAvailabilityIntervalsFor: function (d) {
        d = typeof d == "number" ? new Date(d) : d;
        var c = d.getFullYear();
        var e = d.getMonth();
        var b = d.getDate();
        var a = [];
        Ext.Array.each(this.getAvailability(), function (f) {
            var g = f.endTime.getDate();
            a.push({
                startDate: new Date(c, e, b, f.startTime.getHours(), f.startTime.getMinutes()),
                endDate: new Date(c, e, b + (g == 1 ? 1 : 0), f.endTime.getHours(), f.endTime.getMinutes())
            })
        });
        return a
    },
    getAvailabilityStartFor: function (b) {
        var a = this.getAvailabilityIntervalsFor(b);
        if (!a.length) {
            return null
        }
        return a[0].startDate
    },
    getAvailabilityEndFor: function (b) {
        var a = this.getAvailabilityIntervalsFor(b);
        if (!a.length) {
            return null
        }
        return a[a.length - 1].endDate
    }
});
Ext.define("Gnt.model.Week", {
    extend: "Ext.data.Model",
    idProperty: "Id",
    fields: [{name: "Id"}, {name: "name", type: "string"}, {name: "startDate", type: "date"}, {
        name: "endDate",
        type: "date"
    }, {name: "mainDay"}, {name: "weekAvailability"}],
    set: function (b, a) {
        if (b == "name") {
            Ext.Array.each(this.get("weekAvailability").concat(this.get("mainDay")), function (c) {
                if (c) {
                    c.setName(a)
                }
            })
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.model.Assignment", {
    extend: "Sch.model.Assignment",
    customizableFields: [{name: "TaskId"}, {name: "Units", type: "float", defaultValue: 100}],
    taskIdField: "TaskId",
    eventIdField: "TaskId",
    constructor: function (b, c) {
        var a = this;
        a.eventIdField = a.taskIdField;
        a.callParent([b, c])
    },
    getEventId: function () {
        var a = this;
        return a.get(a.taskIdField)
    },
    setEventId: function (a) {
        var b = this;
        return b.set(b.taskIdField, a)
    },
    unitsField: "Units",
    getTaskStore: function () {
        return this.joined && this.joined.length > 0 && this.joined[0].getTaskStore() || null
    },
    getEventStore: function () {
        return this.getTaskStore()
    },
    getUnits: function () {
        var a = this;
        return Math.max(0, a.get(a.unitsField))
    },
    setUnits: function (b) {
        var a = this;
        a.set(a.unitsField, b)
    },
    getTask: function (a) {
        var b = this;
        return b.getEvent(a)
    },
    getTaskName: function (b) {
        var a = this.getTask(b);
        return a && a.getName() || ""
    },
    getEffort: function (c) {
        var b = this, a = b.getTask(), d = 0;
        a.forEachAvailabilityIntervalWithResources({
            startDate: a.getStartDate(),
            endDate: a.getEndDate(),
            resources: [b.getResource()]
        }, function (h, g, f) {
            var e, j;
            for (e in f) {
                j = f[e].units
            }
            d += (g - h) * j / 100
        });
        return a.getProjectCalendar().convertMSDurationToUnit(d, c || a.getEffortUnit())
    }
});
Ext.define("Gnt.model.AssignmentEditing", {extend: "Gnt.model.Assignment", fields: ["ResourceName"]});
Ext.define("Gnt.model.Dependency", {
    extend: "Sch.model.Customizable",
    inheritableStatics: {Type: {StartToStart: 0, StartToEnd: 1, EndToStart: 2, EndToEnd: 3}},
    idProperty: "Id",
    customizableFields: [{name: "From"}, {name: "To"}, {name: "Type", type: "int", defaultValue: 2}, {
        name: "Lag",
        type: "number",
        defaultValue: 0
    }, {
        name: "LagUnit", type: "string", defaultValue: "d", convert: function (a) {
            return a || "d"
        }
    }, {name: "Cls", defaultValue: ""}],
    fromField: "From",
    toField: "To",
    typeField: "Type",
    lagField: "Lag",
    lagUnitField: "LagUnit",
    clsField: "Cls",
    isHighlighted: false,
    constructor: function (a) {
        this.callParent(arguments);
        if (a) {
            if (a[this.fromField] && a[this.fromField]instanceof Gnt.model.Task) {
                this.setSourceTask(a[this.fromField]);
                delete a.fromField
            }
            if (a[this.toField] && a[this.toField]instanceof Gnt.model.Task) {
                this.setTargetTask(a[this.toField]);
                delete a.toField
            }
        }
    },
    getTaskStore: function () {
        return this.joined[0].taskStore
    },
    getSourceTask: function (a) {
        return (a || this.getTaskStore()).getModelById(this.getSourceId())
    },
    setSourceTask: function (a) {
        this.setSourceId(a.getId() || a.internalId)
    },
    getTargetTask: function (a) {
        return (a || this.getTaskStore()).getModelById(this.getTargetId())
    },
    setTargetTask: function (a) {
        this.setTargetId(a.getId() || a.internalId)
    },
    getSourceId: function () {
        return this.get(this.fromField)
    },
    setSourceId: function (a) {
        this.set(this.fromField, a)
    },
    getTargetId: function () {
        return this.get(this.toField)
    },
    setTargetId: function (a) {
        this.set(this.toField, a)
    },
    getLagUnit: function () {
        return this.get(this.lagUnitField) || "d"
    },
    isPersistable: function () {
        var a = this.getSourceTask(), b = this.getTargetTask();
        return a && !a.phantom && b && !b.phantom
    },
    isValid: function (b) {
        var d = this.callParent(arguments), e = this.getSourceId(), a = this.getTargetId(), c = this.getType();
        if (d) {
            d = Ext.isNumber(c) && !Ext.isEmpty(e) && !Ext.isEmpty(a) && e != a
        }
        if (d && b !== false && this.joined && this.joined[0]) {
            d = this.joined[0].isValidDependency(e, a, c, null, null, this)
        }
        return d
    }
});
Ext.define("Gnt.model.Resource", {
    extend: "Sch.model.Resource",
    customizableFields: ["CalendarId"],
    calendarIdField: "CalendarId",
    normalized: false,
    calendarWaitingListener: null,
    getTaskStore: function () {
        return this.joined[0].getTaskStore()
    },
    getEventStore: function () {
        return this.getTaskStore()
    },
    getTasks: function () {
        return this.getEvents()
    },
    getCalendar: function (a) {
        var b = this;
        return a ? b.getOwnCalendar() : b.getOwnCalendar() || b.getProjectCalendar()
    },
    getOwnCalendar: function () {
        var a = this.getCalendarId();
        return a ? Gnt.data.Calendar.getCalendar(a) : null
    },
    getProjectCalendar: function () {
        return this.getTaskStore().getCalendar()
    },
    setCalendar: function (b) {
        var a = b instanceof Gnt.data.Calendar;
        if (a && !b.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property")
        }
        this.setCalendarId(a ? b.calendarId : b)
    },
    setCalendarId: function (c, d) {
        if (c instanceof Gnt.data.Calendar) {
            c = c.calendarId
        }
        var b = this.getCalendarId();
        if (b != c || d) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null
            }
            var a = {calendarchange: this.onCalendarChange, scope: this};
            var f = this.calendar || Gnt.data.Calendar.getCalendar(b);
            this.calendar = null;
            f && f.un(a);
            this.set(this.calendarIdField, c);
            var e = Gnt.data.Calendar.getCalendar(c);
            if (e) {
                e.on(a);
                if (!d) {
                    this.onCalendarChange()
                }
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on("add", function (g, i, h) {
                    e = Gnt.data.Calendar.getCalendar(c);
                    if (e) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        e.on(a);
                        this.onCalendarChange()
                    }
                }, this, {destroyable: true})
            }
        }
    },
    onCalendarChange: function () {
        this.inOnCalendarChange = true;
        this.adjustToCalendar();
        this.inOnCalendarChange = false
    },
    adjustToCalendar: function () {
        this.getTaskStore() && this.forEachTask(function (a) {
            a.adjustToCalendar()
        })
    },
    assignTo: function (a, c, d) {
        var b = a instanceof Gnt.model.Task ? a : this.getTaskStore().getModelById(a);
        return b.assign(this, c, d)
    },
    unAssignFrom: function (a, c) {
        var b = a instanceof Gnt.model.Task ? a : this.getTaskStore().getModelById(a);
        return b.unAssign(this, c)
    },
    unassignFrom: function () {
        return this.unAssignFrom.apply(this, arguments)
    },
    forEachAssignment: function (b, j) {
        var g = this, h = g.getTaskStore(), e = h && h.getAssignmentStore(), a = e && e.getAssignmentsForResource(g) || [], d, f, c;
        j = j || this;
        for (c = false, d = 0, f = a.length; !c && d < f; ++d) {
            c = (false === b.call(j, a[d]))
        }
    },
    forEachTask: function (c, k) {
        var h = this, j = h.getTaskStore(), f = j && j.getAssignmentStore(), a = f && f.getAssignmentsForResource(h) || [], e, g, d, b;
        k = k || this;
        for (d = false, e = 0, g = a.length; !d && e < g; ++e) {
            b = a[e].getTask();
            b && (d = (false === c.call(k, b)))
        }
    },
    collectAvailabilityIntervalPoints: function (f, a, i, h, c) {
        for (var e = 0, d = f.length; e < d; e++) {
            var b = f[e];
            var g = b.startDate - 0;
            var j = b.endDate - 0;
            if (!h[g]) {
                h[g] = [];
                c.push(g)
            }
            h[g].push(a);
            if (!h[j]) {
                h[j] = [];
                c.push(j)
            }
            h[j].push(i)
        }
    },
    forEachAvailabilityIntervalWithTasks: function (f, h, b) {
        b = b || this;
        var e = f.startDate;
        var B = f.endDate;
        if (!e || !B) {
            throw"Both `startDate` and `endDate` are required for `forEachAvailabilityIntervalWithTasks`"
        }
        var m = new Date(e);
        var D = f.includeAllIntervals;
        var C = f.includeResCalIntervals;
        var t = this.getCalendar();
        var q = [];
        var r = [];
        var c = [];
        var H = [e - 0, B - 0];
        var o = {};
        o[e - 0] = [{type: "00-intervalStart"}];
        o[B - 0] = [{type: "00-intervalEnd"}];
        this.forEachAssignment(function (j) {
            var k = j.getTask();
            if (!k) {
                return
            }
            var N = k.getStartDate();
            var I = k.getEndDate();
            var M = k.getId();
            if (N > B || I < e) {
                return
            }
            r.push(k);
            c.push(k.getOwnCalendar() || this.getCalendar());
            if (k.isSegmented()) {
                for (var O = k.getSegments(), K = 0, J = O.length; K < J; K++) {
                    var L = O[K];
                    this.collectAvailabilityIntervalPoints([{
                        startDate: L.getStartDate(),
                        endDate: L.getEndDate()
                    }], {type: "05-taskStart", assignment: j, taskId: M, units: j.getUnits()}, {
                        type: "04-taskEnd",
                        taskId: M
                    }, o, H)
                }
            } else {
                this.collectAvailabilityIntervalPoints([{startDate: N, endDate: I}], {
                    type: "05-taskStart",
                    assignment: j,
                    taskId: M,
                    units: j.getUnits()
                }, {type: "04-taskEnd", taskId: M}, o, H)
            }
            q.push(j)
        });
        if (!r.length && !D && !C) {
            return
        }
        var g = Sch.util.Date;
        var A, u, d;
        while (m < B) {
            this.collectAvailabilityIntervalPoints(t.getAvailabilityIntervalsFor(m), {type: "00-resourceAvailabilityStart"}, {type: "01-resourceAvailabilityEnd"}, o, H);
            for (A = 0, u = c.length; A < u; A++) {
                d = r[A].getId();
                this.collectAvailabilityIntervalPoints(c[A].getAvailabilityIntervalsFor(m), {
                    type: "02-taskAvailabilityStart",
                    taskId: d
                }, {type: "03-taskAvailabilityEnd", taskId: d}, o, H)
            }
            m = g.getStartOfNextDay(m)
        }
        H.sort(function (j, i) {
            return j - i
        });
        var x = false, F = false, E = {}, a = 0, z = 0;
        for (A = 0, u = H.length - 1; A < u; A++) {
            var y = o[H[A]];
            y.sort(function (j, i) {
                return j.type < i.type ? 1 : -1
            });
            for (var v = 0, w = y.length; v < w; v++) {
                var s = y[v];
                switch (s.type) {
                    case"00-resourceAvailabilityStart":
                        F = true;
                        break;
                    case"01-resourceAvailabilityEnd":
                        F = false;
                        break;
                    case"02-taskAvailabilityStart":
                        a++;
                        break;
                    case"03-taskAvailabilityEnd":
                        a--;
                        break;
                    case"05-taskStart":
                        E[s.taskId] = s;
                        z++;
                        break;
                    case"04-taskEnd":
                        delete E[s.taskId];
                        z--;
                        break;
                    case"00-intervalStart":
                        x = true;
                        break;
                    case"00-intervalEnd":
                        return
                }
            }
            if (x && (D || C && F || F && a && z)) {
                var p = {inResourceCalendar: !!F, inTasksCalendar: !!a, inTask: z};
                var G = H[A];
                var n = H[A + 1];
                if (G > B || n < e) {
                    continue
                }
                if (G < e) {
                    G = e - 0
                }
                if (n > B) {
                    n = B - 0
                }
                if (h.call(b, G, n, E, p) === false) {
                    return false
                }
            }
        }
    },
    getAllocationInfo: function (a) {
        var b = [];
        this.forEachAvailabilityIntervalWithTasks(a, function (j, h, g, k) {
            var f = 0, d = [], c = {};
            if (k.inResourceCalendar && k.inTasksCalendar && k.inTask) {
                for (var e in g) {
                    f += g[e].units;
                    d.push(g[e].assignment);
                    c[e] = g[e].assignment
                }
            }
            b.push(Ext.apply({
                startDate: new Date(j),
                endDate: new Date(h),
                totalAllocation: f,
                assignments: d,
                assignmentsHash: c
            }, k))
        });
        return b
    }
});
Ext.define("Gnt.model.task.More", {
    propagating: false, indent: function (d) {
        var c = this, b = c.previousSibling, a;
        if (b) {
            c.propagateChanges(function () {
                return c.indentWithoutPropagation(function (e) {
                    a = e
                })
            }, function (f, e) {
                if (f) {
                    a && a()
                } else {
                    b.expand()
                }
                d && d(f, e)
            })
        } else {
            d && d(false, {})
        }
    }, indentWithoutPropagation: function (b) {
        var h = this, a = h.previousSibling, i, d, g, c, f, e;
        e = {parentNode: h.parentNode, previousSibling: h.previousSibling, nextSibling: h.nextSibling};
        i = h.getTaskStore();
        d = h.parentNode;
        g = d.indexOf(h);
        i.suspendEvents(true);
        c = a.get("leaf");
        if (c) {
            f = a.getSegments();
            a.markAsParent()
        }
        a.appendChild(h);
        h.removeContext = e;
        a.removeInvalidDependencies();
        b && b(function () {
            d.insertChild(g, h);
            c && a.set("leaf", true);
            c && f && a.setSegmentsWithoutPropagation(f)
        });
        i.resumeEvents();
        return h
    }, outdent: function (d) {
        var c = this, a = c.parentNode, b;
        if (a && !a.isRoot()) {
            c.propagateChanges(function () {
                return c.outdentWithoutPropagation(function (e) {
                    b = e
                })
            }, function (f, e) {
                f && b && b();
                d && d(f, e)
            })
        } else {
            d && d(false, {})
        }
    }, outdentWithoutPropagation: function (d) {
        var e = this, b, f, c, a;
        a = {parentNode: e.parentNode, previousSibling: e.previousSibling, nextSibling: e.nextSibling};
        c = e.getTaskStore();
        b = e.parentNode;
        f = b.indexOf(e);
        c.suspendEvents(true);
        if (b.nextSibling) {
            b.parentNode.insertBefore(e, b.nextSibling)
        } else {
            b.parentNode.appendChild(e)
        }
        e.convertEmptyParentToLeaf && b.set("leaf", b.childNodes.length === 0);
        e.removeContext = a;
        b.parentNode.removeInvalidDependencies();
        c.resumeEvents();
        d && d(function () {
            b.insertChild(f, e)
        });
        return b
    }, removeInvalidDependencies: function () {
        var a = this.getDependencyStore(), c = this.getAllDependencies();
        for (var b = 0; b < c.length; b++) {
            if (!c[b].isValid(true)) {
                a.remove(c[b])
            }
        }
    }, getAllDependencies: function () {
        return this.predecessors.concat(this.successors)
    }, hasIncomingDependencies: function () {
        return this.predecessors.length > 0
    }, hasOutgoingDependencies: function () {
        return this.successors.length > 0
    }, getIncomingDependencies: function (a) {
        return a ? this.predecessors : this.predecessors.slice()
    }, getOutgoingDependencies: function (a) {
        return a ? this.successors : this.successors.slice()
    }, alignByIncomingDependencies: function (c, b, d) {
        var a = this.alignByIncomingDependenciesWithoutPropagation(c, b);
        this.propagateChanges(null, d, true);
        return a
    }, alignByIncomingDependenciesWithoutPropagation: function (e, d, c) {
        if (this.isManuallyScheduled()) {
            return false
        }
        var g = false;
        e = e || this.getTaskStore();
        var b = this.getIncomingDependenciesConstraintContext(e, c);
        if (b) {
            var a = b.startDate;
            var f = b.endDate;
            if (a && f) {
                var h = this.calculateStartDate(f, this.getDuration(), this.getDurationUnit());
                if (h > a) {
                    a = h
                }
                f = null
            }
            if (a && a - this.getStartDate() !== 0) {
                d && d.addAffected(this);
                this.setStartDateWithoutPropagation(a, true, e.skipWeekendsDuringDragDrop);
                g = true
            } else {
                if (f && f - this.getEndDate() !== 0) {
                    d && d.addAffected(this);
                    this.setEndDateWithoutPropagation(f, true, e.skipWeekendsDuringDragDrop);
                    g = true
                }
            }
        }
        return g
    }, getIncomingDependenciesConstraintContext: function (f, h) {
        var g = this.getIncomingDependencies(true);
        if (!g.length || this.isUnscheduled()) {
            return null
        }
        var a = Gnt.model.Dependency.Type, c = new Date(0), b = new Date(0), j = this.getProjectCalendar(), i = this.getCalendar(), d;
        var e = (f || this.getTaskStore()).dependenciesCalendar;
        Ext.Array.forEach(g, function (m) {
            var l = m.getSourceTask(f);
            if (l && (!h || l.isAncestor(h))) {
                var o;
                if (e == "project") {
                    o = j
                } else {
                    if (e == "source") {
                        o = l.getCalendar()
                    } else {
                        if (e == "target") {
                            o = i
                        } else {
                            throw"Unsupported value for `dependenciesCalendar` config option"
                        }
                    }
                }
                var q = m.getLag() || 0, n = m.getLagUnit(), p = l.getStartDate(), k = l.getEndDate();
                switch (m.getType()) {
                    case a.StartToEnd:
                        p = o.skipWorkingTime(p, q, n);
                        if (b < p) {
                            b = p;
                            d = l
                        }
                        break;
                    case a.StartToStart:
                        p = o.skipWorkingTime(p, q, n);
                        if (c < p) {
                            c = p;
                            d = l
                        }
                        break;
                    case a.EndToStart:
                        k = o.skipWorkingTime(k, q, n);
                        if (c < k) {
                            c = k;
                            d = l
                        }
                        break;
                    case a.EndToEnd:
                        k = o.skipWorkingTime(k, q, n);
                        if (b < k) {
                            b = k;
                            d = l
                        }
                        break;
                    default:
                        throw"Invalid dependency type: " + m.getType()
                }
            }
        });
        return {startDate: c > 0 ? c : null, endDate: b > 0 ? b : null, constrainingTask: d}
    }, getCriticalPaths: function () {
        var b = [this], a = this.getIncomingDependenciesConstraintContext();
        while (a) {
            b.push(a.constrainingTask);
            a = a.constrainingTask.getIncomingDependenciesConstraintContext()
        }
        return b
    }, addSubtask: function (d, f) {
        var c = this, a, b;
        c.propagateChanges(function () {
            return c.addSubtaskWithoutPropagation(d, function g(i, h) {
                b = i;
                a = h
            })
        }, function e(h, g) {
            h && b && b();
            f && f(h, g)
        });
        return a
    }, addSubtaskWithoutPropagation: function (h, g) {
        var d = this, a, e, f, c, b;
        a = h.parentNode;
        e = a && a.indexOf(d);
        c = d.get("leaf");
        if (c) {
            d.markAsParent();
            b = d.getSegments()
        }
        h = d.appendChild(h);
        d.expand();
        g && g(function () {
            if (a) {
                a.insertChild(e, h)
            } else {
                d.removeChild(h)
            }
            c && d.set("leaf", true);
            c && b && d.setSegmentsWithoutPropagation(b)
        }, h);
        if (!a) {
            f = h
        } else {
            if (d !== a && d.getTaskStore(true) === a.getTaskStore(true)) {
                f = [h, a]
            }
        }
        return f
    }, insertSubtask: function (b, e, g) {
        var d = this, a, c;
        d.propagateChanges(function () {
            return d.insertSubtaskWithoutPropagation(b, e, function h(j, i) {
                c = j;
                a = i
            })
        }, function f(i, h) {
            i && c && c();
            g && g(i, h)
        });
        return a
    }, insertSubtaskWithoutPropagation: function (g, a, h) {
        var i = this, d, f, c, b, e;
        d = a.parentNode;
        f = d && d.indexOf(i);
        b = i.get("leaf");
        if (b) {
            i.markAsParent();
            e = i.getSegments()
        }
        a = i.insertChild(g, a);
        i.expand();
        h && h(function () {
            if (d) {
                d.insertChild(f, a)
            } else {
                i.removeChild(a)
            }
            b && i.set("leaf", true);
            b && e && i.setSegmentsWithoutPropagation(e)
        }, a);
        if (!d) {
            c = a
        } else {
            if (i !== d && i.getTaskStore(true) === d.getTaskStore(true)) {
                c = [a, d]
            }
        }
        return c
    }, removeSubtask: function (c, e) {
        var b = this, a;
        b.propagateChanges(function () {
            return b.removeSubtaskWithoutPropagation(c, function f(g) {
                a = g
            })
        }, function d(g, f) {
            g && a && a();
            e && e(g, f)
        })
    }, removeSubtaskWithoutPropagation: function (c, d) {
        var n = this, e = n.indexOf(c), o, f, j, m, b, l, g, h, k, a;
        f = n.getDependencyStore();
        j = n.getAssignmentStore();
        m = f && f.getDependenciesForTask(c);
        b = j && c.getAssignments();
        o = [];
        l = [];
        g = [];
        c.cascadeBy(function (i) {
            i !== c && o.push(i)
        });
        for (h = 0, k = o.length; (f || j) && h < k; h++) {
            a = o[h];
            f && (m = m.concat(f.getDependenciesForTask(a)));
            j && (b = b.concat(a.getAssignments()))
        }
        m = f && Ext.Array.unique(m);
        m = f && Ext.Array.sort(m, function (p, i) {
                return f.indexOf(p) < f.indexOf(i) ? -1 : 1
            });
        for (h = 0, k = m && m.length; f && h < k; h++) {
            l.push(f.indexOf(m[h]))
        }
        b = j && Ext.Array.sort(b, function (p, i) {
                return j.indexOf(p) < j.indexOf(i) ? -1 : 1
            });
        for (h = 0, k = b && b.length; j && h < k; h++) {
            g.push(j.indexOf(b[h]))
        }
        j && j.remove(b);
        f && f.remove(m);
        c = n.removeChild(c);
        if (n.childNodes.length === 0 && n.convertEmptyParentToLeaf) {
            n.set("leaf", true)
        }
        d && d(function () {
            n.insertChild(e, c);
            for (h = 0, k = b && b.length; j && h < k; h++) {
                j.insert(g[h], b[h])
            }
            for (h = 0, k = m && m.length; f && h < k; h++) {
                f.insert(l[h], m[h])
            }
        });
        return n
    }, addSuccessor: function (b, f) {
        var d = this, a, c;
        d.propagateChanges(function () {
            return d.addSuccessorWithoutPropagation(b, function g(i, h) {
                c = i;
                a = h
            })
        }, function e(h, g) {
            h && c && c();
            f && f(h, g)
        });
        return a
    }, addSuccessorWithoutPropagation: function (b, g) {
        var f = this, a = f.parentNode, d = a.indexOf(f), c, e;
        b = b || new f.self();
        b.calendar = b.calendar || f.getCalendar();
        b.taskStore = b.taskStore || f.getTaskStore(true);
        if (f.getEndDate()) {
            b.beginEdit();
            b.set(f.startDateField, f.getEndDate());
            b.set(f.endDateField, b.calculateEndDate(f.getEndDate(), 1, Sch.util.Date.DAY));
            b.set(f.durationField, 1);
            b.set(f.durationUnitField, Sch.util.Date.DAY);
            b.endEdit()
        }
        a.insertSubtaskWithoutPropagation(d + 1, b, function (i, h) {
            c = i;
            b = h
        });
        f.linkToWithoutPropagation(b, Gnt.model.Dependency.Type.EndToStart, function (h) {
            e = h
        });
        g && g(function () {
            e();
            c()
        }, b);
        return f
    }, addMilestone: function (c, d) {
        var b = this, a = b.getEndDate();
        if (!c) {
            c = new b.self()
        } else {
            if (Ext.isObject(c) && !(c instanceof Gnt.model.Task)) {
                c = new b.self(c)
            }
        }
        if (a && !c.isMilestone()) {
            c.calendar = c.calendar || b.getCalendar();
            c.setStartEndDate(a, a)
        }
        return b.addTaskBelow(c, d)
    }, addPredecessor: function (c, f) {
        var d = this, a, b;
        d.propagateChanges(function () {
            return d.addPredecessorWithoutPropagation(c, function g(i, h) {
                b = i;
                a = h
            })
        }, function e(h, g) {
            h && b();
            f && f(h, g)
        });
        return a
    }, addPredecessorWithoutPropagation: function (e, g) {
        var f = this, a = f.parentNode, c = a.indexOf(f), b, d;
        e = e || new f.self();
        e.calendar = e.calendar || f.getCalendar();
        e.taskStore = e.taskStore || f.getTaskStore(true);
        if (f.getStartDate()) {
            e.beginEdit();
            e.set(f.startDateField, e.calculateStartDate(f.getStartDate(), 1, Sch.util.Date.DAY));
            e.set(f.endDateField, f.getStartDate());
            e.set(f.durationField, 1);
            e.set(f.durationUnitField, Sch.util.Date.DAY);
            e.endEdit()
        }
        a.insertSubtaskWithoutPropagation(c, e, function (i, h) {
            b = i;
            e = h
        });
        e.linkToWithoutPropagation(f, Gnt.model.Dependency.Type.EndToStart, function (h) {
            d = h
        });
        g && g(function () {
            d();
            b()
        }, e);
        return e
    }, getSuccessors: function () {
        var e = this.successors, d = [];
        for (var c = 0, a = e.length; c < a; c++) {
            var b = e[c].getTargetTask();
            if (b) {
                d.push(b)
            }
        }
        return d
    }, getPredecessors: function () {
        var e = this.predecessors, d = [];
        for (var c = 0, a = e.length; c < a; c++) {
            var b = e[c].getSourceTask();
            if (b) {
                d.push(b)
            }
        }
        return d
    }, addTaskAbove: function (c, h) {
        var f = this, a = f.parentNode, d = a.indexOf(f), b, e;
        c = c || new f.self();
        f.propagateChanges(function () {
            return a.insertSubtaskWithoutPropagation(d, c, function i(k, j) {
                e = k;
                b = j
            })
        }, function g(j, i) {
            j && e();
            h && h(j, i)
        });
        return b
    }, addTaskBelow: function (c, h) {
        var f = this, a = f.parentNode, d = a.indexOf(f) + 1, b, e;
        c = c || new f.self();
        f.propagateChanges(function () {
            return a.insertSubtaskWithoutPropagation(d, c, function i(k, j) {
                e = k;
                b = j
            })
        }, function g(j, i) {
            j && e();
            h && h(j, i)
        });
        return b
    }, isAbove: function (a) {
        var b = this, d = Math.min(b.data.depth, a.data.depth);
        var c = this;
        while (c.data.depth > d) {
            c = c.parentNode;
            if (c == a) {
                return false
            }
        }
        while (a.data.depth > d) {
            a = a.parentNode;
            if (a == b) {
                return true
            }
        }
        while (a.parentNode !== c.parentNode) {
            a = a.parentNode;
            c = c.parentNode
        }
        return a.data.index > c.data.index
    }, cascadeChildren: function (d, c) {
        var e = this;
        if (e.isLeaf()) {
            return
        }
        var f = this.childNodes;
        for (var b = 0, a = f.length; b < a; b++) {
            f[b].cascadeBy(d, c)
        }
    }, getSlack: function (b) {
        b = b || Sch.util.Date.DAY;
        var c = this.getEarlyStartDate(), a = this.getLateStartDate();
        if (!c || !a) {
            return null
        }
        return this.getCalendar().calculateDuration(c, a, b)
    }, getEarlyStartDate: function () {
        var k = this.getTaskStore();
        if (!k) {
            return this.getStartDate()
        }
        var h = this.internalId;
        if (k.earlyStartDates[h]) {
            return k.earlyStartDates[h]
        }
        var b, n = 0, f, e;
        if (this.childNodes.length) {
            for (f = 0, e = this.childNodes.length; f < e; f++) {
                b = this.childNodes[f].getEarlyStartDate();
                if (b < n || !n) {
                    n = b
                }
            }
            k.earlyStartDates[h] = n;
            return n
        }
        if (this.isManuallyScheduled()) {
            n = k.earlyStartDates[h] = this.getStartDate();
            return n
        }
        var m = this.getIncomingDependencies(true), j;
        if (!m.length) {
            n = k.earlyStartDates[h] = this.getStartDate();
            return n
        }
        var g = Gnt.model.Dependency.Type, a = this.getCalendar(), d = this.getProjectCalendar(), c;
        for (f = 0, e = m.length; f < e; f++) {
            j = m[f].getSourceTask();
            if (j) {
                switch (m[f].getType()) {
                    case g.StartToStart:
                        b = j.getEarlyStartDate();
                        break;
                    case g.StartToEnd:
                        b = j.getEarlyStartDate();
                        b = a.calculateStartDate(b, this.getDuration(), this.getDurationUnit());
                        break;
                    case g.EndToStart:
                        b = j.getEarlyEndDate();
                        break;
                    case g.EndToEnd:
                        b = j.getEarlyEndDate();
                        b = a.calculateStartDate(b, this.getDuration(), this.getDurationUnit());
                        break
                }
                c = m[f].getLag();
                if (c) {
                    b = d.skipWorkingTime(b, c, m[f].getLagUnit())
                }
                b = d.skipNonWorkingTime(b, true)
            }
            if (b > n) {
                n = b
            }
        }
        k.earlyStartDates[h] = n;
        return n
    }, getEarlyEndDate: function () {
        var d = this.getTaskStore();
        if (!d) {
            return this.getEndDate()
        }
        var c = this.internalId;
        if (d.earlyEndDates[c]) {
            return d.earlyEndDates[c]
        }
        var a = 0;
        if (this.childNodes.length) {
            var f, e, b;
            for (e = 0, b = this.childNodes.length; e < b; e++) {
                f = this.childNodes[e].getEarlyEndDate();
                if (f > a) {
                    a = f
                }
            }
            d.earlyEndDates[c] = a;
            return a
        }
        if (this.isManuallyScheduled()) {
            a = d.earlyEndDates[c] = this.getEndDate();
            return a
        }
        var g = this.getEarlyStartDate();
        if (!g) {
            return null
        }
        a = d.earlyEndDates[c] = this.getCalendar().calculateEndDate(g, this.getDuration(), this.getDurationUnit());
        return a
    }, getLateEndDate: function () {
        var k = this.getTaskStore();
        if (!k) {
            return this.getEndDate()
        }
        var j = this.internalId;
        if (k.lateEndDates[j]) {
            return k.lateEndDates[j]
        }
        var b, n = 0, g, e;
        if (this.childNodes.length) {
            for (g = 0, e = this.childNodes.length; g < e; g++) {
                b = this.childNodes[g].getLateEndDate();
                if (b > n) {
                    n = b
                }
            }
            k.lateEndDates[j] = n;
            return n
        }
        if (this.isManuallyScheduled()) {
            n = k.lateEndDates[j] = this.getEndDate();
            return n
        }
        var m = this.getOutgoingDependencies(true);
        if (!m.length) {
            n = k.lateEndDates[j] = k.getProjectEndDate();
            return n
        }
        var h = Gnt.model.Dependency.Type, a = this.getCalendar(), d = this.getProjectCalendar(), f, c;
        for (g = 0, e = m.length; g < e; g++) {
            f = m[g].getTargetTask();
            if (f) {
                switch (m[g].getType()) {
                    case h.StartToStart:
                        b = f.getLateStartDate();
                        b = a.calculateEndDate(b, this.getDuration(), this.getDurationUnit());
                        break;
                    case h.StartToEnd:
                        b = f.getLateEndDate();
                        b = a.calculateEndDate(b, this.getDuration(), this.getDurationUnit());
                        break;
                    case h.EndToStart:
                        b = f.getLateStartDate();
                        break;
                    case h.EndToEnd:
                        b = f.getLateEndDate();
                        break
                }
                c = m[g].getLag();
                if (c) {
                    b = d.skipWorkingTime(b, -c, m[g].getLagUnit())
                }
                b = d.skipNonWorkingTime(b, false);
                if (b < n || !n) {
                    n = b
                }
            }
        }
        k.lateEndDates[j] = n || k.getProjectEndDate();
        return k.lateEndDates[j]
    }, getLateStartDate: function () {
        var d = this.getTaskStore();
        if (!d) {
            return this.getStartDate()
        }
        var c = this.internalId;
        if (d.lateStartDates[c]) {
            return d.lateStartDates[c]
        }
        var a;
        if (this.childNodes.length) {
            var f, e, b;
            for (e = 0, b = this.childNodes.length; e < b; e++) {
                f = this.childNodes[e].getLateStartDate();
                if (f < a || !a) {
                    a = f
                }
            }
            d.lateStartDates[c] = a;
            return a
        }
        if (this.isManuallyScheduled()) {
            a = d.lateStartDates[c] = this.getStartDate();
            return a
        }
        var g = this.getLateEndDate();
        if (!g) {
            return null
        }
        a = d.lateStartDates[c] = this.getCalendar().calculateStartDate(g, this.getDuration(), this.getDurationUnit());
        return a
    }, resetEarlyDates: function () {
        var b = this.getTaskStore();
        if (!b) {
            return
        }
        var a = this.internalId;
        b.earlyStartDates[a] = null;
        b.earlyEndDates[a] = null
    }, resetLateDates: function () {
        var b = this.getTaskStore();
        if (!b) {
            return
        }
        var a = this.internalId;
        b.lateStartDates[a] = null;
        b.lateEndDates[a] = null
    }, getTopParent: function (c) {
        var b = this.getTaskStore().getRootNode(), e = this, d = [this], a;
        while (e) {
            if (e === b) {
                return c ? d : a
            }
            d.push(e);
            a = e;
            e = e.parentNode
        }
    }, getInDepthWalker: function (a) {
        var d = a ? this : this.childNodes && this.childNodes[0];
        var b = this;
        var e = {};
        var c = function (h) {
            var g = h;
            var f = g.internalId;
            if (g.isLeaf() || !g.childNodes.length) {
                g = g.nextSibling
            } else {
                if (e[f] === true) {
                    e[f] = false;
                    g = g.nextSibling
                } else {
                    e[f] = true;
                    g = g.childNodes[0]
                }
            }
            if (!g) {
                g = h;
                do {
                    if (g === b) {
                        return null
                    }
                    g = g.parentNode;
                    if (g === b) {
                        return null
                    }
                } while (e[g.internalId] === false);
                return c(g)
            }
            return g
        };
        return function () {
            var f = d;
            if (d) {
                d = c(d)
            }
            return f
        }
    }, propagateChanges: function (i, k, g) {
        var d = this, a, h, f, b;
        f = d.getTaskStore(true);
        g = arguments.length == 3 ? g : f && f.cascadeChanges;
        if (!d.propagating && f) {
            d.propagating = true;
            h = {};
            f.suspendAutoSync();
            b = f.startBatchCascade();
            f.startProjection();
            try {
                a = (i && i !== Ext.emptyFn) ? i(d) : [d]
            } catch (c) {
                f.rejectProjection();
                f.endBatchCascade();
                f.resumeAutoSync(f.autoSync);
                d.propagating = false;
                throw c
            }
            if (a === true) {
                a = d.isProjected() && [d] || false
            } else {
                if (a) {
                    a = [].concat(a)
                }
            }
            if (a) {
                d.propagateChangesThroughDependentTasks(f.getLinearWalkingSequenceForDependentTasks(a, {
                    self: true,
                    ancestors: f.recalculateParents,
                    descendants: f.moveParentAsGroup,
                    successors: g,
                    cycles: f.cycleResolutionStrategy
                }), f, b, a, g, h, function j(l, e) {
                    if (l) {
                        f.rejectProjection();
                        e = {}
                    } else {
                        f.commitProjection()
                    }
                    f.endBatchCascade();
                    d.propagating = false;
                    k && k(l, e);
                    f.resumeAutoSync(f.autoSync && !l && !Ext.Object.isEmpty(e))
                })
            } else {
                f.rejectProjection();
                f.endBatchCascade();
                d.propagating = false;
                k && k(false, {});
                f.resumeAutoSync(f.autoSync)
            }
        } else {
            if (!d.propagating) {
                d.propagating = true;
                try {
                    i && i(d)
                } catch (c) {
                    d.propagating = false;
                    throw c
                }
                d.verifyConstraint(function (e, l) {
                    h = {};
                    l = !!l;
                    if (!l) {
                        h[d.getId()] = d
                    }
                    d.propagating = false;
                    k && k(l, h)
                })
            } else {
                k && k(true, {})
            }
        }
    }, propagateChangesThroughDependentTasks: function (g, h, b, a, j, k, m, d) {
        var f = this, c, e, l;
        d = d || 0;
        l = true;
        for (c = d, e = g.length; l && c < e; ++c) {
            l = f.processTaskConstraints(g, c, h, b, a, j, k, function (n, o, p, i) {
                if (p || (n == e - 1)) {
                    m(p, i)
                } else {
                    if (!o) {
                        f.propagateChangesThroughDependentTasks(g, h, b, a, j, i, m, n + 1)
                    }
                }
            })
        }
    }, processTaskConstraints: function (r, p, k, a, t, f, i, e) {
        var x = this, g = r[p], u = g[0], q = g[1], w = u.hasChildNodes(), v = !w, m = !(u.isManuallyScheduled() || Ext.Array.contains(t, u)), y = f || k.cascadeChanges, o = k.recalculateParents, d = k.moveParentAsGroup, j = u.parentNode, c = j && (j.getStartDate()), s = j && (j.getUnprojected(j.startDateField)), n = j && (c - s), h;

        function l(z, G, A) {
            var B = z.getIncomingDependencies(true), H = false, C, D, F, E;
            for (C = 0, D = B.length; !H && C < D; ++C) {
                F = B[C];
                E = F.getSourceTask();
                H = E && G.hasOwnProperty(E.getId()) || Ext.Array.contains(A, E)
            }
            return H
        }

        switch (true) {
            case m && v && q == "green" && n && d:
            case m && w && q == "yellow" && n && d:
                if (c) {
                    var b = u.getStartDate();
                    if (b >= s) {
                        h = u.calculateDuration(s, b, null, {segments: false});
                        u.setStartDateWithoutPropagation(u.calculateEndDate(c, h, null, {segments: false}), true, k.skipWeekendsDuringDragDrop)
                    } else {
                        h = u.calculateDuration(b, s, null, {segments: false});
                        u.setStartDateWithoutPropagation(u.calculateStartDate(c, h, null, {segments: false}), true, k.skipWeekendsDuringDragDrop)
                    }
                    l(u, i, t) && u.alignByIncomingDependenciesWithoutPropagation(k, null, j)
                }
                break;
            case m && v && q == "green" && y:
            case m && w && q == "yellow" && y:
                l(u, i, t) && u.alignByIncomingDependenciesWithoutPropagation(k, null);
                break;
            case w && q == "green" && o:
                u.refreshCalculatedParentNodeData();
                break
        }
        if (u.isProjected()) {
            a.addAffected(u);
            i[u.getId()] = u
        }
        return u.verifyConstraint(function (A, C) {
            var z, B;
            if (!A && w && m && k.recalculateParents && q == "green") {
                z = Ext.Array.findBy(r, function (F, D) {
                    var G = F[0], E = F[1];
                    B = D;
                    return u === G && E == "yellow"
                });
                e(B, A, !!C, i)
            } else {
                e(p, A, !!C, i)
            }
        })
    }
});
Ext.define("Gnt.model.task.Constraints", {
    requires: ["Gnt.constraint.Base", "Gnt.constraint.StartNoEarlierThan", "Gnt.constraint.StartNoLaterThan", "Gnt.constraint.FinishNoEarlierThan", "Gnt.constraint.FinishNoLaterThan", "Gnt.constraint.MustStartOn", "Gnt.constraint.MustFinishOn"],
    setConstraint: function (c, b, g) {
        var e = this, a = e.getTaskStore(true), f;
        if (c) {
            f = Gnt.constraint.Base.getConstraintClass(c)
        }
        if (!b && f) {
            b = f.getInitialConstraintDate(e)
        }
        function d() {
            e.beginEdit();
            e.set(e.constraintTypeField, c || "");
            e.set(e.constraintDateField, b);
            e.endEdit();
            return true
        }

        if (c) {
            e.propagateChanges(d, g)
        } else {
            d();
            g && g(false, {})
        }
    },
    setConstraintType: function (a, b) {
        this.setConstraint(a, this.getConstraintDate(), b)
    },
    setConstraintDate: function (a, b) {
        this.setConstraint(this.getConstraintType(), a, b)
    },
    hasConstraint: function () {
        return !!this.getConstraintType()
    },
    getConstraintClass: function () {
        return Gnt.constraint.Base.getConstraintClass(this.getConstraintType())
    },
    isConstraintSatisfied: function () {
        var b = this, a = b.getTaskStore(true);
        return !b.hasConstraint() || b.getConstraintClass().isSatisfied(b, b.getConstraintDate())
    },
    verifyConstraint: function (f) {
        var e = this, b, a, d, c, g;
        c = e.isConstraintSatisfied();
        f = f && Ext.Function.pass(f, [c]);
        b = e.getTaskStore(true);
        g = b && b.hasListener("constraintconflict");
        a = b && b.constraintDatePrecision || Sch.util.Date.DAY;
        d = !c && e.getConstraintClass().getResolution(f, e, null, a);
        if (!c && b && g) {
            b.fireEvent("constraintconflict", e, d)
        } else {
            if (!c) {
                d.cancelAction()
            } else {
                if (f) {
                    f(false)
                }
            }
        }
        return c
    },
    getWorkingTimeStartForDate: function (c) {
        var d = this, b = false, a, e;
        a = Ext.Date.clearTime(c, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d.forEachAvailabilityInterval({
            isForward: true,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function (g, f) {
                b = new Date(g);
                return false
            }
        });
        return b
    },
    getWorkingTimeEndForDate: function (c) {
        var d = this, b = false, a, e;
        a = Ext.Date.clearTime(c, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d.forEachAvailabilityInterval({
            isForward: false,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function (g, f) {
                b = new Date(f);
                return false
            }
        });
        return b
    },
    getNearestWorkingTimeStartForDate: function (c, d, b) {
        var f = this, e, a;
        d = d || false;
        b = b || 365;
        e = d ? -1 : 1;
        a = f.getWorkingTimeStartForDate(c);
        while (!a && b--) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, e);
            a = f.getWorkingTimeStartForDate(c)
        }
        return a
    },
    getNearestWorkingTimeEndForDate: function (c, d, b) {
        var f = this, e, a;
        d = d || false;
        b = b || 365;
        e = d ? -1 : 1;
        a = f.getWorkingTimeEndForDate(c);
        while (!a && b--) {
            c = Sch.util.Date.add(c, Sch.util.Date.DAY, e);
            a = f.getWorkingTimeEndForDate(c)
        }
        return a
    },
    getWorkingTimeIntervalForDateTime: function (d) {
        var c = this, b = false, a, e;
        a = Ext.Date.clearTime(d, true);
        e = Sch.util.Date.add(a, Sch.util.Date.DAY, 1);
        d = d.valueOf();
        c.forEachAvailabilityInterval({
            isForward: true,
            startDate: a,
            endDate: e,
            segments: false,
            resources: true,
            fn: function (g, f) {
                if (g <= d && d <= f) {
                    b = {startDate: new Date(g), endDate: new Date(f)}
                }
                return !b
            }
        });
        return b
    },
    isDateTimeWithinWorkingTimeInterval: function (b) {
        var a = this;
        return a.getWorkingTimeIntervalForDateTime(b) !== false
    }
});
Ext.define("Gnt.model.task.Splittable", {
    uses: ["Gnt.model.TaskSegment"],
    segmentsTrackingSuspended: 0,
    changingTaskBySegments: false,
    splitsDuration: 0,
    segmentsSnapshot: null,
    segmentsProjection: null,
    getFirstSegment: function () {
        var a = this.getSegments();
        return a && a[0]
    },
    getLastSegment: function () {
        var a = this.getSegments();
        return a && a[a.length - 1]
    },
    normalizeSegments: function () {
        var a = this.getSegments();
        this.suspendSegmentsTracking();
        a.sort(function (d, c) {
            if (!d.normalized) {
                d.normalize()
            }
            if (!c.normalized) {
                c.normalize()
            }
            return d.getStartDate() > c.getStartDate() ? 1 : -1
        });
        this.mergeOverlappedSegments();
        if (a = this.getSegments()) {
            this.data[this.durationField] = this.getSegmentsDuration()
        }
        this.resumeSegmentsTracking()
    },
    updateSegmentsDates: function (a) {
        a = a || {};
        if (!this.isSegmented()) {
            return
        }
        this.suspendSegmentsTracking();
        a = Ext.apply({useAbsoluteOffset: false}, a);
        a.isForward = a.isForward !== false;
        this.forEachSegment(function (b) {
            b.updateDatesByOffsets(a)
        }, a.isForward);
        this.set(this.segmentsField, this.getSegments().slice());
        this.resumeSegmentsTracking()
    },
    getSegmentIntervalsForRange: function (h, d, g) {
        g = g || this.getSegments();
        if (!g) {
            return
        }
        var b = Sch.util.Date, k = [];
        for (var f = 0, e = g.length; f < e; f++) {
            var c = g[f], j = c.getStartDate(), a = c.getEndDate();
            if (b.intersectSpans(h, d, j, a)) {
                k.push([b.constrain(j, h, d) - 0, b.constrain(a, h, d) - 0])
            }
        }
        return k.length && k || null
    },
    getSegmentByDate: function (d, c) {
        c = c || this.getSegments();
        if (!c) {
            return
        }
        for (var e = 0, a = c.length; e < a; e++) {
            var b = c[e];
            if (d >= b.getStartDate() && d < b.getEndDate()) {
                return b
            }
        }
    },
    constrainSegments: function (d) {
        if (this.changingTaskBySegments) {
            return
        }
        d = d || {};
        var n = this.getSegments();
        if (!n) {
            return
        }
        var c = this.getDuration("MILLI"), q = d.unit || this.getDurationUnit(), f = d.duration, b = this.getStartDate(), r = this.getEndDate(), t = this.getUnitConverter();
        if (!b || (!r && !c && !f)) {
            this.set(this.segmentsField, null);
            return
        }
        if (f) {
            f = t.convertDurationToMs(f, q)
        } else {
            if (!r) {
                f = c
            }
        }
        this.suspendSegmentsTracking();
        n[0].setStartDateWithoutPropagation(this.getStartDate(), false);
        var m = 0, k = [], g = f, j, a;
        var h;
        if (f) {
            h = function (i) {
                return g <= 0
            }
        } else {
            h = function (i) {
                return i.getStartDate() >= r
            }
        }
        for (var p = 0, o = n.length; p < o; p++) {
            j = n[p];
            if (h(j)) {
                k.push.apply(k, n.slice(p));
                break
            }
            g -= j.getDuration("MILLI");
            if (a) {
                m += j.getStartOffset() - a.getEndOffset()
            }
            a = j
        }
        this.removeSegments(k);
        if (n.length < 2) {
            this.set(this.segmentsField, null)
        } else {
            var e = this.getLastSegment();
            var s = false;
            if (f) {
                if (g) {
                    e.setDurationWithoutPropagation(t.convertMSDurationToUnit(e.getEndOffset() - e.getStartOffset() + g, e.getDurationUnit()));
                    s = true
                }
            } else {
                if (e.getEndDate() - r) {
                    e.setEndDateWithoutPropagation(r, false);
                    s = true
                }
            }
            e.setNextSegment(null);
            this.splitsDuration = m;
            if ((k.length || s) && (!this.modified || !this.modified[this.segmentsField])) {
                this.set(this.segmentsField, this.getSegments().slice())
            }
        }
        this.resumeSegmentsTracking()
    },
    forEachSegment: function (b, e, d, a) {
        if (!b) {
            return
        }
        a = a || this;
        var f, c;
        if (e !== false) {
            f = "getNextSegment";
            c = d || this.getFirstSegment()
        } else {
            f = "getPrevSegment";
            c = d || this.getLastSegment()
        }
        while (c) {
            if (b.call(a, c) === false) {
                return
            }
            c = c[f].call(c)
        }
    },
    split: function (g, d, c, f, e) {
        var b = this, a;
        b.propagateChanges(function () {
            return b.splitWithoutPropagation(g, d, c, f, function h(i) {
                a = i
            })
        }, function (i, h) {
            i && a && a();
            e && e(i, h)
        })
    },
    splitWithoutPropagation: function (o, a, i, l, e) {
        var v = this;
        if (l !== true && l !== false) {
            var f = v.getTaskStore(true);
            l = f ? f.skipWeekendsDuringDragDrop : false
        }
        if (!o || !v.isLeaf() || v.isMilestone()) {
            return
        }
        var c = v.getStartDate(), p = v.getEndDate();
        if (!c || !p || (c >= o) || (o >= p)) {
            return
        }
        var m = v.getSegments(), b;
        var d = v.buildSegmentsSnapshot(m);
        if (m) {
            b = v.getSegmentByDate(o);
            if (!b) {
                return
            }
        } else {
            m = []
        }
        a = a || 1;
        i = i || this.getDurationUnit();
        var s = new Date(o), q = s, h = s, n = v.getUnitConverter().convertDurationToMs(a, i);
        if (l) {
            h = v.skipNonWorkingTime(h, true, true);
            q = v.skipNonWorkingTime(q, false, true)
        }
        var r = v.getDurationUnit(), g, t, j;
        v.suspendSegmentsTracking();
        if (!b) {
            g = v.calculateDuration(c, q);
            t = v.getDuration() - g;
            j = {task: v};
            j[v.startDateField] = c;
            j[v.durationField] = g;
            j[v.durationUnitField] = r;
            m.push(Ext.create(v.segmentClassName, j))
        } else {
            g = v.calculateDuration(b.getStartDate(), q, r);
            t = b.getDuration(r) - g;
            b.setEndDateWithoutPropagation(q, false, l)
        }
        var u = v.getUnitConverter().convertDurationToMs(a, i);
        if (b && b.getNextSegment()) {
            v.forEachSegment(function (w) {
                w.setStartEndOffset(w.getStartOffset() + u, w.getEndOffset() + u);
                w.updateDatesByOffsets()
            }, true, b.getNextSegment())
        }
        h = v.skipWorkingTime(h, u);
        if (l) {
            h = v.skipNonWorkingTime(h)
        }
        j = {prevSegment: b || m[0], task: v};
        j[v.startDateField] = h;
        j[v.durationField] = t;
        j[v.durationUnitField] = r;
        var k = Ext.create(v.segmentClassName, j);
        if (b) {
            Ext.Array.insert(m, Ext.Array.indexOf(m, b) + 1, [k])
        } else {
            m.push(k)
        }
        v.resumeSegmentsTracking();
        e && e(function () {
            v.rollbackSegmentsToSnapshot(d)
        });
        if (!b) {
            v.setSegmentsWithoutPropagation(m)
        } else {
            v.onSegmentsChanged(null, null)
        }
        return true
    },
    merge: function (b, a, d) {
        var c = this;
        c.propagateChanges(function () {
            return c.mergeWithoutPropagation(b, a)
        }, d)
    },
    mergeWithoutPropagation: function (c, a) {
        if (!this.isSegmented() || !c || !a) {
            return
        }
        var d, b;
        if (c.getStartOffset() > a.getStartOffset()) {
            d = a;
            b = c
        } else {
            d = c;
            b = a
        }
        d.setEndDateWithoutPropagation(b.getEndDate(), false);
        return true
    },
    suspendSegmentsTracking: function () {
        this.segmentsTrackingSuspended++
    },
    resumeSegmentsTracking: function () {
        this.segmentsTrackingSuspended--
    },
    getSegmentsDuration: function (e) {
        e = e || this.getDurationUnit();
        var b = this.getSegments();
        var f = 0;
        for (var c = 0, a = b.length; c < a; c++) {
            var d = b[c];
            f += d.getEndOffset() - d.getStartOffset()
        }
        return this.getUnitConverter().convertMSDurationToUnit(f, e)
    },
    mergeOverlappedSegments: function (g) {
        var b = this.getSegments();
        if (b) {
            var d = [], e = b[0], f;
            for (var c = 1, a = b.length; c < a; c++) {
                f = b[c];
                if (f.getStartOffset() <= e.getEndOffset()) {
                    d.push(f);
                    if (f.getEndOffset() > e.getEndOffset()) {
                        e.setEndDateWithoutPropagation(f.getEndDate(), false)
                    }
                } else {
                    f.setPrevSegment(e);
                    e = f
                }
            }
            this.removeSegments(d);
            if (b.length < 2 && !g) {
                this.setSegmentsWithoutPropagation(null)
            } else {
                b[b.length - 1].setNextSegment(null)
            }
        }
    },
    onSegmentEditBegin: function (a) {
        this.snapshotSegments()
    },
    onSegmentsChanged: function (c, b) {
        if (this.segmentsTrackingSuspended) {
            return
        }
        var a = this.getSegments();
        this.changingTaskBySegments = true;
        this.suspendSegmentsTracking();
        this.mergeOverlappedSegments(true);
        a = this.getSegments();
        if (c && b && c.durationField in b) {
            this.setDurationWithoutPropagation(this.getSegmentsDuration())
        } else {
            this.setStartDateWithoutPropagation(this.getStartDate(), true)
        }
        a = this.getSegments();
        this.set(this.segmentsField, a && a.slice() || null);
        this.resumeSegmentsTracking();
        this.changingTaskBySegments = false
    },
    removeSegments: function (d) {
        var b = this.getSegments();
        if (!b || !d || !d.length) {
            return
        }
        if (!Ext.isArray(d)) {
            d = [d]
        }
        for (var c = 0, a = d.length; c < a; c++) {
            Ext.Array.remove(b, d[c])
        }
        this.onSegmentsChanged()
    },
    setSegments: function (b, c) {
        var a = this;
        a.propagateChanges(function () {
            return a.setSegmentsWithoutPropagation(b)
        }, c)
    },
    setSegmentsWithoutPropagation: function (a) {
        this.splitsDuration = 0;
        this.suspendSegmentsTracking();
        var b = this.getSegments();
        this.set(this.segmentsField, this.processSegmentsValue(a));
        if (!this.isSegmented()) {
            if (b) {
                this.removeSegments(b.slice())
            }
        }
        this.resumeSegmentsTracking();
        this.onSegmentsChanged(null, null);
        return true
    },
    processSegmentsValue: function (f) {
        var b, e, d;
        if (f) {
            f = [].concat(f);
            b = [];
            for (var c = 0, a = f.length; c < a; c++) {
                e = f[c];
                if (!(e instanceof Gnt.model.TaskSegment)) {
                    e = Ext.create(this.segmentClassName, Ext.apply(e, {task: this}))
                }
                b.push(e);
                e.setPrevSegment(d);
                d = e
            }
            f = b && b.length > 1 && b || null
        }
        return f
    },
    isSegmented: function () {
        return Boolean(this.getSegments())
    },
    getSegment: function (a) {
        return this.getSegments()[a]
    },
    rejectSegmentsProjection: function () {
        var d = this.getTaskStore(true).getProjectionLevel();
        var b, c;
        if (this.segmentsProjection) {
            var a;
            for (c = d; c >= 0; c--) {
                if (b = this.segmentsProjection[c]) {
                    a = c;
                    break
                }
            }
            if (a === d) {
                delete this.segmentsProjection[a]
            }
        }
        if (b) {
            this.rollbackSegmentsToSnapshot(b)
        }
    },
    commitSegmentsProjection: function () {
        var a = this.getTaskStore(true), b = a && a.getProjectionLevel();
        if (this.segmentsProjection) {
            delete this.segmentsProjection[b]
        }
    },
    rollbackSegmentsToSnapshot: function (a) {
        this.data[this.segmentsField] = a && Ext.Array.map(a, function (b) {
                return b && b[0].readSnapshot(b)
            })
    },
    buildSegmentsSnapshot: function (a) {
        a = a || this.getSegments();
        return a && Ext.Array.map(a, function (b) {
                return b && b.buildSnapshot()
            })
    },
    snapshotSegments: function () {
        var c = this.getTaskStore(true), b = this.getSegments(), d = c && c.getProjectionLevel(), a;
        if (d) {
            this.segmentsProjection = this.segmentsProjection || {};
            a = this.segmentsProjection[d - 1];
            if (!a) {
                a = this.buildSegmentsSnapshot(b);
                this.segmentsProjection[d - 1] = a
            }
        }
        if (!this.segmentsSnapshot) {
            this.segmentsSnapshot = a || this.buildSegmentsSnapshot(b)
        }
    },
    commitSegments: function () {
        if (this.rejecting) {
            return
        }
        this.segmentsSnapshot = null;
        var b = this.getSegments();
        if (b) {
            for (var c = 0, a = b.length; c < a; c++) {
                b[c].commit()
            }
        }
    },
    rejectSegments: function () {
        this.rollbackSegmentsToSnapshot(this.segmentsSnapshot);
        this.segmentsSnapshot = null;
        var b = this.getSegments();
        if (b) {
            for (var c = 0, a = b.length; c < a; c++) {
                b[c].reject()
            }
        }
    }
});
Ext.define("Gnt.model.Task", {
    extend: "Sch.model.Range",
    alias: "gntmodel.event",
    requires: ["Sch.util.Date", "Ext.data.NodeInterface"],
    uses: ["Gnt.model.TaskSegment"],
    mixins: ["Gnt.model.mixin.ProjectableModel", "Gnt.model.task.More", "Gnt.model.task.Constraints", "Gnt.model.task.Splittable"],
    segmentClassName: "Gnt.model.TaskSegment",
    idProperty: "Id",
    customizableFields: [{name: "Duration", type: "number", allowNull: true}, {
        name: "Effort",
        type: "number",
        allowNull: true
    }, {name: "EffortUnit", type: "string", defaultValue: "h"}, {name: "CalendarId", type: "string"}, {
        name: "Note",
        type: "string"
    }, {
        name: "DurationUnit", type: "string", defaultValue: "d", convert: function (a) {
            return a || "d"
        }
    }, {name: "PercentDone", type: "number", defaultValue: 0}, {
        name: "ConstraintType",
        type: "string",
        defaultValue: ""
    }, {name: "ConstraintDate", type: "date", dateFormat: "c"}, {
        name: "ManuallyScheduled",
        type: "boolean",
        defaultValue: false
    }, {name: "SchedulingMode", type: "string", defaultValue: "Normal"}, {
        name: "BaselineStartDate",
        type: "date",
        dateFormat: "c"
    }, {name: "BaselineEndDate", type: "date", dateFormat: "c"}, {
        name: "BaselinePercentDone",
        type: "int",
        defaultValue: 0
    }, {name: "Draggable", type: "boolean", persist: false, defaultValue: true}, {
        name: "Resizable",
        persist: false,
        defaultValue: ""
    },{name: "ReadOnly", type: "boolean", defaultValue: false},
        {name: "Rollup", type: "boolean", defaultValue: false}, {
            name: "Segments",
            persist: true,
            convert: function (b, a) {
                return a.processSegmentsValue(b, a)
            },
            serialize: function (a) {
                if (!a) {
                    return null
                }
                return Ext.Array.map([].concat(a), function (b) {
                    return b.serialize()
                })
            }
        }, {name: "PhantomId", type: "string"}, {name: "PhantomParentId", type: "string"}, {
            name: "index",
            type: "int",
            persist: true
        }],
    constraintTypeField: "ConstraintType",
    constraintDateField: "ConstraintDate",
    draggableField: "Draggable",
    resizableField: "Resizable",
    nameField: "Name",
    durationField: "Duration",
    durationUnitField: "DurationUnit",
    effortField: "Effort",
    effortUnitField: "EffortUnit",
    percentDoneField: "PercentDone",
    manuallyScheduledField: "ManuallyScheduled",
    schedulingModeField: "SchedulingMode",
    rollupField: "Rollup",
    calendarIdField: "CalendarId",
    baselineStartDateField: "BaselineStartDate",
    baselineEndDateField: "BaselineEndDate",
    baselinePercentDoneField: "BaselinePercentDone",
    noteField: "Note",
    segmentsField: "Segments",
    readOnlyField: "ReadOnly",
    calendar: null,
    dependencyStore: null,
    taskStore: null,
    phantomIdField: "PhantomId",
    phantomParentIdField: "PhantomParentId",
    normalized: false,
    recognizedSchedulingModes: ["Normal", "FixedDuration", "EffortDriven", "DynamicAssignment"],
    convertEmptyParentToLeaf: true,
    autoCalculateEffortForParentTask: true,
    autoCalculatePercentDoneForParentTask: true,
    isHighlighted: false,
    calendarWaitingListener: null,
    childTasksDuration: null,
    completedChildTasksDuration: null,
    totalCount: null,
    predecessors: null,
    successors: null,
    removeChildIsCalledFromReplaceChild: false,
    savedDirty: null,
    useOwnCalendarAsConverter: false,
    constructor: function () {
        this._singleProp = {};
        this.initProjectable();
        this.callParent(arguments);
        if (this.phantom) {
            this.data[this.phantomIdField] = this.getId()
        }
        this.predecessors = [];
        this.successors = []
    },
    normalize: function () {
        var h = this.getDurationUnit(), c = this.getStartDate(), g = this.getEndDate(), e = this.data, j = this.getTaskStore(true), f = this.getSchedulingMode();
        if (f == "Manual") {
            f = e[this.schedulingModeField] = "Normal";
            e[this.manuallyScheduledField] = true
        }
        var b = this.endDateField;
        if (j && this.isSegmented()) {
            this.normalizeSegments();
            var m;
            if (m = this.getLastSegment()) {
                g = e[b] = m.getEndDate()
            }
        }
        var d = this.getDuration();
        var k = this.effortField;
        if (g && this.inclusiveEndDate) {
            var l = this.getField(b).dateFormat;
            var a = (l && !Ext.Date.formatContainsHourInfo(l)) || (g.getHours() === 0 && g.getMinutes() === 0 && g.getSeconds() === 0 && g.getMilliseconds() === 0);
            if (a) {
                if (Ext.isNumber(d)) {
                    g = e[b] = this.calculateEndDate(c, d, h)
                } else {
                    g = e[b] = Ext.Date.add(g, Ext.Date.DAY, 1)
                }
            }
        }
        if (d == null && c && g) {
            d = e[this.durationField] = this.calculateDuration(c, g, h)
        }
        if ((f == "Normal" || this.isManuallyScheduled()) && g == null && c && Ext.isNumber(d)) {
            g = e[b] = this.calculateEndDate(c, d, h)
        }
        var o = this.get(k), i = this.getEffortUnit();
        switch (f) {
            case"FixedDuration":
                if (g == null && c && Ext.isNumber(d)) {
                    g = e[b] = this.calculateEndDate(c, d, h)
                }
                if (o == null && c && g) {
                    e[k] = this.calculateEffort(c, g, i)
                }
                break;
            case"EffortDriven":
                if (o == null && c && g) {
                    e[k] = this.calculateEffort(c, g, i)
                }
                if (g == null && c && o) {
                    e[b] = this.calculateEffortDrivenEndDate(c, o, i);
                    if (d == null) {
                        e[this.durationField] = this.calculateDuration(c, e[b], h)
                    }
                }
                break;
            default:
                if (g == null && c && Ext.isNumber(d)) {
                    g = e[b] = this.calculateEndDate(c, d, h)
                }
                break
        }
        var n = this.getCalendarId();
        if (n) {
            this.setCalendarId(n, true)
        }
        this.normalized = true
    },
    getUnitConverter: function () {
        return this.useOwnCalendarAsConverter && this.getCalendar() || this.getProjectCalendar()
    },
    normalizeParent: function () {
        var l = this.childNodes;
        var a = 0;
        var d = 0;
        var h = 0;
        var j = this.autoCalculatePercentDoneForParentTask;
        var f = this.autoCalculateEffortForParentTask;
        for (var e = 0; e < l.length; e++) {
            var c = l[e];
            var b = c.isLeaf();
            if (!b) {
                c.normalizeParent()
            }
            if (f) {
                a += c.getEffort("MILLI")
            }
            if (j) {
                var k = b ? c.getDuration("MILLI") || 0 : c.childTasksDuration;
                d += k;
                h += b ? k * (c.getPercentDone() || 0) : c.completedChildTasksDuration
            }
        }
        if (j) {
            this.childTasksDuration = d;
            this.completedChildTasksDuration = h;
            var g = d ? h / d : 0;
            if (this.getPercentDone() != g) {
                this.data[this.percentDoneField] = g
            }
        }
        if (f) {
            if (this.getEffort("MILLI") != a) {
                this.data[this.effortField] = this.getUnitConverter().convertMSDurationToUnit(a, this.getEffortUnit())
            }
        }
    },
    getCalendar: function (a) {
        return a ? this.getOwnCalendar() : this.getOwnCalendar() || this.parentNode && this.parentNode.getCalendar() || this.getProjectCalendar()
    },
    getOwnCalendar: function () {
        var a = this.get(this.calendarIdField);
        return a ? Gnt.data.Calendar.getCalendar(a) : this.calendar
    },
    getProject: function () {
        var a = this, b = null;
        this.bubble(function (c) {
            if (a !== c && c.isProject) {
                b = c;
                return false
            }
        }, this);
        return b
    },
    getProjectCalendar: function () {
        var a = this.getTaskStore(true);
        var b = a && a.getCalendar() || this.parentNode && this.parentNode.getProjectCalendar() || this.isRoot() && this.calendar;
        if (!b) {
            Ext.Error.raise("Can't find a project calendar in `getProjectCalendar`")
        }
        return b
    },
    setCalendar: function (c, d) {
        var b = this, a = c instanceof Gnt.data.Calendar;
        if (a && !c.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property")
        }
        return b.setCalendarId(a ? c.calendarId : c, false, d)
    },
    setCalendarId: function (b, c, d) {
        var a = this;
        if (!c) {
            a.propagateChanges(function () {
                return a.setCalendarIdWithoutPropagation(b, c)
            }, d)
        } else {
            a.setCalendarIdWithoutPropagation(b, c)
        }
    },
    setCalendarIdWithoutPropagation: function (d, e) {
        var a = false;
        if (d instanceof Gnt.data.Calendar) {
            d = d.calendarId
        }
        var c = this.getCalendarId();
        if (c != d || e) {
            a = true;
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null
            }
            var b = {calendarchange: this.adjustToCalendarWithoutPropagation, scope: this};
            var g = this.calendar || Gnt.data.Calendar.getCalendar(c);
            this.calendar = null;
            g && g.un(b);
            this.set(this.calendarIdField, d);
            var f = Gnt.data.Calendar.getCalendar(d);
            if (f) {
                f.on(b);
                if (!e) {
                    this.adjustToCalendarWithoutPropagation()
                }
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on("add", function () {
                    f = Gnt.data.Calendar.getCalendar(d);
                    if (f) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        f.on(b);
                        this.adjustToCalendarWithoutPropagation()
                    }
                }, this, {destroyable: true})
            }
        }
        return a
    },
    getDependencyStore: function () {
        var b = this.getTaskStore(true), a = b && b.getDependencyStore();
        if (!a) {
            Ext.Error.raise("Can't find a dependencyStore in `getDependencyStore`")
        }
        return a
    },
    getResourceStore: function () {
        var a = this.getTaskStore(true);
        return a && a.getResourceStore()
    },
    getAssignmentStore: function () {
        var a = this.getTaskStore(true);
        return a && a.getAssignmentStore()
    },
    getTaskStore: function (a) {
        var b = this;
        if (!b.taskStore) {
            b.taskStore = b.getTreeStore() || b.parentNode && b.parentNode.getTaskStore(a)
        }
        if (!b.taskStore && !a) {
            Ext.Error.raise("Can't find a taskStore in `getTaskStore`")
        }
        return b.taskStore
    },
    getEventStore: function () {
        return this.getTaskStore()
    },
    setTaskStore: function (a) {
        this.taskStore = a
    },
    isManuallyScheduled: function () {
        return this.get(this.schedulingModeField) === "Manual" || this.get(this.manuallyScheduledField)
    },
    setManuallyScheduled: function (b, c) {
        var a = this;
        a.propagateChanges(function () {
            return a.setManuallyScheduledWithoutPropagation(b)
        }, function (d) {
            d ? a.rejectSegmentsProjection() : a.commitSegmentsProjection();
            c && c.apply(this, arguments)
        })
    },
    setManuallyScheduledWithoutPropagation: function (b) {
        var a = this;
        a.beginEdit();
        this.set(a.manuallyScheduledField, b);
        a.endEdit();
        return true
    },
    setSchedulingMode: function (b, c) {
        var a = this;
        a.propagateChanges(function () {
            return a.setSchedulingModeWithoutPropagation(b)
        }, c)
    },
    setSchedulingModeWithoutPropagation: function (c) {
        var b = this, a;
        if (b.getSchedulingMode() != c) {
            b.set(this.schedulingModeField, c);
            switch (c) {
                case"FixedDuration":
                    b.updateEffortBasedOnDuration();
                    break;
                case"EffortDriven":
                    b.updateSpanBasedOnEffort();
                    break
            }
            var d = b.getPredecessors();
            if (d.length > 0) {
                a = d[0]
            } else {
                a = b
            }
        }
        return a
    },
    skipWorkingTime: function (d, f, e, c) {
        var a;
        var g;
        e = e !== false;
        var b = {
            isForward: e, segments: c || false, resources: this.hasResources(), fn: function (k, j) {
                var i = j - k, h = new Date(k).getTimezoneOffset() - new Date(j).getTimezoneOffset();
                if (i >= g) {
                    a = new Date((e ? k : j) - 0 + (e ? 1 : -1) * g);
                    return false
                } else {
                    g -= i + h * 60 * 1000
                }
            }
        };
        if (Ext.isObject(d)) {
            Ext.apply(b, d)
        } else {
            if (e) {
                b.startDate = d
            } else {
                b.endDate = d
            }
        }
        g = f || b.duration;
        if (!g) {
            return d
        }
        this.forEachAvailabilityInterval(b);
        return a
    },
    skipNonWorkingTime: function (d, e, c) {
        var b = false;
        e = e !== false;
        var a = {
            isForward: e, segments: c || false, resources: this.hasResources(), fn: function (g, f) {
                if (g !== f) {
                    d = e ? g : f;
                    b = true;
                    return false
                }
            }
        };
        if (Ext.isObject(d)) {
            Ext.apply(a, d)
        } else {
            if (e) {
                a.startDate = d
            } else {
                a.endDate = d
            }
        }
        this.forEachAvailabilityInterval(a);
        return b ? new Date(d) : this.getCalendar().skipNonWorkingTime(d, e)
    },
    setStartDate: function (a, e, d, c) {
        var b = this;
        b.propagateChanges(function () {
            return b.setStartDateWithoutPropagation(a, e, d)
        }, function (f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            c && c.apply(this, arguments)
        })
    },
    setStartDateWithoutPropagation: function (b, h, g) {
        var c = this, a = c.getTaskStore(true), e, d;
        h = h !== false;
        if (a && g !== true && g !== false) {
            g = a.skipWeekendsDuringDragDrop
        } else {
            if (g !== true && g !== false) {
                g = false
            }
        }
        c.beginEdit();
        if (!b) {
            c.set(c.durationField, null);
            c.set(c.startDateField, null);
            c.setSegments(null)
        } else {
            if (g) {
                b = c.skipNonWorkingTime(b, !c.isMilestone())
            }
            var f = c.getStartDate();
            c.set(c.startDateField, b);
            if (a && c.isSegmented()) {
                c.updateSegmentsDates()
            }
            if (h !== false) {
                c.set(c.endDateField, c.recalculateEndDate(b))
            } else {
                d = this.getEndDate();
                if (d) {
                    this.constrainSegments();
                    c.set(c.durationField, c.calculateDuration(b, d, c.getDurationUnit()))
                }
            }
        }
        e = c.getDuration();
        d = c.getEndDate();
        if (b && d && (e === undefined || e === null)) {
            c.set(c.durationField, c.calculateDuration(b, d, c.getDurationUnit()))
        }
        c.onPotentialEffortChange();
        c.endEdit();
        return true
    },
    setEndDate: function (a, e, d, c) {
        var b = this;
        b.propagateChanges(function () {
            return b.setEndDateWithoutPropagation(a, e, d)
        }, function (f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            c && c.apply(this, arguments)
        })
    },
    setEndDateWithoutPropagation: function (e, c, d) {
        var i = this, j = i.getTaskStore(true), g, b;
        c = c !== false;
        if (d !== true && d !== false && j) {
            d = j.skipWeekendsDuringDragDrop
        } else {
            if (d !== true && d !== false) {
                d = false
            }
        }
        i.beginEdit();
        var h = i.getEndDate();
        if (!e) {
            i.set(i.durationField, null);
            i.set(i.endDateField, null);
            i.setSegments(null)
        } else {
            b = i.getStartDate();
            if (e < b && c === false) {
                e = b
            }
            if (d) {
                e = i.skipNonWorkingTime(e, false)
            }
            if (c !== false) {
                g = i.getDuration();
                if (Ext.isNumber(g)) {
                    if (j && i.isSegmented() && (e - h)) {
                        i.updateSegmentsDates({isForward: false, endDate: e})
                    }
                    i.set(i.startDateField, i.calculateStartDate(e, g, i.getDurationUnit()));
                    i.set(i.endDateField, e)
                } else {
                    i.set(i.endDateField, e)
                }
            } else {
                var f = i.isMilestone();
                if (e < b) {
                    i.set(i.startDateField, e)
                }
                i.set(i.endDateField, e);
                i.constrainSegments();
                if (b) {
                    i.set(i.durationField, i.calculateDuration(b, e, i.getDurationUnit()));
                    if (f && !i.isMilestone()) {
                        var a = i.skipNonWorkingTime(b, true);
                        if (a - b !== 0) {
                            i.set(i.startDateField, a)
                        }
                    }
                }
            }
        }
        g = i.getDuration();
        b = i.getStartDate();
        if (e && b && (g === undefined || g === null)) {
            i.set(i.durationField, i.calculateDuration(b, e, i.getDurationUnit()))
        }
        i.onPotentialEffortChange();
        i.endEdit();
        return true
    },
    setStartEndDate: function (a, c, e, d) {
        var b = this;
        e = e || false;
        b.propagateChanges(function () {
            return b.setStartEndDateWithoutPropagation(a, c, e)
        }, function (f, g) {
            if (f) {
                b.rejectSegmentsProjection()
            } else {
                b.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setStartEndDateWithoutPropagation: function (a, e, g) {
        var c = this, b = c.getTaskStore(true);
        if (g !== true && g !== false && b) {
            g = b.skipWeekendsDuringDragDrop
        } else {
            if (g !== true && g !== false) {
                g = false
            }
        }
        if (g) {
            a = a && c.skipNonWorkingTime(a, true);
            e = e && c.skipNonWorkingTime(e, false);
            if (e < a) {
                a = e
            }
        }
        var f = c.getStartDate(), d = c.getEndDate();
        c.beginEdit();
        c.set(c.startDateField, a);
        c.set(c.endDateField, e);
        if (c.getTaskStore(true) && c.isSegmented() && ((a - f) || (e - d))) {
            c.updateSegmentsDates()
        }
        if (e - d) {
            c.constrainSegments()
        }
        c.set(c.durationField, c.calculateDuration(a, e, c.getDurationUnit()));
        c.onPotentialEffortChange();
        c.endEdit();
        return true
    },
    shift: function (c, a, d) {
        var b = this;
        b.setStartEndDate(Sch.util.Date.add(b.getStartDate(), c, a), Sch.util.Date.add(b.getEndDate(), c, a), undefined, d)
    },
    getDuration: function (b) {
        if (!b) {
            return this.get(this.durationField)
        }
        var a = this.getUnitConverter(), c = a.convertDurationToMs(this.get(this.durationField), this.get(this.durationUnitField));
        return a.convertMSDurationToUnit(c, b)
    },
    getEffort: function (b) {
        var c = this.get(this.effortField) || 0;
        if (!b) {
            return c
        }
        var a = this.getUnitConverter(), d = a.convertDurationToMs(c, this.getEffortUnit());
        return a.convertMSDurationToUnit(d, b)
    },
    setEffort: function (c, b, d) {
        var a = this;
        a.propagateChanges(function () {
            return a.setEffortWithoutPropagation(c, b)
        }, function (e) {
            if (e) {
                a.rejectSegmentsProjection()
            } else {
                a.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setEffortWithoutPropagation: function (c, b) {
        var a = this;
        b = b || a.getEffortUnit();
        a.beginEdit();
        a.set(a.effortField, c);
        a.set(a.effortUnitField, b);
        switch (a.getSchedulingMode()) {
            case"EffortDriven":
                a.updateSpanBasedOnEffort();
                break;
            case"DynamicAssignment":
                a.updateAssignments();
                break
        }
        a.endEdit();
        return true
    },
    getCalendarDuration: function (a) {
        return this.getUnitConverter().convertMSDurationToUnit(this.getEndDate() - this.getStartDate(), a || this.get(this.durationUnitField))
    },
    setDuration: function (c, b, d) {
        var a = this;
        a.propagateChanges(function () {
            return a.setDurationWithoutPropagation(c, b)
        }, function (e) {
            if (e) {
                a.rejectSegmentsProjection()
            } else {
                a.commitSegmentsProjection()
            }
            d && d.apply(this, arguments)
        })
    },
    setDurationWithoutPropagation: function (d, j) {
        var h = this;
        j = j || h.getDurationUnit();
        var e = h.isMilestone();
        h.beginEdit();
        if (Ext.isNumber(d) && !h.getStartDate()) {
            var i = h.getTaskStore(true);
            var b = (i && i.getProjectStartDate()) || Ext.Date.clearTime(new Date());
            h.setStartDateWithoutPropagation(b)
        }
        var f = null;
        this.constrainSegments({duration: d, unit: j});
        if (Ext.isNumber(d)) {
            f = h.calculateEndDate(h.getStartDate(), d, j)
        }
        h.set(h.endDateField, f);
        h.set(h.durationField, d);
        h.set(h.durationUnitField, j);
        if (h.isMilestone() != e) {
            if (e) {
                var c = h.getStartDate();
                if (c) {
                    var a = h.skipNonWorkingTime(c, true);
                    if (a - c !== 0) {
                        h.set(h.startDateField, a)
                    }
                }
            } else {
                if (f) {
                    var g = h.skipNonWorkingTime(f, false);
                    if (g - f !== 0) {
                        h.set(h.startDateField, g);
                        h.set(h.endDateField, g)
                    }
                }
            }
        }
        h.onPotentialEffortChange();
        h.endEdit();
        return true
    },
    calculateStartDate: function (g, f, e, c) {
        e = e || this.getDurationUnit();
        if (!f) {
            return g
        }
        c = Ext.apply({endDate: g, isForward: false, resources: this.hasResources()}, c);
        var d = this.getSchedulingMode();
        if (this.getTaskStore(true) && d != "FixedDuration" && d != "DynamicAssignment" && d != "EffortDriven") {
            var b = this.getUnitConverter().convertDurationToMs(f, e);
            var a;
            this.forEachAvailabilityInterval(c, function (k, j) {
                var i = j - k;
                if (i >= b) {
                    a = new Date(j - b);
                    return false
                } else {
                    var h = new Date(j).getTimezoneOffset() - new Date(k).getTimezoneOffset();
                    b -= i + h * 60 * 1000
                }
            });
            return a
        } else {
            return this.getCalendar().calculateStartDate(g, f, e)
        }
    },
    recalculateEndDate: function (b) {
        var c = this, a, d;
        b = b || c.getStartDate();
        if (b && c.getSchedulingMode() == "EffortDriven") {
            a = c.calculateEffortDrivenEndDate(b, c.getEffort())
        } else {
            d = c.getDuration();
            if (b && Ext.isNumber(d)) {
                a = c.calculateEndDate(b, d, c.getDurationUnit())
            } else {
                a = c.getEndDate()
            }
        }
        return a
    },
    calculateEndDate: function (a, g, e, c) {
        e = e || this.getDurationUnit();
        if (!g) {
            return a
        }
        c = Ext.apply({startDate: a}, c);
        var d = this.getSchedulingMode(), f;
        if (this.getTaskStore(true) && d != "FixedDuration" && d != "DynamicAssignment" && d != "EffortDriven") {
            var b = this.getUnitConverter().convertDurationToMs(g, e);
            c.resources = this.hasResources();
            this.forEachAvailabilityInterval(c, function (k, j) {
                var i = j - k;
                if (i >= b) {
                    f = new Date(k + b);
                    return false
                } else {
                    var h = new Date(k).getTimezoneOffset() - new Date(j).getTimezoneOffset();
                    b -= i + h * 60 * 1000
                }
            })
        } else {
            return this.getCalendar().calculateEndDate(a, g, e)
        }
        return f
    },
    calculateDuration: function (a, d, c, b) {
        c = c || this.getDurationUnit();
        if (!a || !d) {
            return 0
        }
        if (this.getTaskStore(true)) {
            var e = 0;
            this.forEachAvailabilityInterval(Ext.apply({
                startDate: a,
                endDate: d,
                resources: this.hasResources()
            }, b), function (h, g) {
                var f = new Date(h).getTimezoneOffset() - new Date(g).getTimezoneOffset();
                e += g - h + f * 60 * 1000
            });
            return this.getUnitConverter().convertMSDurationToUnit(e, c)
        } else {
            return this.getCalendar().calculateDuration(a, d, c)
        }
    },
    isCalendarApplicable: function (j) {
        var b = this.getStartDate();
        if (!b) {
            return true
        }
        var h = this.getTaskStore(true);
        if (!h) {
            return true
        }
        var g = Sch.util.Date.add(b, "d", (h && h.availabilitySearchLimit) || 5 * 365);
        var a = this.getAssignments();
        var c = [];
        Ext.Array.forEach(a, function (k) {
            var i = k.getResource();
            if (i) {
                c.push(i.getCalendar())
            }
        });
        if (!c.length) {
            return true
        }
        var e = Gnt.data.Calendar.getCalendar(j);
        for (var f = 0, d = c.length; f < d; f++) {
            if (e.isAvailabilityIntersected(c[f], b, g)) {
                return true
            }
        }
        return false
    },
    forEachAvailabilityInterval: function (z, u, L) {
        u = u || z.fn;
        L = L || z.scope || this;
        var s = this, e = z.startDate, w = z.endDate, D = z.includeEmptyIntervals, aa = z.resources, O = z.segments || (z.segments !== false), t = z.isForward !== false, j = Sch.util.Date, P = this.getStartDate(), V = this.getEndDate(), y, h;
        var a = this.getTaskStore(true);
        if (t) {
            if (!e) {
                throw new Error("forEachAvailabilityInterval: `startDate` is required when `isForward` is true")
            }
            if (!w) {
                w = j.add(e, "d", z.availabilitySearchLimit || (a && a.availabilitySearchLimit) || 5 * 365)
            }
            y = new Date(e)
        } else {
            if (!w) {
                throw new Error("forEachAvailabilityInterval: `endDate` is required when `isForward` is false")
            }
            if (!e) {
                e = j.add(w, "d", -(z.availabilitySearchLimit || (a && a.availabilitySearchLimit) || 5 * 365))
            }
            y = new Date(w)
        }
        var F = this.getOwnCalendar(), Z = this.getProjectCalendar(), f = {}, x = [];
        if (aa) {
            var H = false;
            var p = z.assignments;
            var r = function (i) {
                var n = i.getId(), l = p && Ext.Array.findBy(p, function (ab) {
                        return ab.getResourceId() == n
                    }) || s.getAssignmentFor(i), k = i.getCalendar(), m = k.getCalendarId();
                if (!f[m]) {
                    f[m] = [];
                    x.push(k)
                }
                f[m].push({assignment: l, resourceId: n, units: l && l.getUnits()});
                H = true
            };
            if (aa !== true) {
                Ext.each(aa, r)
            } else {
                Ext.Array.forEach(this.getAssignments(), function (k) {
                    var i = k.getResource();
                    if (i) {
                        r(i)
                    }
                })
            }
            if (!H) {
                return
            }
        } else {
            F = F || Z
        }
        if (O) {
            if (!Ext.isArray(O)) {
                h = this.getSegments()
            } else {
                h = O
            }
        }
        var X, W, T, b, Y, C;
        while (t ? y < w : y > e) {
            var A = {};
            var g = [];
            var J = y - (t ? 0 : 1);
            if (F) {
                var K = F.getAvailabilityIntervalsFor(J);
                for (W = 0, T = K.length; W < T; W++) {
                    b = K[W];
                    Y = b.startDate - 0;
                    C = b.endDate - 0;
                    if (!A[Y]) {
                        A[Y] = [];
                        g.push(Y)
                    }
                    A[Y].push({type: "00-taskAvailailabilityStart", typeBackward: "01-taskAvailailabilityStart"});
                    g.push(C);
                    A[C] = A[C] || [];
                    A[C].push({type: "01-taskAvailailabilityEnd", typeBackward: "00-taskAvailailabilityEnd"})
                }
            }
            if (h) {
                var o, d;
                if (t) {
                    o = y;
                    d = j.getStartOfNextDay(y)
                } else {
                    o = j.getEndOfPreviousDay(y);
                    d = y
                }
                var q = this.getSegmentIntervalsForRange(o, d, h);
                if (q) {
                    for (X = 0, T = q.length; X < T; X++) {
                        Y = q[X][0];
                        C = q[X][1];
                        if (!A[Y]) {
                            A[Y] = [];
                            g.push(Y)
                        }
                        A[Y].push({type: "04-taskSegmentStart", typeBackward: "05-taskSegmentStart"});
                        g.push(C);
                        A[C] = A[C] || [];
                        A[C].push({type: "05-taskSegmentEnd", typeBackward: "04-taskSegmentEnd"})
                    }
                }
            }
            var U;
            for (X = 0, T = x.length; X < T; X++) {
                var N = x[X], B = N.getAvailabilityIntervalsFor(J);
                U = f[N.getCalendarId()];
                for (W = 0; W < B.length; W++) {
                    b = B[W];
                    Y = b.startDate - 0;
                    C = b.endDate - 0;
                    if (!A[Y]) {
                        A[Y] = [];
                        g.push(Y)
                    }
                    A[Y].push({
                        type: "02-resourceAvailailabilityStart",
                        typeBackward: "03-resourceAvailailabilityStart",
                        resources: U
                    });
                    if (!A[C]) {
                        A[C] = [];
                        g.push(C)
                    }
                    A[C].push({
                        type: "03-resourceAvailailabilityEnd",
                        typeBackward: "02-resourceAvailailabilityEnd",
                        resources: U
                    })
                }
            }
            g.sort(function (k, i) {
                return k - i
            });
            var I = !P || !V || (y >= P && y <= V), c = false, v = false, S = {}, G = 0, M, E, R, Q;
            if (t) {
                for (X = 0, T = g.length; X < T; X++) {
                    M = A[g[X]];
                    M.sort(function (k, i) {
                        return k.type < i.type ? 1 : -1
                    });
                    for (W = 0; W < M.length; W++) {
                        E = M[W];
                        switch (E.type) {
                            case"00-taskAvailailabilityStart":
                                c = true;
                                break;
                            case"01-taskAvailailabilityEnd":
                                c = false;
                                break;
                            case"02-resourceAvailailabilityStart":
                                U = E.resources;
                                for (R = 0, Q = U.length; R < Q; R++) {
                                    S[U[R].resourceId] = U[R];
                                    G++
                                }
                                break;
                            case"03-resourceAvailailabilityEnd":
                                U = E.resources;
                                for (R = 0, Q = U.length; R < Q; R++) {
                                    delete S[U[R].resourceId];
                                    G--
                                }
                                break;
                            case"04-taskSegmentStart":
                                v = true;
                                break;
                            case"05-taskSegmentEnd":
                                v = false;
                                break
                        }
                    }
                    if ((c || !F) && (!h || !I || v) && (!aa || G || D)) {
                        Y = g[X];
                        C = g[X + 1];
                        if (Y >= w || C <= e) {
                            continue
                        }
                        if (Y < e) {
                            Y = e - 0
                        }
                        if (C > w) {
                            C = w - 0
                        }
                        if (u.call(L, Y, C, S) === false) {
                            return false
                        }
                    }
                }
            } else {
                for (X = g.length - 1; X >= 0; X--) {
                    M = A[g[X]];
                    M.sort(function (k, i) {
                        return k.typeBackward < i.typeBackward ? 1 : -1
                    });
                    for (W = 0; W < M.length; W++) {
                        E = M[W];
                        switch (E.typeBackward) {
                            case"00-taskAvailailabilityEnd":
                                c = true;
                                break;
                            case"01-taskAvailailabilityStart":
                                c = false;
                                break;
                            case"02-resourceAvailailabilityEnd":
                                U = E.resources;
                                for (R = 0, Q = U.length; R < Q; R++) {
                                    S[U[R].resourceId] = U[R];
                                    G++
                                }
                                break;
                            case"03-resourceAvailailabilityStart":
                                U = E.resources;
                                for (R = 0, Q = U.length; R < Q; R++) {
                                    delete S[U[R].resourceId];
                                    G--
                                }
                                break;
                            case"04-taskSegmentEnd":
                                v = true;
                                break;
                            case"05-taskSegmentStart":
                                v = false;
                                break
                        }
                    }
                    if ((c || !F) && (!h || !I || v) && (!aa || G || D)) {
                        Y = g[X - 1];
                        C = g[X];
                        if (Y > w || C <= e) {
                            continue
                        }
                        if (Y < e) {
                            Y = e - 0
                        }
                        if (C > w) {
                            C = w - 0
                        }
                        if (u.call(L, Y, C, S) === false) {
                            return false
                        }
                    }
                }
            }
            y = t ? j.getStartOfNextDay(y) : j.getEndOfPreviousDay(y)
        }
    },
    forEachAvailabilityIntervalWithResources: function (a, c, b) {
        if (!a.resources) {
            a.resources = true
        }
        this.forEachAvailabilityInterval.apply(this, arguments)
    },
    calculateEffortDrivenEndDate: function (a, c, b) {
        if (!c) {
            return a
        }
        var e = this.getUnitConverter().convertDurationToMs(c, b || this.getEffortUnit());
        var d = new Date(a);
        this.forEachAvailabilityIntervalWithResources({startDate: a}, function (l, k, j) {
            var m = 0;
            for (var h in j) {
                m += j[h].units
            }
            var g = k - l;
            var f = m * g / 100;
            if (f >= e) {
                d = new Date(l + e / f * g);
                return false
            } else {
                e -= f
            }
        });
        return d
    },
    refreshCalculatedParentNodeData: function () {
        var v = this.autoCalculatePercentDoneForParentTask;
        var j = this.autoCalculateEffortForParentTask;
        var a = this.childNodes;
        var d = a.length;
        var f = {};
        if (d > 0 && (j || v)) {
            var h = 0;
            var p = 0;
            var s = 0;
            for (var t = 0; t < d; t++) {
                var b = a[t];
                if (b.parentNode) {
                    var w = b.isLeaf();
                    if (j) {
                        h += b.getEffort("MILLI")
                    }
                    if (v) {
                        var c = w ? b.getDuration("MILLI") || 0 : b.childTasksDuration;
                        p += c;
                        s += w ? c * (b.getPercentDone() || 0) : b.completedChildTasksDuration
                    }
                }
            }
            if (j && this.getEffort("MILLI") != h) {
                f.Effort = true;
                this.setEffortWithoutPropagation(this.getUnitConverter().convertMSDurationToUnit(h, this.getEffortUnit()))
            }
            if (v) {
                this.childTasksDuration = p;
                this.completedChildTasksDuration = s;
                var q = p ? s / p : 0;
                if (this.getPercentDone() != q) {
                    f.PercentDone = true;
                    this.setPercentDone(q)
                }
            }
        }
        var e, n;
        if (!this.isRoot() && d > 0 && !this.isManuallyScheduled()) {
            var g = new Date(-8640000000000000), l = new Date(+8640000000000000), m = new Date(+8640000000000000), y = new Date(-8640000000000000);
            for (var u = 0; u < d; u++) {
                var o = a[u];
                m = Sch.util.Date.min(m, o.getStartDate() || m);
                y = Sch.util.Date.max(y, o.getEndDate() || y)
            }
            if (y < m && m < l && y > g) {
                var x;
                x = y;
                y = m;
                m = x
            }
            e = f.StartDate = m - l !== 0 && this.getStartDate() - m !== 0;
            n = f.EndDate = y - g !== 0 && this.getEndDate() - y !== 0;
            if (e && n) {
                this.setStartEndDateWithoutPropagation(m, y, false)
            } else {
                if (e) {
                    this.setStartDateWithoutPropagation(m, false, false)
                } else {
                    if (n) {
                        this.setEndDateWithoutPropagation(y, false, false)
                    }
                }
            }
        }
        return f
    },
    recalculateParents: function () {
        var a = this.parentNode;
        a && (a.refreshCalculatedParentNodeData(), !this.getTaskStore().cascading && a.recalculateParents())
    },
    recalculateAllParents: function () {
        var c = this.parentNode, b = false, d;
        if (c) {
            d = c.refreshCalculatedParentNodeData();
            for (var a in d) {
                if (d[a]) {
                    b = true;
                    break
                }
            }
            b && c.recalculateAllParents()
        }
    },
    isMilestone: function (b) {
        if (b) {
            return this.isBaselineMilestone()
        }
        if (!this.get("leaf")) {
            var a = this.getStartDate(), c = this.getEndDate();
            if (a && c) {
                return c - a === 0
            }
        }
        return this.getDuration() === 0
    },
    convertToMilestone: function (b) {
        var a = this;
        a.propagateChanges(function () {
            return a.convertToMilestoneWithoutPropagation()
        }, b)
    },
    convertToMilestoneWithoutPropagation: function () {
        var b = this, a = false;
        if (!b.isMilestone()) {
            b.setStartDateWithoutPropagation(b.getEndDate(), false);
            b.setDurationWithoutPropagation(0);
            a = true
        }
        return a
    },
    convertToRegular: function (b) {
        var a = this;
        a.propagateChanges(function () {
            return a.convertToRegularWithoutPropagation()
        }, b)
    },
    convertToRegularWithoutPropagation: function () {
        var d = this, b = false, c, a;
        if (d.isMilestone()) {
            c = d.get(d.durationUnitField);
            a = d.calculateStartDate(d.getStartDate(), 1, c);
            d.setDurationWithoutPropagation(1, c);
            d.setStartDateWithoutPropagation(a, true, false, false);
            b = true
        }
        return b
    },
    isBaselineMilestone: function () {
        var b = this.getBaselineStartDate(), a = this.getBaselineEndDate();
        if (b && a) {
            return a - b === 0
        }
        return false
    },
    markAsParent: function () {
        var a = this;
        a.isSegmented() && a.setSegmentsWithoutPropagation(null);
        a.set("leaf", false)
    },
    getDurationUnit: function () {
        return this.get(this.durationUnitField) || "d"
    },
    getEffortUnit: function () {
        return this.get(this.effortUnitField) || "h"
    },
    getBaselinePercentDone: function () {
        return this.get(this.baselinePercentDoneField) || 0
    },
    isPersistable: function () {
        var a = this.parentNode;
        return !a || !a.phantom || a.isRoot()
    },
    getResources: function () {
        var a = this, b = a.getAssignmentStore();
        return b && b.getResourcesForEvent(a) || []
    },
    getAssignments: function () {
        var a = this, b = a.getAssignmentStore();
        return b && b.getAssignmentsForTask(a) || []
    },
    hasAssignments: function () {
        return this.getAssignments().length > 0
    },
    hasResources: function () {
        var c = this.getAssignments(), b = false, d, a;
        for (d = 0, a = c.length; !b && d < a; d++) {
            b = !!c[d].getResource()
        }
        return b
    },
    getAssignmentFor: function (b) {
        var a = this, c = a.getAssignmentStore();
        return c && c.getAssignmentForEventAndResource(a, b) || null
    },
    isAssignedTo: function (b) {
        var a = this, c = a.getAssignmentStore();
        return c && c.isTaskAssignedToResource(a, b) || false
    },
    assign: function (e, b, g) {
        var d = this, a, c;
        d.propagateChanges(function () {
            return d.assignWithoutPropagation(e, b, function h(j, i) {
                c = j;
                a = i
            })
        }, function f(i, h) {
            i && c && c();
            g && g(i, h)
        });
        return a
    },
    assignWithoutPropagation: function (b, f, e) {
        var g = this, j = [], h = g.getTaskStore(), d = h.getAssignmentStore(), i = h.getResourceStore(), a, c;
        f = f || 100;
        !g.getAssignmentFor(b) || Ext.Error.raise("Resource can't be assigned twice to the same task");
        if (b instanceof Gnt.model.Resource && i.indexOf(b) == -1) {
            c = b.getId();
            i.add(b);
            j.push(function () {
                i.remove(b)
            })
        } else {
            if (b instanceof Gnt.model.Resource) {
                c = b.getId()
            } else {
                if (i.indexOfId(b) >= 0) {
                    c = b
                }
            }
        }
        a = d.assignTaskToResource(g, c, f);
        j.push(function () {
            d.unassignTaskFromResource(g, c)
        });
        e && e(function () {
            Ext.Array.forEach(j, function (k) {
                k()
            })
        }, a[0]);
        return true
    },
    unassign: function () {
        return this.unAssign.apply(this, arguments)
    },
    unAssign: function (c, e) {
        var b = this, a;
        b.propagateChanges(function () {
            return b.unassignWithoutPropagation(c, function f(g) {
                a = g
            })
        }, function d(g, f) {
            g && a && a();
            e && e(g, f)
        })
    },
    unassignWithoutPropagation: function (c, a) {
        var b = this, g = c instanceof Gnt.model.Resource ? c.getId() : c, d = b.getAssignmentStore(), f = b.getAssignmentFor(g), e;
        e = d.indexOf(f);
        d.unassignTaskFromResource(b, c);
        a && a(function () {
            d.insert(e, f)
        });
        return true
    },
    reassign: function (a, b, g) {
        var d = this, e, c;
        d.propagateChanges(function () {
            var j = d.getAssignmentFor(a).getUnits();
            d.unassignWithoutPropagation(a, function i(k) {
                e = k
            });
            d.assignWithoutPropagation(b, j, function h(k) {
                c = k
            });
            return true
        }, function f(i, h) {
            if (i) {
                c && c();
                e && e()
            }
            g && g(i, h)
        })
    },
    linkTo: function (a, c, g, e) {
        var d = this, b;
        d.propagateChanges(function () {
            return d.linkToWithoutPropagation(a, c, function h(i) {
                b = i
            }, e)
        }, function f(i, h) {
            i && b && b();
            g && g(i, h)
        })
    },
    linkToWithoutPropagation: function (c, h, a, f) {
        var g = this, e = g.getId(), i = g.getTaskStore(), b = g.getDependencyStore(), d;
        c = c instanceof Gnt.model.Task ? c.getId() : c;
        h = ((h === null || h === undefined) && Gnt.model.Dependency.Type.EndToStart) || h;
        d = new b.model();
        d.setSourceId(e);
        d.setTargetId(c);
        d.setType(h);
        if (b.isValidDependency(d) && (!f || f(d) !== false)) {
            b.add(d)
        }
        a && a(function () {
            b.remove(d)
        });
        return g
    },
    unlinkFrom: function (a, e) {
        var c = this, b;
        c.propagateChanges(function () {
            return c.unlinkFromWithoutPropagation(a, function f(g) {
                b = g
            })
        }, function d(g, f) {
            g && b && b();
            e && e(g, f)
        })
    },
    unlinkFromWithoutPropagation: function (d, e) {
        var g = this, a = g.getId(), c = g.getDependencyStore(), b, f;
        d = d instanceof Gnt.model.Task ? d.getId() : d;
        b = c.getByTaskIds(d, a);
        f = c.indexOf(b);
        c.remove(b);
        e && e(function () {
            c.insert(f, b)
        });
        return g
    },
    calculateEffort: function (a, c, b) {
        if (!a || !c) {
            return 0
        }
        var d = 0;
        this.forEachAvailabilityIntervalWithResources({startDate: a, endDate: c}, function (h, g, f) {
            var j = 0;
            for (var e in f) {
                j += f[e].units
            }
            d += (g - h) * j / 100
        });
        return this.getUnitConverter().convertMSDurationToUnit(d, b || this.getEffortUnit())
    },
    updateAssignments: function () {
        var a = this.getStartDate();
        var c = this.getEndDate();
        if (!a || !c) {
            return
        }
        var b = 0;
        this.forEachAvailabilityIntervalWithResources({startDate: a, endDate: c}, function (g, f, e) {
            for (var h in e) {
                b += f - g
            }
        });
        if (!b) {
            return
        }
        var d = this.getEffort(Sch.util.Date.MILLI);
        Ext.Array.each(this.getAssignments(), function (e) {
            e.setUnits(d / b * 100)
        })
    },
    updateEffortBasedOnDuration: function () {
        this.setEffortWithoutPropagation(this.calculateEffort(this.getStartDate(), this.getEndDate()))
    },
    updateEffortBasedOnSpan: function () {
        this.updateEffortBasedOnDuration()
    },
    updateSpanBasedOnEffort: function () {
        this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate())
    },
    onPotentialEffortChange: function () {
        switch (this.getSchedulingMode()) {
            case"FixedDuration":
                this.updateEffortBasedOnDuration();
                break;
            case"DynamicAssignment":
                this.updateAssignments();
                break
        }
    },
    onAssignmentMutation: function () {
        switch (this.getSchedulingMode()) {
            case"FixedDuration":
                this.updateEffortBasedOnDuration();
                break;
            case"EffortDriven":
                this.updateSpanBasedOnEffort();
                break;
            case"DynamicAssignment":
                this.updateAssignments();
                break
        }
    },
    onAssignmentStructureMutation: function () {
        switch (this.getSchedulingMode()) {
            case"FixedDuration":
                this.updateEffortBasedOnDuration();
                break;
            case"EffortDriven":
                this.updateSpanBasedOnEffort();
                break;
            case"DynamicAssignment":
                this.updateAssignments();
                break
        }
    },
    adjustToCalendar: function (b) {
        var a = this;
        a.propagateChanges(function () {
            return a.adjustToCalendarWithoutPropagation()
        }, b)
    },
    adjustToCalendarWithoutPropagation: function () {
        var c = this, b = c.getTaskStore(true), a = false;
        if (c.taskStore) {
            if (c.get("leaf")) {
                c.setStartDateWithoutPropagation(c.getStartDate(), true, b.skipWeekendsDuringDragDrop);
                c.alignByIncomingDependenciesWithoutPropagation(b, null);
                a = this
            } else {
                if (c.getStartDate() && c.getEndDate()) {
                    c.set(c.durationField, c.calculateDuration(c.getStartDate(), c.getEndDate(), c.getDurationUnit()));
                    a = this
                }
            }
        }
        return a
    },
    isReadOnly: function (a) {
        var b;
        if (!a) {
            b = this.getProject()
        }
        return b && b.getReadOnly() || this.getReadOnly()
    },
    isEditable: function (b) {
        if (!this.isProject) {
            var a = this.getProject();
            if (a && a.isReadOnly()) {
                return false
            }
        }
        if (b === this.readOnlyField) {
            return true
        }
        if (this.isReadOnly(true)) {
            return false
        }
        if (!this.isLeaf()) {
            if (b === this.effortField && this.autoCalculateEffortForParentTask) {
                return false
            }
            if (b === this.percentDoneField && this.autoCalculatePercentDoneForParentTask) {
                return false
            }
        }
        if ((b === this.durationField || b === this.endDateField) && this.getSchedulingMode() === "EffortDriven") {
            return false
        }
        if (b === this.effortField && this.getSchedulingMode() === "FixedDuration") {
            return false
        }
        return true
    },
    isDraggable: function () {
        return this.getDraggable()
    },
    isResizable: function () {
        return this.getResizable()
    },
    getWBSCode: function () {
        var b = [], a = this;
        while (a.parentNode) {
            b.push(a.data.index + 1);
            a = a.parentNode
        }
        return b.reverse().join(".")
    },
    resetTotalCount: function (b) {
        var a = this;
        while (a) {
            a.totalCount = b ? -1 : null;
            a = a.parentNode
        }
    },
    getTotalCount: function () {
        var b = this.totalCount;
        var c = b == -1;
        if (b == null || c) {
            var e = this.childNodes;
            b = e.length;
            for (var d = 0, a = e.length; d < a; d++) {
                b += e[d].getTotalCount()
            }
            if (c) {
                return b
            } else {
                this.totalCount = b
            }
        }
        return b
    },
    getPreviousSiblingsTotalCount: function () {
        var a = this.previousSibling, b = this.data.index;
        while (a) {
            b += a.getTotalCount();
            a = a.previousSibling
        }
        return b
    },
    getPredecessorsCount: function () {
        return this.getPreviousSiblingsTotalCount.apply(this, arguments)
    },
    getSequenceNumber: function () {
        var b = 0, a = this;
        while (a.parentNode) {
            b += a.getPredecessorsCount() + 1;
            a = a.parentNode
        }
        return b
    },
    getBySequenceNumber: function (f) {
        var c = null, e, b;
        if (f === 0) {
            c = this
        } else {
            if (f > 0 && f <= this.getTotalCount()) {
                f--;
                for (var d = 0, a = this.childNodes.length; d < a; d++) {
                    e = this.childNodes[d];
                    b = e.getTotalCount();
                    if (f > b) {
                        f -= b + 1
                    } else {
                        e = this.childNodes[d];
                        c = e.getBySequenceNumber(f);
                        break
                    }
                }
            }
        }
        return c
    },
    getDisplayStartDate: function (e, c, d, a, b) {
        e = e || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            d = this.getStartDate();
            if (arguments.length < 2) {
                c = true
            }
        }
        if (d && c && this.isMilestone(b) && d - Ext.Date.clearTime(d, true) === 0 && !Ext.Date.formatContainsHourInfo(e)) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1)
        }
        return a ? d : (d ? Ext.util.Format.date(d, e) : "")
    },
    getDisplayEndDate: function (e, c, d, a, b) {
        e = e || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            d = this.getEndDate();
            if (arguments.length < 2) {
                c = true
            }
        }
        if (d && (!this.isMilestone(b) || c) && d - Ext.Date.clearTime(d, true) === 0 && !Ext.Date.formatContainsHourInfo(e)) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1)
        }
        return a ? d : (d ? Ext.util.Format.date(d, e) : "")
    },
    fullCopy: function (a) {
        var b = this.callParent(arguments);
        b.taskStore = this.getTaskStore();
        return b
    },
    commit: function () {
        this.callParent(arguments);
        this.commitSegments()
    },
    reject: function () {
        this.callParent(arguments);
        this.rejectSegments()
    },
    isUnscheduled: function () {
        return !this.getStartDate() || !this.getEndDate()
    },
    getReadOnly: Ext.emptyFn,
    setReadOnly: Ext.emptyFn
}, function () {
    Ext.data.NodeInterface.decorate(this);
    this.override({
        remove: function () {
            var d = this, c = d.parentNode, b = d.getTaskStore(true), a;
            a = d.callParent(arguments);
            if (c && b && b.recalculateParents && c.convertEmptyParentToLeaf && !c.isRoot() && c.childNodes.length === 0) {
                c.set("leaf", true)
            } else {
                if (c && b && b.recalculateParents && !b.suspendAutoRecalculateParents && !c.isRoot() && c.childNodes.length > 0) {
                    c.refreshCalculatedParentNodeData();
                    c.recalculateParents()
                }
            }
            return a
        }, insertBefore: function (c, e) {
            c = this.createNode(c);
            if (!c) {
                return
            }
            var i = this.getTaskStore(true), h = i && i.getRoot(), b = this.phantomParentIdField, d = this !== h && this.phantom, f = this.getId();
            if (d) {
                this.data[this.phantomIdField] = f
            }
            if (f !== c.data[b]) {
                if (!c.phantom) {
                    c.modified = c.modified || {};
                    c.modified[b] = c.data[b]
                }
                c.data[b] = d ? f : null
            }
            var j = e && e.get("index");
            var a = c.parentNode;
            this.resetTotalCount(a);
            var g = this.callParent(arguments);
            if (a) {
                this.resetTotalCount()
            }
            if (e && e.get("index") != j) {
                e.modified = e.modified || {};
                e.modified.index = j
            }
            return g
        }, appendChild: function (a, n, g) {
            a = a instanceof Array ? a : [a];
            var m = this.getTaskStore(true), l = m && m.getRoot(), b = false, c = this.phantomParentIdField, e = this !== l && this.phantom, j = this.getId(), h = 0;
            for (var f = 0; f < a.length; f++) {
                var d = this.createNode(a[f]);
                if (!d) {
                    continue
                }
                h++;
                a[f] = d;
                if (d.parentNode) {
                    b = true
                }
                if (j !== d.data[c]) {
                    if (!d.phantom) {
                        d.modified = d.modified || {};
                        d.modified[c] = d.data[c]
                    }
                    d.data[c] = e ? j : null
                }
            }
            if (!h) {
                return
            }
            if (e) {
                this.data[this.phantomIdField] = j
            }
            this.resetTotalCount(b);
            var k = this.callParent([a.length > 1 ? a : a[0], n, g]);
            if (b) {
                this.resetTotalCount()
            }
            this.beginEdit();
            this.markAsParent();
            this.set(this.schedulingModeField, "Normal");
            this.endEdit();
            return k
        }, removeChild: function (h, e, f, b) {
            var g = this, d = !g.removeChildIsCalledFromReplaceChild && g.convertEmptyParentToLeaf && g.childNodes.length == 1, c = g.getTaskStore(true), a;
            g.resetTotalCount();
            g.removeChildIsCalledFromReplaceChild = false;
            a = g.callParent(arguments);
            if (b) {
                g.resetTotalCount()
            }
            if (c && c.recalculateParents && !c.suspendAutoRecalculateParents) {
                g.refreshCalculatedParentNodeData()
            }
            d && !g.isRoot() && g.set("leaf", true);
            return a
        }, replaceChild: function () {
            this.removeChildIsCalledFromReplaceChild = true;
            this.callParent(arguments)
        }, removeAll: function () {
            this.resetTotalCount();
            this.callParent(arguments)
        }, createNode: function (g) {
            var f = this, d = f.getTaskStore(true), c = d && d.getRoot(), b;
            if (d) {
                b = d.getProxy().getReader();
                var h = b.getChildType;
                b.getChildType = function () {
                    return h.apply(this, arguments) || this.getModel()
                }
            }
            g = this.callParent(arguments);
            if (d && b) {
                delete b.getChildType
            }
            if (d && c !== this && g.isProject) {
                return
            }
            var a = d && d.autoNormalizeNodes && !g.normalized && !g.normalizeScheduled;
            g = this.callParent(arguments);
            if (a) {
                var e = g.updateInfo;
                g.updateInfo = function () {
                    e.apply(this, arguments);
                    delete g.updateInfo;
                    g.normalize()
                };
                g.normalizeScheduled = true
            }
            return g
        }
    })
});
Ext.define("Gnt.model.TaskSegment", {
    extend: "Gnt.model.Task",
    task: null,
    prevSegment: null,
    nextSegment: null,
    customizableFields: [{name: "StartOffset", type: "int"}, {name: "EndOffset", type: "int"}],
    startOffsetField: "StartOffset",
    endOffsetField: "EndOffset",
    taskNotifyingSuspended: 0,
    respectNeighbours: 0,
    constructor: function (a) {
        a = a || {};
        a.leaf = true;
        if (!a.task) {
            throw"'task' has to be specified"
        }
        this.task = a.task;
        this.setPrevSegment(a.prevSegment);
        this.callParent(arguments);
        Ext.override(this, this.overridables);
        if (this.getTask().normalized && this.getTaskStore(true) && !this.normalized) {
            this.normalize()
        }
    },
    overridables: {
        set: function () {
            var a = this.getTask();
            if (!this.editing && a) {
                a.onSegmentEditBegin(this)
            }
            this.callParent(arguments)
        }
    },
    serialize: function () {
        var a = {};
        if (this.getId()) {
            a[this.idProperty] = this.getId()
        }
        a[this.phantomIdField] = this.getPhantomId();
        a[this.startDateField] = this.getStartDate();
        a[this.endDateField] = this.getEndDate();
        a[this.durationField] = this.getDuration();
        a[this.durationUnitField] = this.getDurationUnit();
        a[this.clsField] = this.getCls();
        return a
    },
    setStartOffset: function (a) {
        var c = this.getTask().getProjectCalendar();
        var b = c.convertMSDurationToUnit(this.getEndOffset() - a, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, a);
        this.set(this.durationField, b);
        this.endEdit()
    },
    setEndOffset: function (b) {
        var c = this.getTask().getProjectCalendar();
        var a = c.convertMSDurationToUnit(b - this.getStartOffset(), this.getDurationUnit());
        this.beginEdit();
        this.set(this.endOffsetField, b);
        this.set(this.durationField, a);
        this.endEdit()
    },
    setStartEndOffset: function (a, c) {
        var d = this.getTask().getProjectCalendar();
        var b = d.convertMSDurationToUnit(c - a, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, a);
        this.set(this.endOffsetField, c);
        this.set(this.durationField, b);
        this.endEdit()
    },
    normalize: function () {
        this.callParent(arguments);
        var b = this.getStartDate();
        if (!this.getStartOffset() && b) {
            var c = this.getTask();
            var a = this.calculateDuration(c.getStartDate(), b, "MILLI");
            var d = a + this.getDuration("MILLI");
            var f = c.getProjectCalendar();
            var e = f.convertMSDurationToUnit(d - a, this.getDurationUnit());
            this.data[this.startOffsetField] = a;
            this.data[this.endOffsetField] = d;
            this.data[this.durationField] = e
        }
    },
    updateOffsetsByDates: function () {
        if (!this.getTaskStore(true)) {
            return
        }
        if (this.updatingOffsets || this.updatingDates) {
            return
        }
        this.updatingOffsets = true;
        var a = this.calculateDuration(this.getTask().getStartDate(), this.getStartDate(), "MILLI");
        this.setStartEndOffset(a, a + this.getDuration("MILLI"));
        this.updatingOffsets = false
    },
    updateDatesByOffsets: function (f) {
        f = f || {};
        if (this.updatingDates || this.updatingOffsets) {
            return
        }
        var g = f.isForward !== false, e = f.useAbsoluteOffset !== false, b = f.startDate, h = f.endDate, d = this.getTaskStore(true);
        if (!d) {
            return
        }
        this.updatingDates = true;
        var c, a;
        if (g) {
            a = this.getPrevSegment();
            if (a && !e) {
                c = this.skipWorkingTime(a.getEndDate(), this.getStartOffset() - a.getEndOffset())
            } else {
                c = this.skipWorkingTime(b || this.getTask().getStartDate(), this.getStartOffset())
            }
        } else {
            a = this.getNextSegment();
            if (a && !e) {
                c = this.skipWorkingTime(a.getStartDate(), a.getStartOffset() - this.getEndOffset() + this.getDuration("MILLI"), false)
            } else {
                c = this.skipWorkingTime(h || this.getTask().getEndDate(), this.getDuration("MILLI"), false)
            }
        }
        this.setStartDateWithoutPropagation(c, true, d.skipWeekendsDuringDragDrop);
        this.updatingDates = false
    },
    getPrevSegment: function () {
        return this.prevSegment
    },
    getNextSegment: function () {
        return this.nextSegment
    },
    setPrevSegment: function (a) {
        this.prevSegment = a;
        if (a) {
            a.nextSegment = this
        }
    },
    setNextSegment: function (a) {
        this.nextSegment = a;
        if (a) {
            a.prevSegment = this
        }
    },
    buildSnapshot: function () {
        return [this, Ext.apply({}, this.data), {
            prevSegment: this.getPrevSegment(),
            nextSegment: this.getNextSegment()
        }]
    },
    readSnapshot: function (a) {
        if (a) {
            Ext.apply(this.data, a[1]);
            Ext.apply(this, a[2]);
            return this
        }
        return a
    },
    enableRespectNeighbours: function () {
        this.respectNeighbours++
    },
    disableRespectNeighbours: function () {
        this.respectNeighbours--
    },
    suspendTaskNotifying: function () {
        this.taskNotifyingSuspended++
    },
    resumeTaskNotifying: function () {
        this.taskNotifyingSuspended--
    },
    setStartDate: function (a, b) {
        if (b) {
            this.enableRespectNeighbours()
        }
        this.callParent(arguments);
        if (b) {
            this.disableRespectNeighbours()
        }
    },
    setStartDateWithoutPropagation: function () {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        if (!this.inShifting && this.respectNeighbours && this.getNextSegment()) {
            var a = this.getNextSegment();
            var b = this.getEndOffset() - a.getStartOffset();
            if (a && (b > 0)) {
                a.suspendTaskNotifying();
                a.enableRespectNeighbours();
                a.shiftWithoutPropagation(b);
                a.resumeTaskNotifying();
                a.disableRespectNeighbours()
            }
        }
        this.endEdit();
        return true
    },
    shiftWithoutPropagation: function (c) {
        var b = this;
        if (!c) {
            return
        }
        b.beginEdit();
        b.inShifting = true;
        b.setStartEndOffset(b.getStartOffset() + c, b.getEndOffset() + c);
        b.updateDatesByOffsets();
        var a;
        if (b.respectNeighbours && (a = c > 0 ? b.getNextSegment() : b.getPrevSegment())) {
            a.suspendTaskNotifying();
            a.enableRespectNeighbours();
            a.shiftWithoutPropagation(c);
            a.resumeTaskNotifying();
            a.disableRespectNeighbours()
        }
        b.inShifting = false;
        b.endEdit();
        return true
    },
    setEndDateWithoutPropagation: function () {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    setStartEndDateWithoutPropagation: function () {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    setDurationWithoutPropagation: function () {
        this.beginEdit();
        this.callParent(arguments);
        this.updateOffsetsByDates();
        this.endEdit();
        return true
    },
    getTask: function () {
        return this.task
    },
    beginEdit: function () {
        var a = this.getTask();
        if (a && !this.__editCounter) {
            a.onSegmentEditBegin(this)
        }
        this.callParent(arguments)
    },
    endEdit: function () {
        var a = this.previous;
        this.callParent(arguments);
        if (!this.__editCounter && !this.taskNotifyingSuspended) {
            if (this.startDateField in a || this.endDateField in a || this.startOffsetField in a || this.endOffsetField in a || this.durationField in a) {
                this.getTask().onSegmentsChanged(this, a)
            }
        }
    },
    setSegments: Ext.emptyFn,
    getSegments: Ext.emptyFn,
    callTask: function (b) {
        var a = this.task;
        var d = this.callTask.caller;
        var c = d && a[d.$name];
        if (c) {
            return c.apply(a, b)
        }
    },
    getSchedulingMode: function () {
        return "Normal"
    },
    getCalendar: function () {
        return this.callTask(arguments)
    },
    getOwnCalendar: function () {
        return this.callTask(arguments)
    },
    getProjectCalendar: function () {
        return this.callTask(arguments)
    },
    getDependencyStore: function () {
        return this.callTask(arguments)
    },
    getResourceStore: function () {
        return this.callTask(arguments)
    },
    getAssignmentStore: function () {
        return this.callTask(arguments)
    },
    getTaskStore: function () {
        return this.callTask(arguments)
    },
    forEachAvailabilityInterval: function (a) {
        a.segments = a.segments || false;
        return this.callTask(arguments)
    },
    propagateChanges: function () {
        return this.callTask(arguments)
    },
    rejectSegmentsProjection: function () {
        return this.callTask(arguments)
    },
    commitSegmentsProjection: function () {
        return this.callTask(arguments)
    },
    getAssignments: function () {
        return this.callTask(arguments)
    },
    getAssignmentFor: function () {
        return this.callTask(arguments)
    },
    isAssignedTo: function () {
        return this.callTask(arguments)
    },
    getResources: function () {
        return this.callTask(arguments)
    }
});
Ext.define("Gnt.model.ProjectLine", {
    extend: "Ext.data.Model",
    idProperty: "Id",
    fields: [{name: "Id"}, {name: "ProjectId"}, {name: "Date", type: "date"}, {
        name: "Cls",
        type: "string"
    }, {name: "Text", type: "string"}]
});
Ext.define("Gnt.model.Project", {
    extend: "Gnt.model.Task",
    alias: "gntmodel.project",
    isProject: true,
    descriptionField: "Note",
    allowDependenciesField: "AllowDependencies",
    customizableFields: [{name: "Description", type: "string"}, {
        name: "AllowDependencies",
        persist: false,
        type: "bool",
        defaultValue: false
    }],
    recognizedSchedulingModes: ["Normal"],
    isEditable: function (a) {
        switch (a) {
            case this.nameField:
            case this.startDateField:
            case this.endDateField:
            case this.durationField:
            case this.durationUnitField:
            case this.allowDependenciesField:
            case this.descriptionField:
            case this.allowDependenciesField:
                return this.callParent(arguments);
            default:
                return false
        }
    }
});
Ext.define("Gnt.util.DurationParser", {
    requires: ["Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    parseNumberFn: null,
    durationRegex: null,
    allowDecimals: true,
    constructor: function (a) {
        Ext.apply(this, a);
        if (this.unitsRegex) {
            Ext.apply(this.l10n.unitsRegex, this.unitsRegex)
        }
        if (!this.durationRegex) {
            this.durationRegex = this.allowDecimals ? /^\s*([\-+]?\d+(?:[.,]\d+)?)\s*(\w+)?/i : /^\s*([\-+]?\d+)(?![.,])\s*(\w+)?/i
        }
    },
    parse: function (c) {
        var a = this.durationRegex.exec(c);
        if (c == null || !a) {
            return null
        }
        var e = this.parseNumberFn(a[1]);
        var b = a[2];
        var d;
        if (b) {
            Ext.iterate(this.L("unitsRegex"), function (f, g) {
                if (g.test(b)) {
                    d = Sch.util.Date.getUnitByName(f);
                    return false
                }
            });
            if (!d) {
                return null
            }
        }
        return {value: e, unit: d}
    }
});
Ext.define("Gnt.util.DependencyParser", {
    requires: ["Gnt.util.DurationParser"],
    mixins: ["Gnt.mixin.Localizable"],
    separator: /\s*;\s*/,
    parseNumberFn: null,
    dependencyRegex: null,
    types: null,
    constructor: function (a) {
        Ext.apply(this, a);
        this.initTypes();
        var d = this.L("typeText");
        for (var b = 0; b < this.types.length; b++) {
            this.types[b] = (d[this.types[b]] || this.types[b])
        }
        var c = "(-?\\d+)(" + this.types.join("|") + ")?([\\+\\-].*)?";
        this.dependencyRegex = this.dependencyRegex || new RegExp(c, "i");
        this.durationParser = new Gnt.util.DurationParser({parseNumberFn: this.parseNumberFn})
    },
    initTypes: function () {
        this.types = this.types || ["SS", "SF", "FS", "FF"]
    },
    parse: function (j) {
        if (!j) {
            return []
        }
        var d = j.split(this.separator);
        var k = [];
        var c = this.dependencyRegex;
        for (var f = 0; f < d.length; f++) {
            var a = d[f];
            if (!a && f == d.length - 1) {
                continue
            }
            var g = c.exec(a);
            var e = {};
            if (!g) {
                return null
            }
            e.taskId = parseInt(g[1], 10);
            e.type = Ext.Array.indexOf(this.types, (g[2] || this.types[2]).toUpperCase());
            var h = g[3];
            if (h) {
                var b = this.durationParser.parse(h);
                if (!b) {
                    return null
                }
                e.lag = b.value;
                e.lagUnit = b.unit || "d"
            }
            k.push(e)
        }
        return k
    }
});
Ext.define("Gnt.util.Data", {
    singleton: true, cloneModelSet: function (b, d, c) {
        var e = [], a;
        var f = function (g) {
            a = g.copy();
            a.phantom = false;
            a.originalRecord = g;
            if (d) {
                if (d.call(c || b, a, g) === false) {
                    return
                }
            }
            e.push(a)
        };
        if (b.each) {
            b.each(f)
        } else {
            Ext.Array.each(b, f)
        }
        return e
    }, applyCloneChanges: function (g, m, j, o) {
        var a = [];
        var c = m.autoSyncSuspended;
        if (m.autoSync && !c) {
            m.suspendAutoSync()
        }
        var f = g.getRemovedRecords();
        for (var e = 0, b = f.length; e < b; e++) {
            if (f[e].originalRecord) {
                a.push(f[e].originalRecord)
            }
        }
        if (a.length) {
            m.remove(a);
            g.removed.length = 0
        }
        var n = g.getModifiedRecords(), p, d, h;
        for (e = 0, b = n.length; e < b; e++) {
            p = n[e].originalRecord;
            d = n[e].getData();
            delete d[n[e].idProperty];
            if (p) {
                p.beginEdit();
                for (var k in d) {
                    p.set(k, d[k])
                }
                if (j) {
                    j.call(o || n[e], d, n[e])
                }
                p.endEdit()
            } else {
                if (j) {
                    j.call(o || n[e], d, n[e])
                }
                h = m.add(d);
                n[e].originalRecord = h && h[0]
            }
            n[e].commit(true)
        }
        if (m.autoSync && !c) {
            m.resumeAutoSync();
            m.sync()
        }
    }
});
Ext.define("Gnt.data.linearizator.CycleResolvers", function (i) {
    function g() {
        return false
    }

    function j() {
        Ext.Error.raise("Can't linearize dependent tasks, there's a cycle in the dependency chain!")
    }

    function a(m, o) {
        var q = d(m, o), l = {}, p = function (t, s) {
            var r = l[t] || (l[t] = {});
            r[s] = s
        };
        f(q, function n(r) {
            if (r.prevSibling) {
                e(r.prevSibling.foldedDeps, r.foldedDeps, p);
                r.foldedDeps = Ext.apply(r.foldedDeps, r.prevSibling.foldedDeps)
            }
            if (!r.nextSibling && r.parentNode) {
                e(r.parentNode.foldedDeps, r.foldedDeps, p);
                r.parentNode.foldedDepds = Ext.apply(r.parentNode.foldedDeps, r.foldedDeps)
            }
        });
        c(o.fromById, l);
        return true
    }

    function d(l, r) {
        var n, m = [], p = {}, o, q;
        for (o in l) {
            if (l.hasOwnProperty(o)) {
                q = p[o] = h(l[o].task, l, r);
                if (!l.hasOwnProperty(q.parentNode)) {
                    m.push(q)
                }
            }
        }
        for (o in p) {
            if (p.hasOwnProperty(o)) {
                p[o] = k(p[o], p)
            }
        }
        if (m.length == 1) {
            n = m[0]
        } else {
            n = {parentNode: null, prevSibling: null, nextSibling: null, children: m, foldedDeps: {}}
        }
        return n
    }

    function h(x, n, y) {
        var p = y.fromById, o = {}, v = x.internalId, s, q, w, m, u, l, r, t;
        o[v] = Ext.clone(p[v] || {});
        s = x.parentNode && n.hasOwnProperty(x.parentNode.internalId) && x.parentNode.internalId;
        m = x.childNodes || [];
        l = [];
        for (r = 0, t = m.length; r < t; r++) {
            u = m[r].internalId;
            if (n.hasOwnProperty(u)) {
                l.push(u)
            }
        }
        w = x.previousSibling;
        while (w && !n.hasOwnProperty(w.internalId)) {
            w = w.previousSibling
        }
        w = w && w.internalId;
        q = x.nextSibling;
        while (q && !n.hasOwnProperty(q.internalId)) {
            q = q.nextSibling
        }
        q = q && q.internalId;
        return {parentNode: s, prevSibling: w, nextSibling: q, children: l, foldedDeps: o}
    }

    function k(p, m) {
        var o, l, n = p.children;
        for (o = 0, l = n.length; o < l; o++) {
            n[o] = m[n[o]]
        }
        p.parentNode = (p.parentNode || p.parentNode === 0) && m[p.parentNode] || null;
        p.prevSibling = (p.prevSibling || p.prevSibling === 0) && m[p.prevSibling] || null;
        p.nextSibling = (p.nextSibling || p.nextSibling === 0) && m[p.nextSibling] || null;
        return p
    }

    function f(p, o) {
        var n = p.children, m, l;
        for (m = 0, l = n.length; m < l; m++) {
            f(n[m], o)
        }
        o(p);
        return p
    }

    function e(p, u, o) {
        var v, q, m, l, s, n, t, r;
        v = Ext.Object.getKeys(p);
        m = Ext.Object.getKeys(u);
        q = Ext.Array.flatten(Ext.Array.map(v, function (w) {
            return Ext.Object.getKeys(p[w])
        }));
        l = Ext.Array.flatten(Ext.Array.map(m, function (w) {
            return Ext.Object.getKeys(u[w])
        }));
        s = Ext.Array.intersect(q, m);
        t = Ext.Array.intersect(l, v);
        if (s.length > 0 && t.length > 0) {
            n = 0;
            Ext.Array.forEach(s, function (y) {
                for (var x = 0, w = q.length; x < w; x++) {
                    q[x] == y && ++n
                }
            });
            r = 0;
            Ext.Array.forEach(t, function (y) {
                for (var x = 0, w = l.length; x < w; x++) {
                    l[x] == y && ++r
                }
            });
            if (n < r) {
                Ext.Array.forEach(s, function (w) {
                    b(p, w, o)
                })
            } else {
                Ext.Array.forEach(t, function (w) {
                    b(u, w, o)
                })
            }
        }
    }

    function b(o, l, n) {
        var m;
        for (m in o) {
            if (o.hasOwnProperty(m) && o[m].hasOwnProperty(l)) {
                n(m, l)
            }
        }
    }

    function c(p, l) {
        var n, m, o;
        for (n in l) {
            if (l.hasOwnProperty(n)) {
                o = l[n];
                for (m in o) {
                    if (o.hasOwnProperty(m)) {
                        p[n][m][0] = "green"
                    }
                }
            }
        }
        return p
    }

    return {singleton: true, none: g, exception: j, cut: a}
});
Ext.define("Gnt.data.Linearizator", function (u) {
    var r = {};

    function c(y, x, w) {
        w = l(w);
        return e([].concat(y), x, w.tasksDepsCollectingFn, w.cycleSolverFn)
    }

    function e(A, D, x, B) {
        var z = false, E = true, G, F, C, w, y;
        G = k();
        F = h();
        g(A, x, G, F);
        while (E) {
            z = false;
            while (!z) {
                z = true;
                E = false;
                for (C in G) {
                    if (G.hasOwnProperty(C) && G[C].color != "green") {
                        w = G[C].task;
                        y = f(w, F);
                        if (y != "red") {
                            v(y, w, G, F);
                            D(w, y, G, F);
                            z = false
                        } else {
                            E = true
                        }
                    }
                }
            }
            if (E) {
                E = B && B(G, F)
            }
        }
    }

    function l(y) {
        var x = n(y), A, z, w;
        w = r[x];
        if (!w) {
            A = Gnt.data.linearizator.CycleResolvers[y.cycles || "none"];
            z = [];
            y.self && (z.push(d));
            y.ancestors && (z.push(i));
            y.descendants && (z.push(t));
            y.successors && (z.push(p));
            z = q(z);
            w = {tasksDepsCollectingFn: z, cycleSolverFn: A};
            r[x] = w
        }
        return w
    }

    function n(x) {
        var w = [], y;
        for (y in x) {
            if (x.hasOwnProperty(y)) {
                w.push(y, "=", String(x[y]))
            }
        }
        return w.join(";")
    }

    function q(w) {
        return function (y, x, z) {
            var A = [];
            Ext.Array.forEach(w, function (B) {
                A = A.concat(B(y, x, z))
            });
            return A
        }
    }

    function g(z, y, x, w) {
        Ext.Array.forEach(z, function (A) {
            var B = y(A, x, w);
            if (B.length > 0) {
                g(B, y, x, w)
            }
        })
    }

    function d(x, w, y) {
        var A = [], z = x.internalId;
        if (!w.hasOwnProperty(z)) {
            w[z] = {task: x, color: "red"};
            A = [x]
        }
        return A
    }

    function i(x, I, H) {
        var w = [], z = H.downFromById, D = H.downToById, B = H.upFromById, C = H.upToById, E = x.internalId, y = x.parentNode, A = y && y.internalId, F, G;
        if (y && !I.hasOwnProperty(A)) {
            I[A] = {task: y, color: "red"};
            w.push(y)
        }
        if (y) {
            F = ["red"];
            G = ["red"];
            !z[A] && (z[A] = {});
            !z[A][E] && (z[A][E] = F);
            !D[E] && (D[E] = F);
            !C[A] && (C[A] = {});
            !C[A][E] && (C[A][E] = G);
            !B[E] && (B[E] = G)
        }
        return w
    }

    function t(y, F, E) {
        var w = [], z = E.downFromById, C = E.downToById, A = E.upFromById, B = E.upToById, x = !y.isRoot() && y.childNodes, D = y.internalId;
        x && Ext.Array.forEach(x, function (G) {
            var J = G.internalId, H, I;
            if (!F.hasOwnProperty(J)) {
                F[J] = {task: G, color: "red"};
                w.push(G)
            }
            H = ["red"];
            I = ["red"];
            !z[D] && (z[D] = {});
            !z[D][J] && (z[D][J] = H);
            !C[J] && (C[J] = H);
            !B[D] && (B[D] = {});
            !B[D][J] && (B[D][J] = I);
            !A[J] && (A[J] = I)
        });
        return w
    }

    function p(y, x, z) {
        var C = [], D = z.fromById, w = z.toById, B = y.getSuccessors(), A = y.internalId;
        Ext.Array.forEach(B, function (G) {
            var F = G.internalId, E;
            if (!x.hasOwnProperty(F)) {
                x[F] = {task: G, color: "red"};
                C.push(G)
            }
            E = ["red"];
            !D[A] && (D[A] = {});
            !D[A][F] && (D[A][F] = E);
            !w[F] && (w[F] = {});
            !w[F][A] && (w[F][A] = E)
        });
        return C
    }

    function k() {
        return {}
    }

    function h() {
        return {fromById: {}, toById: {}, downFromById: {}, downToById: {}, upFromById: {}, upToById: {}}
    }

    function j(y, A) {
        var x = A.toById[y.internalId], w = false, z;
        for (z in x) {
            if (x.hasOwnProperty(z) && x[z] && x[z][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }

    function b(x, z) {
        var A = z.fromById[x.internalId], w = false, y;
        for (y in A) {
            if (A.hasOwnProperty(y) && A[y] && A[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }

    function o(x, y) {
        var z = y.downToById, w = x.internalId;
        return z[w] && z[w][0] == "red"
    }

    function s(x, A) {
        var z = A.downFromById[x.internalId], w = false, y;
        for (y in z) {
            if (z.hasOwnProperty(y) && z[y] && z[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }

    function a(x, z) {
        var A = z.upToById[x.internalId], w = false, y;
        for (y in A) {
            if (A.hasOwnProperty(y) && A[y] && A[y][0] == "red") {
                w = true;
                break
            }
        }
        return w
    }

    function m(x, y) {
        var w = x.internalId, z = y.upToById;
        return z[w] && z[w][0] == "red"
    }

    function f(x, y) {
        var w = "red";
        if (!j(x, y) && !o(x, y) && !a(x, y)) {
            w = "green"
        } else {
            if (!j(x, y) && !o(x, y) && s(x, y)) {
                w = "yellow"
            } else {
                w = "red"
            }
        }
        return w
    }

    function v(y, w, E, D) {
        var C = w.internalId, x = D.fromById[C], A = D.downFromById[C], B = D.upFromById[C], z;
        E[C].color = y;
        if (y == "green") {
            if (x) {
                for (z in x) {
                    if (x.hasOwnProperty(z)) {
                        x[z][0] = y
                    }
                }
            }
            if (A) {
                for (z in A) {
                    if (A.hasOwnProperty(z)) {
                        A[z][0] = y
                    }
                }
            }
            if (B) {
                B[0] = y
            }
        } else {
            if (y == "yellow") {
                if (A) {
                    for (z in A) {
                        if (A.hasOwnProperty(z)) {
                            A[z][0] = y
                        }
                    }
                }
            }
        }
    }

    return {singleton: true, requires: ["Gnt.data.linearizator.CycleResolvers"], linearWalkBySpecification: c}
});
Ext.define("Gnt.widget.ConstraintResolutionForm", {
    extend: "Ext.form.Panel",
    requires: ["Ext.form.RadioGroup", "Ext.form.field.Display"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.constraintresolutionform",
    legacyMode: false,
    config: {resolutionContext: null, dateFormat: null},
    bodyPadding: 5,
    autoScroll: true,
    constructor: function (a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    initComponent: function () {
        var a = this;
        a.setupItemsFromResolutionContext(a.resolutionContext);
        a.setupFooterFromResolutionContext(a.resolutionContext);
        a.callParent(arguments)
    },
    setupItemsFromResolutionContext: function (b) {
        var c = this, a = [];
        Ext.Array.each(b.resolutions, function (e, d) {
            a.push({
                xtype: "radio",
                boxLabel: c.getResolutionOptionDescription(e.title, b),
                name: "resolutionOption",
                checked: e === b.getCancelActionOption(),
                inputValue: d,
                tabIndex: d
            })
        });
        c.items = [{
            xtype: "displayfield",
            itemId: "description",
            value: c.getConstraintViolationDescription(b),
            anchor: "-0"
        }, {
            xtype: "radiogroup",
            itemId: "options",
            columns: 1,
            title: c.L("Resolution options"),
            allowBlank: false,
            items: a,
            anchor: "-0"
        }]
    },
    setupFooterFromResolutionContext: function (a) {
        var b = this;
        b.fbar = {
            itemId: "footer-tb",
            items: [{
                xtype: "checkbox",
                itemId: "dont-ask-cb",
                boxLabel: b.L("Don't ask again"),
                tabIndex: a.resolutions.length + 1
            }, "->", {
                text: b.L("OK"),
                itemId: "ok-btn",
                formBind: true,
                tabIndex: a.resolutions.length + 2,
                handler: b.onUserActionOk,
                scope: b
            }, {
                text: b.L("Cancel"),
                itemId: "cancel-btn",
                tabIndex: a.resolutions.length + 3,
                handler: b.onUserActionCancel,
                scope: b
            }]
        }
    },
    getDontAskValue: function () {
        var a = this;
        return a.down("#dont-ask-cb").getValue()
    },
    getConstraintViolationDescription: function (f) {
        var h = this, g, d, e, c, b, a;
        g = f.title;
        c = f.task;
        b = c.getName() || "";
        e = c.getConstraintClass();
        a = h.dateFormat || h.L("dateFormat") || Ext.Date.defaultFormat;
        d = e && e.getDisplayableConstraintDateForFormat(f.date, a, c) || f.date;
        return d ? Ext.String.format(h.L("Task {0} violates constraint {1} {2}"), b, g, Ext.Date.format(d, a)) : Ext.String.format(h.L("Task {0} violates constraint {1}"), b, g)
    },
    getResolutionOptionDescription: function (g, e) {
        var f = this, c, b, d, a;
        c = e.task;
        d = c.getConstraintClass();
        a = f.dateFormat || f.L("dateFormat") || Ext.Date.defaultFormat;
        b = d && d.getDisplayableConstraintDateForFormat(e.date, a, c) || e.date;
        return b ? Ext.String.format(g, Ext.Date.format(b, a)) : Ext.String.format(g, "")
    },
    onUserActionOk: function (b) {
        var c = this, a;
        a = c.getValues();
        a.dontAsk = c.getDontAskValue();
        c.fireEvent("ok", c, a)
    },
    onUserActionCancel: function (a) {
        var b = this;
        b.fireEvent("cancel", b)
    },
    getOptimalHeight: function (f) {
        var g = this, a, h, e, d, c, b;
        if (f) {
            a = g.getXY();
            h = g.getWidth();
            g.setXY([-10000, -10000]);
            g.setWidth(f)
        }
        e = g.getComponent("options");
        d = e.getEl().getOffsetsTo(g.body);
        b = g.getDockedComponent("footer-tb");
        c = d[1] + Ext.getDom(e.getEl()).scrollHeight + 2 * g.bodyPadding + b.getHeight() + 10;
        if (f) {
            g.setWidth(h);
            g.setXY(a)
        }
        return c
    }
});
Ext.define("Gnt.widget.ConstraintResolutionWindow", {
    extend: "Ext.window.Window",
    alias: "widget.constraintresolutionwindow",
    requires: ["Gnt.widget.ConstraintResolutionForm"],
    mixins: ["Gnt.mixin.Localizable"],
    modal: true,
    closable: true,
    resizable: true,
    collapsible: false,
    border: false,
    bodyBorder: false,
    config: {resolutionContext: null, dateFormat: null},
    form: null,
    constructor: function (a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    initComponent: function () {
        var a = this;
        a.title = a.L("Constraint violation");
        a.setupItems();
        a.height = Math.round(Ext.dom.Element.getViewportHeight() / 3);
        a.width = Math.round(Ext.dom.Element.getViewportWidth() / 4);
        a.callParent(arguments);
        a.on("afterlayout", a.onAfterOptimalLayout, a, {single: true})
    },
    setupItems: function () {
        var a = this;
        a.layout = "fit";
        a.form = new Gnt.widget.ConstraintResolutionForm({
            margin: "0 0 3 0",
            resolutionContext: a.getResolutionContext(),
            dateFormat: a.getDateFormat(),
            bubbleEvents: ["ok", "cancel"]
        });
        a.items = a.form
    },
    onAfterOptimalLayout: function () {
        var c = this, d, a, e, b;
        d = c.getHeight();
        a = c.form.getHeight();
        e = c.form.getOptimalHeight();
        b = e + d - a;
        d != b && c.setHeight(b)
    }
});
Ext.define("Gnt.plugin.ConstraintResolutionGui", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.constraintresolutiongui",
    requires: ["Gnt.widget.ConstraintResolutionWindow"],
    config: {dateFormat: null},
    cmpDetacher: null,
    storeDetacher: null,
    storedResolutions: null,
    constructor: function (a) {
        var b = this;
        if (Ext.Version.compare(Ext.versions.extjs, "5.0.0") == -1) {
            b.initConfig(a)
        }
        b.callParent([a])
    },
    init: function (b) {
        var a = this;
        a.callParent(arguments);
        if (!a.disabled) {
            a.enable()
        }
    },
    enable: function () {
        var b = this, a = b.getCmp();
        b.callParent();
        if (a.rendered) {
            b.attachToTaskStore()
        } else {
            b.cmpDetacher = a.on("afterrender", function () {
                b.attachToTaskStore()
            }, null, {destroyable: true, single: true})
        }
    },
    disable: function () {
        var b = this, a = b.getCmp();
        b.callParent();
        if (a.rendered) {
            b.detachFromTaskStore()
        } else {
            b.cmpDetacher && Ext.destroy(b.cmpDetacher);
            b.cmpDetacher = null
        }
    },
    attachToTaskStore: function () {
        var c = this, b, a;
        if (!c.storeDetacher) {
            b = c.getCmp();
            a = b.getTaskStore();
            c.storeDetacher = b.mon(a, "constraintconflict", c.onConstraintConflict, c, {destroyable: true})
        }
    },
    detachFromTaskStore: function () {
        var a = this;
        a.storeDetacher && Ext.destroy(a.storeDetacher);
        a.storeDetacher = null
    },
    onConstraintConflict: function (b, a) {
        var i = this, k = i.getCmp(), l = k.lockedGrid.getView(), d = k.normalGrid.getView(), f = k.getDependencyView(), j = d.indexOf(b), c, h, g = {
            destroy: function () {
                Ext.destroy(h)
            }
        };

        function e() {
            if (j != -1) {
                l.refreshNode(j);
                d.refreshNode(j);
                f.updateDependencies(b)
            }
        }

        e();
        if (!i.hasStoredResolutionForContext(a)) {
            c = new Gnt.widget.ConstraintResolutionWindow({dateFormat: i.getDateFormat(), resolutionContext: a});
            h = c.on({
                ok: Ext.Function.bind(i.onUserActionOk, i, [a, e, c, g], true),
                cancel: Ext.Function.bind(i.onUserActionCancel, i, [a, e, c, g], true),
                close: Ext.Function.bind(i.onUserActionClose, i, [a, e, g], true),
                scope: i,
                destroyable: true
            });
            k.completeEdit();
            c.show()
        } else {
            i.resolveSilently(a, e)
        }
    },
    getStoredResolutions: function () {
        var a = this;
        if (!a.storedResolutions) {
            a.storedResolutions = {}
        }
        return a.storedResolutions
    },
    getStoredResolutionKeyForContext: function (a) {
        return a.title + a.resolutions.length
    },
    hasStoredResolutionForContext: function (b) {
        var c = this, a = c.getStoredResolutionKeyForContext(b), d = c.getStoredResolutions();
        return Ext.isDefined(d[a])
    },
    getStoredResolutionForContext: function (b) {
        var c = this, a = c.getStoredResolutionKeyForContext(b), d = c.getStoredResolutions();
        return d[a]
    },
    storeResolutionForContext: function (b, d) {
        var c = this, a = c.getStoredResolutionKeyForContext(b), e = c.storedResolutions;
        c.storedResolutions[a] = d
    },
    resolveSilently: function (a, d) {
        var c = this, b = c.getStoredResolutionForContext(a);
        a.resolutions[b].resolve();
        d()
    },
    onUserActionOk: function (g, b, d, c, h, f, a) {
        var e = this;
        Ext.destroy(a);
        f.close();
        if (b.dontAsk) {
            e.storeResolutionForContext(c, b.resolutionOption)
        }
        c.resolutions[b.resolutionOption].resolve();
        h()
    },
    onUserActionCancel: function (f, c, b, g, e, a) {
        var d = this;
        Ext.destroy(a);
        e.close();
        b.cancelAction();
        g()
    },
    onUserActionClose: function (e, c, b, f, a) {
        var d = this;
        Ext.destroy(a);
        b.cancelAction();
        f()
    }
});
if (!Ext.ClassManager.get("Gnt.data.util.IdConsistencyManager")) {
    Ext.define("Gnt.data.util.IdConsistencyManager", {
        extend: "Sch.data.util.IdConsistencyManager",
        config: {dependencyStore: null},
        onEventIdChanged: function (c, f, g, b) {
            var e = this, a = e.getDependencyStore(), d;
            e.callParent([c, f, g, b]);
            if (a) {
                d = e.getUpdateDependencyFromToFieldsFn(a, g, b);
                c.on("update", d, null, {single: true, priority: 200})
            }
        },
        getUpdateDependencyFromToFieldsFn: function (b, d, a) {
            var c = b.getRange();
            return function () {
                Ext.Array.forEach(c, function (e) {
                    if (e.getFrom() == d) {
                        e.setFrom(a)
                    } else {
                        if (e.getTo() == d) {
                            e.setTo(a)
                        }
                    }
                })
            }
        }
    })
}
if (!Ext.ClassManager.get("Gnt.data.util.ModelPersistencyManager")) {
    Ext.define("Gnt.data.util.ModelPersistencyManager", {
        extend: "Sch.data.util.ModelPersistencyManager",
        config: {dependencyStore: null},
        dependencyStoreDetacher: null,
        updateDependencyStore: function (c, a) {
            var b = this;
            Ext.destroyMembers(b, "dependencyStoreDetacher");
            if (c && c.autoSync) {
                b.dependencyStoreDetacher = c.on({
                    beforesync: b.onDependencyStoreBeforeSync,
                    scope: b,
                    destroyable: true,
                    priority: 100
                })
            }
        },
        onDependencyStoreBeforeSync: function (a) {
            var b = this;
            b.removeNonPersistableRecordsToCreate(a);
            return b.shallContinueSync(a)
        }
    })
}
Ext.define("Gnt.data.Calendar", {
    extend: "Ext.data.Store",
    requires: ["Ext.Date", "Gnt.model.CalendarDay", "Sch.model.Range", "Sch.util.Date"],
    mixins: ["Sch.data.mixin.UniversalModelGetter"],
    model: "Gnt.model.CalendarDay",
    proxy: "memory",
    daysPerMonth: 30,
    daysPerWeek: 7,
    hoursPerDay: 24,
    unitsInMs: null,
    defaultNonWorkingTimeCssCls: "gnt-holiday",
    weekendsAreWorkdays: false,
    weekendFirstDay: 6,
    weekendSecondDay: 0,
    holidaysCache: null,
    availabilityIntervalsCache: null,
    daysIndex: null,
    weekAvailability: null,
    defaultWeekAvailability: null,
    nonStandardWeeksByStartDate: null,
    nonStandardWeeksStartDates: null,
    calendarId: null,
    parent: null,
    defaultAvailability: ["00:00-24:00"],
    name: null,
    suspendCacheUpdate: 0,
    availabilitySearchLimit: 1825,
    statics: {
        getCalendar: function (a) {
            if (a instanceof Gnt.data.Calendar) {
                return a
            }
            return Ext.data.StoreManager.lookup("GNT_CALENDAR:" + a)
        }, getAllCalendars: function () {
            var a = [];
            Ext.data.StoreManager.each(function (b) {
                if (b instanceof Gnt.data.Calendar) {
                    a.push(b)
                }
            });
            return a
        }, removeAll: function () {
            var a = Ext.data.StoreManager;
            a.each(function (b) {
                if (b instanceof Gnt.data.Calendar) {
                    a.unregister(b);
                    Ext.destroy(b)
                }
            })
        }
    },
    constructor: function (a) {
        a = a || {};
        var b = a.parent;
        delete a.parent;
        var c = a.calendarId;
        delete a.calendarId;
        this.callParent(arguments);
        this.setParent(b);
        this.setCalendarId(c);
        this.unitsInMs = {
            MILLI: 1,
            SECOND: 1000,
            MINUTE: 60 * 1000,
            HOUR: 60 * 60 * 1000,
            DAY: this.hoursPerDay * 60 * 60 * 1000,
            WEEK: this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000,
            MONTH: this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            QUARTER: 3 * this.daysPerMonth * 24 * 60 * 60 * 1000,
            YEAR: 4 * 3 * this.daysPerMonth * 24 * 60 * 60 * 1000
        };
        this.defaultWeekAvailability = this.getDefaultWeekAvailability();
        this.on({
            update: this.clearCache,
            datachanged: this.clearCache,
            clear: this.clearCache,
            load: this.clearCache,
            scope: this
        });
        this.clearCache()
    },
    getCalendarId: function () {
        return this.calendarId
    },
    setCalendarId: function (b) {
        if (this.calendarId != null) {
            Ext.data.StoreManager.unregister(this)
        }
        this.calendarId = b;
        if (b != null) {
            this.storeId = "GNT_CALENDAR:" + b;
            Ext.data.StoreManager.register(this)
        } else {
            this.storeId = null
        }
        var a = this.proxy;
        if (a && a.extraParams) {
            a.extraParams.calendarId = b
        }
    },
    getDefaultWeekAvailability: function () {
        var e = this.defaultAvailability;
        var d = this.weekendFirstDay;
        var a = this.weekendSecondDay;
        var c = [];
        for (var b = 0; b < 7; b++) {
            c.push(this.weekendsAreWorkdays || b != d && b != a ? new this.model({
                Type: "WEEKDAY",
                Weekday: b,
                Availability: e && Ext.Array.clone(e) || [],
                IsWorkingDay: true
            }) : new this.model({Type: "WEEKDAY", Weekday: b, Availability: []}))
        }
        return c
    },
    clearCache: function () {
        if (this.suspendCacheUpdate > 0) {
            return
        }
        this.holidaysCache = {};
        this.availabilityIntervalsCache = {};
        var c = this.daysIndex = {};
        var a = this.weekAvailability = [];
        var d = this.nonStandardWeeksStartDates = [];
        var b = this.nonStandardWeeksByStartDate = {};
        this.each(function (k) {
            var e = k.getId();
            var n = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(e);
            var j = /^WEEKDAY:(\d+)$/.exec(e);
            var m = k.getType();
            var l = k.getWeekday();
            if (m == "WEEKDAYOVERRIDE" || n) {
                var f, i;
                if (m == "WEEKDAYOVERRIDE") {
                    f = k.getOverrideStartDate();
                    i = k.getOverrideEndDate()
                }
                if (n) {
                    f = Ext.Date.parse(n[2], "Y/m/d");
                    i = Ext.Date.parse(n[3], "Y/m/d");
                    l = n[1]
                }
                if (f && i && l != null) {
                    var h = f - 0;
                    if (!b[h]) {
                        b[h] = {
                            startDate: new Date(f),
                            endDate: new Date(i),
                            name: k.getName(),
                            weekAvailability: [],
                            mainDay: null
                        };
                        d.push(h)
                    }
                    if (l >= 0) {
                        b[h].weekAvailability[l] = k
                    } else {
                        b[h].mainDay = k
                    }
                }
            } else {
                if (m == "WEEKDAY" || j) {
                    if (j) {
                        l = j[1]
                    }
                    if (l != null) {
                        if (l < 0 || l > 6) {
                            throw new Error("Incorrect week day index")
                        }
                        a[l] = k
                    }
                } else {
                    var g = k.getDate();
                    if (g) {
                        c[g - 0] = k
                    }
                }
            }
        });
        d.sort(function (f, e) {
            return f - e
        });
        this.fireEvent("calendarchange", this)
    },
    intersectsWithCurrentWeeks: function (b, c) {
        var a = false;
        this.forEachNonStandardWeek(function (f) {
            var d = f.startDate;
            var e = f.endDate;
            if (d <= b && b < e || d < c && c <= e) {
                a = true;
                return false
            }
        });
        return a
    },
    addNonStandardWeek: function (b, f, a, c) {
        b = Ext.Date.clearTime(new Date(b));
        f = Ext.Date.clearTime(new Date(f));
        if (this.intersectsWithCurrentWeeks(b, f)) {
            throw new Error("Can not add intersecting week")
        }
        var e = this.model;
        var g = [];
        Ext.Array.each(a, function (h, i) {
            if (h instanceof Gnt.model.CalendarDay) {
                h.setType("WEEKDAYOVERRIDE");
                h.setOverrideStartDate(b);
                h.setOverrideEndDate(f);
                h.setWeekday(i);
                h.setName(c || "Week override");
                g.push(h)
            } else {
                if (Ext.isArray(h)) {
                    var j = new e();
                    j.setType("WEEKDAYOVERRIDE");
                    j.setOverrideStartDate(b);
                    j.setOverrideEndDate(f);
                    j.setWeekday(i);
                    j.setName(c || "Week override");
                    j.setAvailability(h);
                    g.push(j)
                }
            }
        });
        var d = new e();
        d.setType("WEEKDAYOVERRIDE");
        d.setOverrideStartDate(b);
        d.setOverrideEndDate(f);
        d.setWeekday(-1);
        d.setName(c || "Week override");
        g.push(d);
        this.add(g)
    },
    getNonStandardWeekByStartDate: function (a) {
        return this.nonStandardWeeksByStartDate[Ext.Date.clearTime(new Date(a)) - 0] || null
    },
    getNonStandardWeekByDate: function (d) {
        d = Ext.Date.clearTime(new Date(d)) - 0;
        var e = this.nonStandardWeeksStartDates;
        var a = this.nonStandardWeeksByStartDate;
        for (var c = 0; c < e.length; c++) {
            var b = a[e[c]];
            if (b.startDate > d) {
                break
            }
            if (b.startDate <= d && d <= b.endDate) {
                return b
            }
        }
        return null
    },
    removeNonStandardWeek: function (a) {
        a = Ext.Date.clearTime(new Date(a)) - 0;
        var b = this.getNonStandardWeekByStartDate(a);
        if (!b) {
            return
        }
        this.remove(Ext.Array.clean(b.weekAvailability).concat(b.mainDay))
    },
    forEachNonStandardWeek: function (e, c) {
        var d = this;
        var f = this.nonStandardWeeksStartDates;
        var a = this.nonStandardWeeksByStartDate;
        for (var b = 0; b < f.length; b++) {
            if (e.call(c || d, a[f[b]]) === false) {
                return false
            }
        }
    },
    setWeekendsAreWorkDays: function (a) {
        if (a !== this.weekendsAreWorkdays) {
            this.weekendsAreWorkdays = a;
            this.defaultWeekAvailability = this.getDefaultWeekAvailability();
            this.clearCache()
        }
    },
    areWeekendsWorkDays: function () {
        return this.weekendsAreWorkdays
    },
    getCalendarDay: function (a) {
        a = typeof a == "number" ? new Date(a) : a;
        return this.getOverrideDay(a) || this.getWeekDay(a.getDay(), a) || this.getDefaultCalendarDay(a.getDay())
    },
    getOverrideDay: function (a) {
        return this.getOwnCalendarDay(a) || this.parent && this.parent.getOverrideDay(a) || null
    },
    getOwnCalendarDay: function (a) {
        a = typeof a == "number" ? new Date(a) : a;
        return this.daysIndex[Ext.Date.clearTime(a, true) - 0]
    },
    getWeekDay: function (c, b) {
        if (b) {
            var a = this.getNonStandardWeekByDate(b);
            if (a && a.weekAvailability[c]) {
                return a.weekAvailability[c]
            }
        }
        return this.weekAvailability[c] || this.parent && this.parent.getWeekDay(c, b) || null
    },
    getDefaultCalendarDay: function (a) {
        if (!this.hasOwnProperty("defaultAvailability") && !this.hasOwnProperty("weekendsAreWorkdays") && this.parent) {
            return this.parent.getDefaultCalendarDay(a)
        }
        return this.defaultWeekAvailability[a]
    },
    isHoliday: function (c) {
        var b = c - 0;
        var d = this.holidaysCache;
        if (d[b] != null) {
            return d[b]
        }
        c = typeof c == "number" ? new Date(c) : c;
        var a = this.getCalendarDay(c);
        if (!a) {
            throw"Can't find day for " + c
        }
        return d[b] = !a.getIsWorkingDay()
    },
    isWeekend: function (b) {
        var a = b.getDay();
        return a === this.weekendFirstDay || a === this.weekendSecondDay
    },
    isWorkingDay: function (a) {
        return !this.isHoliday(a)
    },
    convertMSDurationToUnit: function (a, b) {
        return a / this.unitsInMs[Sch.util.Date.getNameOfUnit(b)]
    },
    convertDurationToMs: function (b, a) {
        return b * this.unitsInMs[Sch.util.Date.getNameOfUnit(a)]
    },
    getHolidaysRanges: function (c, f, a) {
        if (c > f) {
            Ext.Error.raise("startDate can't be bigger than endDate")
        }
        c = Ext.Date.clearTime(c, true);
        f = Ext.Date.clearTime(f, true);
        var b = [], g, d;
        for (d = c; d < f; d = Sch.util.Date.getNext(d, Sch.util.Date.DAY, 1)) {
            if (this.isHoliday(d) || (this.weekendsAreWorkdays && a && this.isWeekend(d))) {
                var h = this.getCalendarDay(d);
                var i = h && h.getCls() || this.defaultNonWorkingTimeCssCls;
                var e = Sch.util.Date.getNext(d, Sch.util.Date.DAY, 1);
                if (!g) {
                    g = new Sch.model.Range({StartDate: d, EndDate: e, Cls: i})
                } else {
                    if (g.getCls() == i) {
                        g.setEndDate(e)
                    } else {
                        b.push(g);
                        g = new Sch.model.Range({StartDate: d, EndDate: e, Cls: i})
                    }
                }
            } else {
                if (g) {
                    b.push(g);
                    g = null
                }
            }
        }
        if (g) {
            b.push(g)
        }
        return b
    },
    forEachAvailabilityInterval: function (r, f, q) {
        q = q || this;
        var m = this;
        var d = r.startDate;
        var k = r.endDate;
        var p = r.isForward !== false;
        if (p ? !d : !k) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option")
        }
        var a = new Date(p ? d : k);
        var c = Sch.util.Date;
        if (p) {
            if (!k) {
                k = c.add(d, "d", r.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365)
            }
        } else {
            if (!d) {
                d = c.add(k, "d", -(r.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365))
            }
        }
        var g = false;
        while (p ? a < k : a > d) {
            var j = this.getAvailabilityIntervalsFor(a - (p ? 0 : 1), p ? g : false);
            for (var h = p ? 0 : j.length - 1; p ? h < j.length : h >= 0; p ? h++ : h--) {
                var b = j[h];
                var l = b.startDate;
                var o = b.endDate;
                if (l >= k || o <= d) {
                    continue
                }
                var e = l < d ? d : l;
                var n = o > k ? k : o;
                if (f.call(q, e, n) === false) {
                    return false
                }
            }
            a = p ? c.getStartOfNextDay(a, false, g) : c.getEndOfPreviousDay(a, g);
            g = true
        }
    },
    calculateDuration: function (a, d, b) {
        var c = 0;
        this.forEachAvailabilityInterval({startDate: a, endDate: d}, function (g, f) {
            var e = g.getTimezoneOffset() - f.getTimezoneOffset();
            c += f - g + e * 60 * 1000
        });
        return this.convertMSDurationToUnit(c, b)
    },
    calculateEndDate: function (a, f, b) {
        if (!f) {
            return new Date(a)
        }
        var e = Sch.util.Date, d;
        f = this.convertDurationToMs(f, b);
        var c = f === 0 && Ext.Date.clearTime(a, true) - a === 0 ? e.add(a, Sch.util.Date.DAY, -1) : a;
        this.forEachAvailabilityInterval({startDate: c}, function (i, h) {
            var j = h - i;
            var g = i.getTimezoneOffset() - h.getTimezoneOffset();
            if (j >= f) {
                d = new Date(i - 0 + f);
                return false
            } else {
                f -= j + g * 60 * 1000
            }
        });
        return d
    },
    calculateStartDate: function (d, c, b) {
        if (!c) {
            return new Date(d)
        }
        var a;
        c = this.convertDurationToMs(c, b);
        this.forEachAvailabilityInterval({endDate: d, isForward: false}, function (f, e) {
            var g = e - f;
            if (g >= c) {
                a = new Date(e - c);
                return false
            } else {
                c -= g
            }
        });
        return a
    },
    skipNonWorkingTime: function (a, c) {
        var b = false;
        this.forEachAvailabilityInterval(c ? {startDate: a} : {endDate: a, isForward: false}, function (e, d) {
            a = c ? e : d;
            b = true;
            return false
        });
        if (!b) {
            throw"skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified"
        }
        return new Date(a)
    },
    skipWorkingTime: function (a, c, b) {
        return c >= 0 ? this.calculateEndDate(a, c, b) : this.calculateStartDate(a, -c, b)
    },
    getAvailabilityIntervalsFor: function (a, b) {
        if (b) {
            a = (a).valueOf()
        } else {
            if (a instanceof Date) {
                a = (new Date(a.getFullYear(), a.getMonth(), a.getDate())).valueOf()
            } else {
                a = Ext.Date.clearTime(new Date(a)).valueOf()
            }
        }
        return this.availabilityIntervalsCache[a] = (this.availabilityIntervalsCache[a] || this.getCalendarDay(a).getAvailabilityIntervalsFor(a))
    },
    getByInternalId: function (a) {
        return this.data.map[a]
    },
    isChildOf: function (c) {
        var a = c === this && this, b = false;
        while (a && !b) {
            b = a === c;
            a = a.parent
        }
        return b
    },
    getParentableCalendars: function () {
        var b = this, a = [], c = Gnt.data.Calendar.getAllCalendars();
        Ext.Array.each(c, function (d) {
            if (d !== b && !d.isChildOf(b)) {
                a.push({Id: d.calendarId, Name: d.name || d.calendarId})
            }
        });
        return a
    },
    setParent: function (e) {
        var d = Gnt.data.Calendar.getCalendar(e);
        if (e && !d) {
            throw new Error("Invalid parent specified for the calendar")
        }
        if (this.parent != d) {
            var b = this.proxy;
            var c = {calendarchange: this.clearCache, destroy: this.onParentDestroy, scope: this};
            var a = this.parent;
            if (a) {
                a.un(c)
            }
            this.parent = d;
            if (d) {
                d.on(c)
            }
            if (b && b.extraParams) {
                b.extraParams.parentId = d ? d.calendarId : null
            }
            this.clearCache();
            this.fireEvent("parentchange", this, d, a)
        }
    },
    onParentDestroy: function () {
        this.setParent(null)
    },
    isAvailabilityIntersected: function (p, b, m) {
        var n, a, e, h;
        for (var g = 0; g < 7; g++) {
            n = this.getWeekDay(g) || this.getDefaultCalendarDay(g);
            e = p.getWeekDay(g) || p.getDefaultCalendarDay(g);
            if (!n || !e) {
                continue
            }
            a = n.getAvailability();
            h = e.getAvailability();
            for (var f = 0, c = a.length; f < c; f++) {
                for (var d = 0, o = h.length; d < o; d++) {
                    if (h[d].startTime < a[f].endTime && h[d].endTime > a[f].startTime) {
                        return true
                    }
                }
            }
        }
        var q = false;
        this.forEachNonStandardWeek(function (i) {
            if (i.startDate >= m) {
                return false
            }
            if (b < i.endDate) {
                q = true;
                return false
            }
        });
        return q
    }
});
Ext.define("Gnt.data.CalendarManager", {
    extend: "Ext.data.TreeStore",
    requires: ["Gnt.data.Calendar"],
    mixins: ["Sch.data.mixin.UniversalModelGetter"],
    model: "Gnt.model.Calendar",
    alias: "store.calendarmanager",
    storeId: "calendars",
    calendarClass: "Gnt.data.Calendar",
    calendarConfig: null,
    projectCalendar: null,
    myListeners: null,
    constructor: function (b) {
        b = b || {};
        if (!b.proxy) {
            b.proxy = {type: "memory"}
        }
        this.callParent([b]);
        this.myListeners = this.on({
            idchanged: this.onChangeId,
            rootchange: this.onNewRoot,
            nodeappend: this.onNewNode,
            nodeinsert: this.onNewNode,
            noderemove: this.onRemoveNode,
            destroyable: true,
            scope: this
        });
        var a = this.getRoot();
        if (a) {
            this.bindCalendars(a)
        } else {
            this.setRoot({expanded: true})
        }
    },
    destroy: function () {
        this.myListeners.destroy();
        this.callParent(arguments)
    },
    onChangeId: function (c, e, b, a) {
        if (!(c instanceof Gnt.model.Calendar)) {
            return
        }
        var d = this.getCalendar(e || a);
        d.setCalendarId(b)
    },
    onIdChanged: function (b, c, a) {
        this.onChangeId(b, c, a);
        return this.callParent(arguments)
    },
    onNewNode: function (a, c) {
        this.bindCalendars(c);
        if (c !== this.getRoot()) {
            this.fixCalendarParent(c)
        }
        var b = this;
        c.cascadeBy(function (d) {
            d.setCalendarManager(b)
        })
    },
    onNewRoot: function (a) {
        this.onNewNode(null, a)
    },
    onRemoveNode: function (b, c, a) {
        if (!a) {
            var d = c.calendar;
            if (d) {
                this.unbindCalendarEvents(d);
                if (!this.__loading) {
                    d.destroy();
                    Ext.data.StoreManager.unregister(d)
                }
                c.setCalendarManager(null)
            }
        }
    },
    suspendCalendarsEvents: function (a) {
        this.getRoot().cascadeBy(function (b) {
            var d = b.getCalendar();
            if (d) {
                d.suspendEvents(a)
            }
        }, this)
    },
    resumeCalendarsEvents: function () {
        this.getRoot().cascadeBy(function (a) {
            var b = a.getCalendar();
            if (b) {
                b.resumeEvents()
            }
        }, this)
    },
    getCalendarClass: function () {
        return this.calendarClass
    },
    getProjectCalendar: function () {
        return this.projectCalendar
    },
    setProjectCalendar: function (a) {
        if (typeof a !== "object") {
            a = this.getCalendar(a) || Gnt.data.Calendar.getCalendar(a)
        }
        if (!a) {
            return
        }
        this.projectCalendar = a;
        this.fireEvent("projectcalendarset", this, a)
    },
    getCalendar: function (b) {
        var a = this.getModelById(b);
        return a && a.getCalendar()
    },
    getNodeByCalendar: function (b) {
        if (!b) {
            return this.getRoot()
        }
        var a = this.getModelById(b.calendarId);
        if (!a) {
            this.getRoot().cascadeBy(function (d) {
                var e = d.getCalendar();
                if (e === b) {
                    a = d;
                    return false
                }
            }, this)
        }
        return a
    },
    onParentChange: function (d, b, a) {
        var c = this.getNodeByCalendar(d);
        if (c && !c.syncingCalendarParent) {
            this.fixNodeParent(c)
        }
    },
    bindCalendarEvents: function (a) {
        this.relayEvents(a, ["load"], "calendar");
        this.relayEvents(a, ["add", "update", "remove", "bulkremove"], "day");
        this.relayEvents(a, ["calendarchange"]);
        a.on("parentchange", this.onParentChange, this);
        this.on({dayadd: this.onDayAdd, dayupdate: this.onDayUpdate, dayremove: this.onDayRemove, scope: this})
    },
    unbindCalendarEvents: function (a) {
        this.un({dayadd: this.onDayAdd, dayupdate: this.onDayUpdate, dayremove: this.onDayRemove, scope: this});
        a && a.un({parentchange: this.onParentChange, scope: this})
    },
    onDayAdd: function (b, a) {
        this.getModelById(b.getCalendarId()).dirty = true
    },
    onDayUpdate: function (b, a) {
        this.getModelById(b.getCalendarId()).dirty = true
    },
    onDayRemove: function (b, a) {
        this.getModelById(b.getCalendarId()).dirty = true
    },
    fixCalendarParent: function (b) {
        if (b.syncingCalendarParent) {
            return
        }
        var a = b.parentNode.getCalendar(), c = b.getCalendar();
        if (a !== c.parent) {
            b.syncingCalendarParent = true;
            c.setParent(a);
            b.syncingCalendarParent = false
        }
    },
    fixNodeParent: function (d) {
        var a = d.parentNode.getCalendar(), b = d.getCalendar().parent;
        if (a !== b) {
            var c = this.getNodeByCalendar(b);
            c && c.appendChild(d)
        }
    },
    bindCalendar: function (b) {
        if (!b || this.getRoot() === b) {
            return
        }
        var e = b.getCalendar();
        var g = b.getDays();
        var f = b.getId() || b.internalId;
        g = Ext.isArray(g) && g;
        if (!e || g) {
            if (!e) {
                e = Gnt.data.Calendar.getCalendar(f)
            }
            if (!e) {
                var c = b.parentNode && b.parentNode.getCalendar();
                var d = Ext.ClassManager.get(b.getCalendarClass() || this.calendarClass);
                var a = Ext.applyIf(b.getCalendarConfig(), {data: g, parent: c});
                e = Ext.create(d, Ext.apply(a, this.calendarConfig))
            }
            b.setCalendar(e);
            this.bindCalendarEvents(e)
        } else {
            if (!this.getCalendar(e.calendarId)) {
                this.bindCalendarEvents(e)
            }
        }
        this.fireEvent("calendarbound", this, e, b)
    },
    unbindCalendar: function (a) {
        if (!a || this.getRoot() === a) {
            return
        }
        var b = a.getCalendar();
        if (!b) {
            return
        }
        this.unbindCalendarEvents(b);
        this.fireEvent("calendarunbound", this, b, a)
    },
    bindCalendars: function (b) {
        var a = this;
        if (b) {
            Ext.Array.forEach([].concat(b), function (c) {
                c.cascadeBy(a.bindCalendar, a)
            })
        }
    },
    unbindCalendars: function (b) {
        var a = this;
        if (b) {
            Ext.Array.forEach([].concat(b), function (c) {
                c.cascadeBy(a.unbindCalendar, a)
            })
        }
    }
});
Ext.define("Gnt.data.calendar.BusinessTime", {
    extend: "Gnt.data.Calendar",
    daysPerMonth: 20,
    daysPerWeek: 5,
    hoursPerDay: 8,
    defaultAvailability: ["08:00-12:00", "13:00-17:00"]
});
Ext.define("Gnt.data.DependencyStore", {
    extend: "Ext.data.Store",
    mixins: ["Sch.data.mixin.UniversalModelGetter"],
    model: "Gnt.model.Dependency",
    storeId: "dependencies",
    alias: "store.gantt_dependencystore",
    taskStore: null,
    methodsCache: null,
    strictDependencyValidation: false,
    transitiveDependencyValidation: false,
    ignoreInitial: true,
    isLoadingRecords: false,
    allowedDependencyTypes: null,
    proxy: "memory",
    allowParentTaskDependencies: true,
    constructor: function (a) {
        a = a || {};
        this.callParent([a]);
        this.init();
        this.ignoreInitial = false
    },
    init: function () {
        this.methodsCache = {};
        this.on({
            add: this.onDependencyAdd,
            update: this.onDependencyUpdate,
            load: this.onDependencyLoad,
            datachanged: this.onDependencyDataChanged,
            remove: this.onDependencyRemove,
            clear: this.onDependencyStoreClear,
            priority: 100,
            scope: this
        })
    },
    onDependencyLoad: function () {
        var a = this.getTaskStore();
        a && a.fillTasksWithDepInfo()
    },
    onDependencyDataChanged: function () {
        var a = this.getTaskStore();
        if (this.isLoadingRecords && a) {
            a.fillTasksWithDepInfo()
        }
    },
    loadRecords: function () {
        this.isLoadingRecords = true;
        this.callParent(arguments);
        this.isLoadingRecords = false
    },
    scheduleTask: function (b) {
        var c = this.getTaskStore(), a = b.getStartDate(), d = b.getEndDate();
        if (!a || !d) {
            b.beginEdit();
            if (!a) {
                b.setStartDateWithoutPropagation(c.getProjectStartDate(), undefined !== b.getDuration())
            }
            if (!d) {
                b.setDurationWithoutPropagation(1)
            }
            b.endEdit()
        }
    },
    scheduleLinkedTasks: function (b, a) {
        this.scheduleTask(b);
        if (!a.getStartDate() && !b.getTaskStore().cascadeChanges) {
            a.alignByIncomingDependencies()
        }
        this.scheduleTask(a)
    },
    onDependencyAdd: function (c, d) {
        if (this.ignoreInitial) {
            return
        }
        for (var b = 0; b < d.length; b++) {
            var a = d[b];
            if (!this.isValidDependencyType(a.getType())) {
                throw"This dependency type is invalid. Check Gnt.data.DependencyStore#allowedDependencyTypes value"
            }
            var f = a.getSourceTask(), e = a.getTargetTask();
            if (f && e) {
                f.successors.push(a);
                e.predecessors.push(a);
                this.scheduleLinkedTasks(f, e)
            }
        }
        c.resetMethodsCache()
    },
    onDependencyRemove: function (e, f, d, b) {
        var c = this.getTaskStore();
        var a = [];
        Ext.Array.forEach(f, function (g) {
            var i = g.getSourceTask(c), h = g.getTargetTask(c);
            if (i) {
                Ext.Array.remove(i.successors, g)
            }
            if (h) {
                Ext.Array.remove(h.predecessors, g);
                if (!h.isManuallyScheduled()) {
                    a.push(h)
                }
            }
        });
        e.resetMethodsCache();
        Ext.Array.forEach(a, function (g) {
            g.adjustToCalendarWithoutPropagation()
        })
    },
    onDependencyUpdate: function (i, b, c) {
        if (c != Ext.data.Model.COMMIT) {
            var j = this.getTaskStore();
            var e = b.previous;
            var h = b.getSourceTask();
            var f = b.getTargetTask();
            var g = e && b.fromField in e;
            var a = e && b.toField in e;
            if (g) {
                var k = j.getModelById(e[b.fromField]);
                k && Ext.Array.remove(k.successors, b);
                if (h && Ext.Array.indexOf(h.successors, b) < 0) {
                    h.successors.push(b)
                }
            }
            if (a) {
                var d = j.getModelById(e[b.toField]);
                d && Ext.Array.remove(d.predecessors, b);
                if (f && Ext.Array.indexOf(f.predecessors, b) < 0) {
                    f.predecessors.push(b)
                }
            }
            if ((g || a) && h && f) {
                this.scheduleLinkedTasks(h, f)
            }
            this.resetMethodsCache()
        }
    },
    onDependencyStoreClear: function (b) {
        var a = b.getTaskStore();
        a && a.fillTasksWithDepInfo()
    },
    getDependenciesForTask: function (a) {
        return a.successors.concat(a.predecessors)
    },
    getIncomingDependenciesForTask: function (a, b) {
        return b ? a.predecessors : a.predecessors.slice()
    },
    getOutgoingDependenciesForTask: function (a, b) {
        return b ? a.successors : a.successors.slice()
    },
    getKeyByDeps: function (e, g, b) {
        if (!e || !e.length) {
            return ""
        }
        var d = "";
        for (var c = 0, a = e.length; c < a; c++) {
            var f = e[c];
            d += (f.getSourceId && f.getSourceId() || f[g]) + ":" + (f.getTargetId && f.getTargetId() || f[b]) + ","
        }
        return d
    },
    buildCacheKey: function (f, g, c, e, a) {
        var i = a.fromField || (a.fromField = this.model.prototype.fromField), d = a.toField || (a.toField = this.model.prototype.toField), b = a.ignoreDepKey, h = a.addDepKey;
        if (!a.hasOwnProperty("ignoreDepKey")) {
            a.ignoreDepKey = b = c && this.getKeyByDeps(c, i, d) || "";
            a.addDepKey = h = e && this.getKeyByDeps(e, i, d) || ""
        }
        return f + "-" + g + "-" + b + "-" + h
    },
    hasTransitiveDependency: function (f, b, c, o, a) {
        a = a || {visitedTasks: {}};
        var d = this.buildCacheKey(f, b, c, o, a);
        var r = a.visitedTasks, p = a.extraSuccessors;
        if (this.isCachedResultAvailable("hasTransitiveDependency", d)) {
            return this.methodsCache.hasTransitiveDependency[d]
        }
        var q = this, u = a.fromField, g = a.toField, s = this.getTaskById(f), n, k;
        if (r[f]) {
            return false
        }
        r[f] = true;
        if (s) {
            if (o && !p) {
                p = a.extraSuccessors = {};
                for (n = 0, k = o.length; n < k; n++) {
                    var e = o[n];
                    var m = e.getSourceId && e.getSourceId() || e[u];
                    p[m] = p[m] || [];
                    p[m].push(e)
                }
            }
            var j, h = s.successors;
            if (p && p[f]) {
                h = h.concat(p[f])
            }
            for (n = 0, k = h.length; n < k; n++) {
                j = h[n];
                var t = j.getTargetId && j.getTargetId() || j[g];
                if ((!c || Ext.Array.indexOf(c, j) == -1) && (t === b || q.hasTransitiveDependency(t, b, c, o, a))) {
                    return this.setCachedResult("hasTransitiveDependency", d, true)
                }
            }
        }
        return this.setCachedResult("hasTransitiveDependency", d, false)
    },
    successorsHaveTransitiveDependency: function (j, k, e, h, b) {
        b = b || {};
        var g = this.buildCacheKey(j, k, e, h, b);
        var c = k instanceof Gnt.model.Task ? k : this.getTaskById(k);
        if (this.isCachedResultAvailable("successorsHaveTransitiveDependency", g)) {
            return this.methodsCache.successorsHaveTransitiveDependency[g]
        }
        for (var f = 0, d = c.successors.length; f < d; f++) {
            var a = c.successors[f].getTargetId();
            if (this.hasTransitiveDependency(j, a, e, h) || this.predecessorsHaveTransitiveDependency(j, a, e, h) || this.successorsHaveTransitiveDependency(j, a, e, h, b)) {
                return this.setCachedResult("successorsHaveTransitiveDependency", g, true)
            }
        }
        return this.setCachedResult("successorsHaveTransitiveDependency", g, false)
    },
    predecessorsHaveTransitiveDependency: function (j, k, d, h, a) {
        a = a || {};
        var g = this.buildCacheKey(j, k, d, h, a);
        var b = j instanceof Gnt.model.Task ? j : this.getTaskById(j);
        if (this.isCachedResultAvailable("predecessorsHaveTransitiveDependency", g)) {
            return this.methodsCache.predecessorsHaveTransitiveDependency[g]
        }
        for (var f = 0, c = b.predecessors.length; f < c; f++) {
            var e = b.predecessors[f].getSourceId();
            if (this.hasTransitiveDependency(e, k, d, h) || this.successorsHaveTransitiveDependency(e, k, d, h) || this.predecessorsHaveTransitiveDependency(e, k, d, h, a)) {
                return this.setCachedResult("predecessorsHaveTransitiveDependency", g, true)
            }
        }
        return this.setCachedResult("predecessorsHaveTransitiveDependency", g, false)
    },
    isPartOfTransitiveDependency: function (e, c, d, a) {
        var b = e instanceof Gnt.model.Task ? e : this.getTaskById(e);
        if (!b.predecessors.length && !b.successors.length) {
            return false
        }
        if (b.predecessors.length) {
            return this.predecessorsHaveTransitiveDependency.apply(this, arguments)
        } else {
            return this.successorsHaveTransitiveDependency.apply(this, arguments)
        }
    },
    getCycle: function (a) {
        a = a || {};
        Ext.applyIf(a, {ignoreTasks: {}, visitedTasks: {}, path: [], task: this.getAt(0).getSourceTask()});
        var f = a.visitedTasks, g = a.ignoreTasks, k = a.path, b = a.task, j = b.getId();
        if (g[j]) {
            return
        }
        k.push(b);
        if (f[j]) {
            return k
        }
        f[j] = true;
        var c = b.successors;
        for (var h = 0, d = c.length; h < d; h++) {
            a.task = c[h].getTargetTask();
            var e = this.getCycle(a);
            if (e) {
                return e
            }
        }
        k.pop();
        delete f[j]
    },
    getCycles: function () {
        var c = this, a = [], b = {};
        this.each(function (g) {
            var f = c.getCycle({task: g.getSourceTask(), ignoreTasks: b});
            if (f) {
                for (var e = 0, d = f.length; e < d; e++) {
                    b[f[e]] = true
                }
                a.push(f)
            }
        });
        return a
    },
    resetMethodsCache: function () {
        this.methodsCache = {}
    },
    isCachedResultAvailable: function (b, a) {
        return this.methodsCache[b] && this.methodsCache[b].hasOwnProperty(a)
    },
    getCachedResult: function (b, a) {
        return this.methodsCache[b][a]
    },
    setCachedResult: function (c, a, b) {
        this.methodsCache[c] = this.methodsCache[c] || {};
        this.methodsCache[c][a] = b;
        return b
    },
    getGroupTopTasks: function (g, h) {
        var b = g.length, f = h.length, d = b, a = f, e, c;
        do {
            e = g[d];
            c = h[a];
            d--;
            a--
        } while (e == c && d >= 0 && a >= 0);
        return [e, c]
    },
    groupsHasTransitiveDependency: function (h, c, d, u, b) {
        var q = b || {targets: null, visitedTasks: {}};
        var r = this.getTaskStore().getRootNode(), j = false, y = this, o = this.getTaskById(h), A = this.getTaskById(c), z = q.visitedTasks, x = q.targets;
        if (!q.targetGroup) {
            q.targetGroup = A.getTopParent(true)
        }
        var B = q.fromField || (q.fromField = this.model.prototype.fromField), k = q.toField || (q.toField = this.model.prototype.toField), n = q.ignoreDepKey, a = q.addDepKey;
        var v = this.getGroupTopTasks(o.getTopParent(true), q.targetGroup), m = v[0], f = v[1];
        if (m === o && f === A && o.isLeaf() && A.isLeaf()) {
            return this.hasTransitiveDependency(h, c, d)
        }
        if (!q.hasOwnProperty("ignoreDepKey")) {
            q.ignoreDepKey = n = d && this.getKeyByDeps(d, B, k) || "";
            q.addDepKey = a = u && this.getKeyByDeps(u, B, k) || ""
        }
        var e = m.getId() + "-" + f.getId() + "-" + n + "-" + a;
        if (this.isCachedResultAvailable("groupsHasTransitiveDependency", e)) {
            return this.methodsCache.groupsHasTransitiveDependency[e]
        }
        if (f !== q.targetTopParent) {
            q.targetTopParent = f;
            x = q.targets = {};
            f.cascadeBy(function (i) {
                x[i.getId()] = true
            })
        }
        var w = q.extraSuccessors;
        if (u && !w) {
            w = q.extraSuccessors = {};
            for (var t = 0, p = u.length; t < p; t++) {
                var g = u[t];
                var s = g.getSourceId && g.getSourceId() || g[B];
                w[s] = w[s] || [];
                w[s].push(g)
            }
        }
        m.cascadeBy(function (E) {
            if (E !== r) {
                var H = E.getId();
                if (z[H]) {
                    return false
                }
                z[H] = true;
                var I = E.successors;
                if (w && w[H]) {
                    I = I.concat(w[H])
                }
                for (var G = 0, D = I.length; G < D; G++) {
                    var F = I[G], C = F.getTargetId && F.getTargetId() || F[k];
                    if ((!d || Ext.Array.indexOf(d, F) == -1) && (x[C] || y.groupsHasTransitiveDependency(C, c, d, u, q))) {
                        j = true;
                        return false
                    }
                }
            }
        });
        return this.setCachedResult("groupsHasTransitiveDependency", e, j)
    },
    getDependencyError: function (d, b, k, i, m, g) {
        var e, j, f;
        var c = d instanceof Gnt.model.Dependency;
        if (c) {
            e = d.getSourceId();
            j = this.getTaskById(e);
            i = b;
            m = k;
            if (i && Ext.Array.contains(i, d)) {
                i = Ext.Array.slice(i, 0);
                Ext.Array.remove(i, d)
            }
            k = d.getType();
            b = d.getTargetId();
            f = this.getTaskById(b);
            if (d.joined && d.joined.length) {
                g = d
            }
        } else {
            e = d;
            j = this.getTaskById(e);
            f = this.getTaskById(b);
            if (k === undefined) {
                var h = this.model.getField(this.model.prototype.typeField).defaultValue;
                k = h !== undefined ? h : this.model.Type.EndToStart
            }
        }
        if (!g && c && !d.isValid()) {
            return -1
        } else {
            if (!e || !b || e == b) {
                return -1
            }
        }
        if (!j || !f) {
            return -2
        }
        if (!this.isValidDependencyType(k)) {
            return -10
        }
        if (j.contains(f) || f.contains(j)) {
            return -9
        }
        var l;
        if (m || g) {
            l = [];
            if (g) {
                l.push(g)
            }
            if (m) {
                l = l.concat(m)
            }
        }
        if (this.transitiveDependencyValidation) {
            if (this.hasTransitiveDependency(e, b, l, i)) {
                return -3
            }
        } else {
            if (this.areTasksLinkedForward(e, b, l, i)) {
                return -3
            }
        }
        if (this.hasTransitiveDependency(b, e, l, i)) {
            return -4
        }
        if (this.transitiveDependencyValidation && this.isPartOfTransitiveDependency(e, b, l, i)) {
            return -5
        }
        if (this.strictDependencyValidation) {
            if (this.groupsHasTransitiveDependency(b, e, l, i)) {
                return -7
            }
            if (this.transitiveDependencyValidation && this.groupsHasTransitiveDependency(e, b, l, i)) {
                return -8
            }
        }
        if (!this.allowParentTaskDependencies && (!j.isLeaf() || !f.isLeaf())) {
            return -11
        }
        if (f.isProject || j.isProject) {
            return -12
        }
        var n = f.getProject(), a = j.getProject();
        if (n != a) {
            if (n && !n.getAllowDependencies() || a && !a.getAllowDependencies()) {
                return -13
            }
        }
        if (f.isReadOnly() || j.isReadOnly()) {
            return -14
        }
        return 0
    },
    isValidDependencyType: function (c) {
        if (this.allowedDependencyTypes) {
            var a = false, b = this.model;
            Ext.each(this.allowedDependencyTypes, function (d) {
                if (b.Type[d] == c) {
                    a = true;
                    return false
                }
            });
            return a
        }
        return true
    },
    isValidDependency: function (f, b, d, a, c, e) {
        return !this.getDependencyError(f, b, d, a, c, e)
    },
    areTasksLinkedForward: function (a, h, p, j) {
        var n = a instanceof Gnt.model.Task ? a : this.getTaskById(a);
        var o = h instanceof Gnt.model.Task ? h : this.getTaskById(h);
        if (!n || !o) {
            return false
        }
        var f = this.model.prototype, s = f.fromField, g = f.toField;
        var k = n.getId() + "-" + o.getId() + "-" + (this.getKeyByDeps(p, s, g) || "") + "-" + (this.getKeyByDeps(j, s, g) || "");
        if (this.isCachedResultAvailable("areTasksLinkedForward", k)) {
            return this.methodsCache.areTasksLinkedForward[k]
        }
        var c = n.successors, b = o.predecessors, m, e, d;
        for (e = 0, d = c.length; e < d; e++) {
            m = c[e];
            if ((!p || !Ext.Array.contains(p, m)) && Ext.Array.contains(b, m)) {
                return this.setCachedResult("areTasksLinkedForward", k, true)
            }
        }
        if (j) {
            var r, q;
            for (e = 0, d = j.length; e < d; e++) {
                m = j[e];
                r = m.getSourceId && m.getSourceId() || m[s];
                q = m.getTargetId && m.getTargetId() || m[g];
                if (r == n.getId() && q == o.getId()) {
                    return this.setCachedResult("areTasksLinkedForward", k, true)
                }
            }
        }
        return this.setCachedResult("areTasksLinkedForward", k, false)
    },
    areTasksLinked: function (a, e) {
        var d = a instanceof Gnt.model.Task ? a : this.getTaskById(a);
        var c = e instanceof Gnt.model.Task ? e : this.getTaskById(e);
        if (!d || !c) {
            return false
        }
        var b = d.getId() + "-" + c.getId();
        if (this.isCachedResultAvailable("areTasksLinked", b)) {
            return this.methodsCache.areTasksLinked[b]
        }
        return this.setCachedResult("areTasksLinked", b, this.areTasksLinkedForward(d, c) || this.areTasksLinkedForward(c, d))
    },
    getByTaskIds: function (c, b) {
        var a = this.findBy(function (f) {
            var d = f.getTargetId(), e = f.getSourceId();
            if ((e === c && d === b) || (e === b && d === c)) {
                return true
            }
        });
        return this.getAt(a)
    },
    getTaskById: function (b) {
        var a = this.getTaskStore();
        return a && a.getModelById(b) || null
    },
    getSourceTask: function (a) {
        var b = a instanceof Gnt.model.Dependency ? a.getSourceId() : a;
        return this.getTaskById(b)
    },
    getTargetTask: function (a) {
        var b = a instanceof Gnt.model.Dependency ? a.getTargetId() : a;
        return this.getTaskById(b)
    },
    getTaskStore: function () {
        return this.taskStore
    },
    setTaskStore: function (a) {
        this.taskStore = a
    }
});
Ext.define("Gnt.data.TaskStore", {
    extend: "Ext.data.TreeStore",
    requires: ["Sch.util.Date", "Sch.patches.TreeStore", "Gnt.data.Linearizator", "Gnt.data.util.IdConsistencyManager", "Gnt.data.util.ModelPersistencyManager", "Gnt.model.Task", "Gnt.model.Project", "Gnt.data.Calendar", "Gnt.data.DependencyStore"],
    mixins: ["Gnt.patches.TaskStore", "Sch.data.mixin.FilterableTreeStore", "Sch.data.mixin.UniversalModelGetter", "Sch.data.mixin.CacheHintHelper", "Sch.data.mixin.EventStore", "Gnt.data.mixin.ProjectableStore"],
    model: "Gnt.model.Task",
    alias: "store.gantt_taskstore",
    storeId: "tasks",
    proxy: "memory",
    typeProperty: "TaskType",
    calendarManager: null,
    calendar: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    weekendsAreWorkdays: false,
    cascadeChanges: true,
    batchSync: true,
    recalculateParents: true,
    skipWeekendsDuringDragDrop: true,
    cascadeDelay: 0,
    moveParentAsGroup: true,
    enableDependenciesForParentTasks: true,
    availabilitySearchLimit: 1825,
    cycleResolutionStrategy: "cut",
    autoNormalizeNodes: true,
    cascading: false,
    isFillingRoot: false,
    isSettingRoot: false,
    earlyStartDates: null,
    earlyEndDates: null,
    lateStartDates: null,
    lateEndDates: null,
    lastTotalTimeSpan: null,
    suspendAutoRecalculateParents: 0,
    suspendAutoCascade: 0,
    currentCascadeBatch: null,
    batchCascadeLevel: 0,
    fillTasksWithDepInfoCounter: 0,
    dependenciesCalendar: "project",
    pendingDataUpdates: null,
    constructor: function (c) {
        c = c || {};
        var d = c.calendar || this.calendar;
        if (!d) {
            var f = {};
            if (c.hasOwnProperty("weekendsAreWorkdays")) {
                f.weekendsAreWorkdays = c.weekendsAreWorkdays
            } else {
                if (this.self.prototype.hasOwnProperty("weekendsAreWorkdays") && this.self != Gnt.data.TaskStore) {
                    f.weekendsAreWorkdays = this.weekendsAreWorkdays
                }
            }
            var b = c.calendarManager || this.calendarManager;
            if (b) {
                var g = this;
                b = c.calendarManager = Ext.data.StoreManager.lookup(b);
                var i = b.getProjectCalendar();
                if (i) {
                    d = i
                } else {
                    this.calendarManagerListeners = b.on({
                        projectcalendarset: function (l, m) {
                            g.setCalendar(m, true)
                        }, destroyable: true, single: true
                    })
                }
            }
            d = d && Ext.data.StoreManager.lookup(d) || new Gnt.data.Calendar(f)
        }
        var a = c.dependencyStore || this.dependencyStore;
        a = a && Ext.data.StoreManager.lookup(a) || Ext.create("Gnt.data.DependencyStore");
        delete c.dependencyStore;
        var j = c.resourceStore || this.resourceStore;
        j = j && Ext.data.StoreManager.lookup(j) || Ext.create("Gnt.data.ResourceStore");
        delete c.resourceStore;
        var e = c.assignmentStore || this.assignmentStore;
        e = e && Ext.data.StoreManager.lookup(e) || Ext.create("Gnt.data.AssignmentStore", {resourceStore: j});
        delete c.assignmentStore;
        if (d) {
            delete c.calendar;
            this.setCalendar(d, true, true)
        }
        this.resetEarlyDates(true);
        this.resetLateDates(true);
        this.pendingDataUpdates = {recalculateParents: {}};
        var k = c.root || this.root;
        this.root = null;
        delete c.root;
        this.callParent([c]);
        this.setResourceStore(j);
        this.setAssignmentStore(e);
        this.setDependencyStore(a);
        k && this.setRoot(k);
        this.setupListeners();
        this.fillTasksWithDepInfo();
        var h = this.getRootNode();
        if (h && this.autoNormalizeNodes) {
            h.normalizeParent()
        }
        if (this.autoSync && this.batchSync) {
            this.sync = Ext.Function.createBuffered(this.sync, 500)
        }
        this.initTreeFiltering()
    },
    setupListeners: function () {
        this.on({
            nodeappend: this.onMyNodeAdded,
            nodeinsert: this.onMyNodeAdded,
            update: this.onTaskUpdated,
            scope: this
        });
        this.on({
            noderemove: this.onTaskRemoved,
            nodemove: this.onTaskMoved,
            write: this.onTaskStoreWrite,
            sort: this.onTasksSorted,
            load: this.onTasksLoaded,
            rootchange: this.onTasksLoaded,
            scope: this,
            priority: 100
        })
    },
    createResourceEventsCache: Ext.emptyFn,
    createIdConsistencyManager: function () {
        var a = this;
        return new Gnt.data.util.IdConsistencyManager({
            eventStore: a,
            resourceStore: a.getResourceStore(),
            assignmentStore: a.getAssignmentStore(),
            dependencyStore: a.getDependencyStore()
        })
    },
    createModelPersistencyManager: function () {
        var a = this;
        return new Gnt.data.util.ModelPersistencyManager({
            eventStore: a,
            resourceStore: a.getResourceStore(),
            assignmentStore: a.getAssignmentStore(),
            dependencyStore: a.getDependencyStore()
        })
    },
    fillNode: function (b, a) {
        if (b.isRoot()) {
            this.isSettingRoot = true
        }
        this.callParent(arguments);
        if (b.isRoot()) {
            this.isSettingRoot = false
        }
    },
    onTasksLoaded: function () {
        var a = this.getRoot();
        this.fillTasksWithDepInfoCounter = 1;
        this.fillTasksWithDepInfo();
        if (a && this.autoNormalizeNodes) {
            a.normalizeParent()
        }
    },
    load: function (a) {
        this.un("noderemove", this.onTaskRemoved, this);
        this.un("nodeappend", this.onMyNodeAdded, this);
        this.un("update", this.onTaskUpdated, this);
        this.callParent(arguments);
        this.on("noderemove", this.onTaskRemoved, this);
        this.on("nodeappend", this.onMyNodeAdded, this);
        this.on("update", this.onTaskUpdated, this)
    },
    setProxy: function () {
        this.callParent(arguments);
        if (this.typeProperty) {
            var b = this, a = b.getProxy() && b.getProxy().getReader();
            if (a && !a.getTypeProperty()) {
                a.setTypeProperty(b.typeProperty)
            }
        }
    },
    setRoot: function (a) {
        var d = this;
        var b = this.count() && this.getRoot();
        this.isSettingRoot = true;
        Ext.apply(a, {
            calendar: d.calendar,
            taskStore: d,
            dependencyStore: d.dependencyStore,
            phantom: false,
            dirty: false
        });
        var c = this.callParent(arguments);
        this.isSettingRoot = false;
        b && b.cascadeBy(function (e) {
            e.setTaskStore(null)
        });
        return c
    },
    getDependencyStore: function () {
        return this.dependencyStore
    },
    fillTasksWithDepInfo: function () {
        if (!this.getRootNode()) {
            return
        }
        var a = this.getDependencyStore();
        if (this.fillTasksWithDepInfoCounter++ > 0) {
            this.forEachTaskUnordered(function (b) {
                b.successors = [];
                b.predecessors = []
            })
        }
        if (a) {
            a.each(function (b) {
                var d = b.getSourceTask(), c = b.getTargetTask();
                if (d && c) {
                    d.successors.push(b);
                    c.predecessors.push(b)
                }
            })
        }
    },
    setDependencyStore: function (a) {
        var c = this, d = c.dependencyStore, b = {
            add: c.onDependencyAdd,
            update: c.onDependencyUpdate,
            remove: c.onDependencyDelete,
            scope: c
        };
        if (d && d.isStore) {
            d.un(b);
            d.setTaskStore(null);
            c.idConsistencyManager && c.idConsistencyManager.setDependencyStore(null);
            c.modelPersistencyManager && c.modelPersistencyManager.setDependencyStore(null)
        }
        c.dependencyStore = a && Ext.StoreMgr.lookup(a) || null;
        if (c.dependencyStore) {
            c.modelPersistencyManager && c.modelPersistencyManager.setDependencyStore(c.dependencyStore);
            c.idConsistencyManager && c.idConsistencyManager.setDependencyStore(c.dependencyStore);
            c.dependencyStore.setTaskStore(c);
            c.dependencyStore.on(b);
            c.fillTasksWithDepInfo()
        }
        if ((d || a) && d !== a) {
            c.events && c.fireEvent("dependencystorechange", c, a, d)
        }
    },
    getResourceStore: function () {
        return this.resourceStore || null
    },
    setResourceStore: function (b) {
        var a = this, c = a.resourceStore;
        if (c && c.isStore) {
            c.setTaskStore(null);
            a.idConsistencyManager && a.idConsistencyManager.setResourceStore(null);
            a.modelPersistencyManager && a.modelPersistencyManager.setResourceStore(null)
        }
        a.resourceStore = b && Ext.StoreMgr.lookup(b) || null;
        if (a.resourceStore) {
            a.modelPersistencyManager && a.modelPersistencyManager.setResourceStore(a.resourceStore);
            a.idConsistencyManager && a.idConsistencyManager.setResourceStore(a.resourceStore);
            a.resourceStore.setTaskStore(a);
            a.resourceStore.normalizeResources()
        }
        if ((c || b) && (c !== b)) {
            a.events && a.fireEvent("resourcestorechange", a, b, c)
        }
    },
    getAssignmentStore: function () {
        return this.assignmentStore || null
    },
    setAssignmentStore: function (c) {
        var b = this, d = b.assignmentStore, a = {
            add: b.onAssignmentStructureMutation,
            update: b.onAssignmentMutation,
            remove: b.onAssignmentStructureMutation,
            scope: b
        };
        if (d && d.isStore) {
            d.un(a);
            d.setTaskStore(null);
            b.idConsistencyManager && b.idConsistencyManager.setAssignmentStore(null);
            b.modelPersistencyManager && b.modelPersistencyManager.setAssignmentStore(null)
        }
        b.assignmentStore = c && Ext.StoreMgr.lookup(c) || null;
        if (b.assignmentStore) {
            b.modelPersistencyManager && b.modelPersistencyManager.setAssignmentStore(b.assignmentStore);
            b.idConsistencyManager && b.idConsistencyManager.setAssignmentStore(b.assignmentStore);
            c.setTaskStore(b);
            c.on(a)
        }
        if ((d || c) && d !== c) {
            b.events && b.fireEvent("assignmentstorechange", b, c, d)
        }
    },
    adjustToCalendar: function (h, g) {
        var e = this;
        e.resetEarlyDates();
        e.resetLateDates();
        if (h instanceof Gnt.model.Task) {
            h.adjustToCalendar(g)
        } else {
            if (Ext.isFunction(h)) {
                g = h;
                h = []
            }
            var b = e.getRootNode(), f = {};
            if (!Ext.isArray(h) || !h.length) {
                h = b && b.childNodes || []
            }
            for (var c = 0, a = h.length; c < a; c++) {
                var d = h[c];
                if (!f[d.getId()]) {
                    d.propagateChanges(function () {
                        d.cascadeBy(function (i) {
                            if (i !== b) {
                                i.adjustToCalendarWithoutPropagation()
                            }
                        });
                        return d
                    }, function (i, j) {
                        if (!i) {
                            Ext.apply(f, j)
                        }
                        g && g.apply(this, arguments)
                    })
                }
            }
        }
    },
    renormalizeTasks: function (b, a, c) {
        this.adjustToCalendar(a, c)
    },
    getCalendar: function () {
        return this.calendar || null
    },
    setCalendar: function (e, c, b) {
        var d = {calendarchange: this.renormalizeTasks, scope: this};
        if (this.calendar) {
            this.calendar.un(d)
        }
        this.calendar = e;
        if (e) {
            e.on(d);
            var a = this.getRootNode();
            if (a) {
                a.calendar = e
            }
            if (!c) {
                this.renormalizeTasks()
            }
            if (!b) {
                this.fireEvent("calendarset", this, e)
            }
        }
    },
    getCriticalPaths: function () {
        var b = this.getRootNode(), a = [], c = new Date(0);
        b.cascadeBy(function (d) {
            c = Sch.util.Date.max(d.getEndDate(), c)
        });
        b.cascadeBy(function (d) {
            if (c - d.getEndDate() === 0 && !d.isRoot() && !(!d.isLeaf() && d.childNodes.length)) {
                a.push(d)
            }
        });
        return Ext.Array.map(a, function (d) {
            return d.getCriticalPaths()
        })
    },
    onMyNodeAdded: function (b, c) {
        if (!c.isRoot()) {
            if (this.lastTotalTimeSpan) {
                var a = this.getTotalTimeSpan();
                if (c.getEndDate() > a.end || c.getStartDate() < a.start) {
                    this.lastTotalTimeSpan = null
                }
            }
            if (c.getEndDate() - this.getProjectEndDate() === 0) {
                this.resetLateDates()
            }
            if (!this.cascading && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[c.getId()] = c
                } else {
                    c.recalculateParents()
                }
            }
        }
    },
    onTaskUpdated: function (c, b, a) {
        var f = b.previous;
        if (this.lastTotalTimeSpan) {
            var d = this.getTotalTimeSpan();
            if (f && (f[b.endDateField] - d.end === 0 || f[b.startDateField] - d.start === 0) || (b.getEndDate() > d.end || b.getStartDate() < d.start)) {
                this.lastTotalTimeSpan = null
            }
        }
        if (!this.cascading && a !== Ext.data.Model.COMMIT && f) {
            var g = b.percentDoneField in f;
            if (b.startDateField in f || b.endDateField in f || "parentId"in f || b.effortField in f || f[b.schedulingModeField] === "Manual" || f[b.manuallyScheduledField]) {
                var e = b;
                if (this.cascadeChanges && !this.suspendAutoCascade) {
                    if (f[e.schedulingModeField] == "Manual") {
                        var h = e.getIncomingDependencies(true);
                        if (h.length) {
                            e = h[0].getSourceTask()
                        }
                    }
                    Ext.Function.defer(this.cascadeChangesForTask, this.cascadeDelay, this, [e])
                } else {
                    this.resetEarlyDates();
                    this.resetLateDates()
                }
                g = true
            } else {
                if ((f[b.schedulingModeField] || b.manuallyScheduledField in f) && b.isManuallyScheduled()) {
                    this.resetEarlyDates();
                    this.resetLateDates()
                }
            }
            if (g && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[b.getId()] = b
                } else {
                    b.recalculateParents()
                }
            }
        }
    },
    onEndUpdate: function () {
        var b = this, d = {}, a, c;
        Ext.Object.each(b.pendingDataUpdates.recalculateParents, function (f, e) {
            e.parentNode && (d[e.parentNode.getId()] = e.parentNode)
        });
        d = Ext.Array.sort(Ext.Object.getValues(d), function (f, e) {
            return (f.data.depth > e.data.depth) ? 1 : ((f.data.depth < e.data.depth) ? -1 : 0)
        });
        while (d.length > 0) {
            a = d.pop();
            a.refreshCalculatedParentNodeData();
            a.recalculateParents()
        }
        b.pendingDataUpdates.recalculateParents = {};
        return b.callParent(arguments)
    },
    getEmptyCascadeBatch: function () {
        var a = this;
        return {
            nbrAffected: 0, affected: {}, visitedCounters: {}, addVisited: function (c) {
                var b = c.internalId;
                if (!this.visitedCounters[b]) {
                    this.visitedCounters[b] = 1
                } else {
                    this.visitedCounters[b]++
                }
            }, addAffected: function (d, c) {
                var b = d.internalId;
                if (this.affected[b]) {
                    return
                } else {
                    this.affected[b] = d;
                    this.nbrAffected++
                }
                if (!a.cascading && this.nbrAffected > 1) {
                    a.fireEvent("beforecascade", a);
                    a.cascading = true
                }
                if (!c) {
                    var e = this.affectedParentsbyInternalId;
                    var g = this.affectedParentsArray;
                    var f = d.isLeaf() ? d.parentNode : d;
                    while (f && !f.data.root) {
                        if (e[f.internalId]) {
                            break
                        }
                        e[f.internalId] = f;
                        g.push(f);
                        this.addAffected(f, true);
                        f = f.parentNode
                    }
                }
            }, affectedParentsArray: [], affectedParentsbyInternalId: {}, parentsStartDates: {}
        }
    },
    startBatchCascade: function () {
        if (!this.batchCascadeLevel) {
            this.currentCascadeBatch = this.getEmptyCascadeBatch();
            this.suspendAutoRecalculateParents++;
            this.suspendAutoCascade++
        }
        this.batchCascadeLevel++;
        return this.currentCascadeBatch
    },
    endBatchCascade: function () {
        this.batchCascadeLevel--;
        if (!this.batchCascadeLevel) {
            this.suspendAutoRecalculateParents--;
            this.suspendAutoCascade--;
            var a = this.currentCascadeBatch;
            this.currentCascadeBatch = null;
            this.resetEarlyDates();
            this.resetLateDates();
            if (this.cascading) {
                this.cascading = false;
                this.fireEvent("cascade", this, a)
            }
        }
    },
    cascadeChangesForTask: function (a, b) {
        a.propagateChanges(Ext.emptyFn, b, true)
    },
    removeTaskDependencies: function (a) {
        var b = this.dependencyStore, c = a.getAllDependencies(b);
        if (c.length) {
            b.remove(c)
        }
    },
    removeTaskAssignments: function (b) {
        var c = this.getAssignmentStore(), a = b.getAssignments();
        if (a.length) {
            c.remove(a)
        }
    },
    onTaskRemoved: function (g, e, h) {
        var a = this.getDependencyStore();
        var d = this.getAssignmentStore();
        var i = !e.isReplace && !h;
        if (a && i) {
            e.cascadeBy(this.removeTaskDependencies, this)
        }
        if (d && i) {
            d.fireEvent("beforetaskassignmentschange", d, e.getId(), []);
            e.cascadeBy(this.removeTaskAssignments, this);
            d.fireEvent("taskassignmentschanged", d, e.getId(), [])
        }
        var f = this.getTotalTimeSpan();
        var b = e.getStartDate();
        var c = e.getEndDate();
        if (c - f.end === 0 || b - f.start === 0) {
            this.lastTotalTimeSpan = null
        }
        if (i) {
            e.setTaskStore(null)
        }
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onTaskMoved: function (b, d, f, c) {
        var e = this.getTotalTimeSpan();
        var a = b.getStartDate();
        var g = b.getEndDate();
        if (g - e.end === 0 || a - e.start === 0) {
            this.lastTotalTimeSpan = null
        }
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onAssignmentMutation: function (c, a) {
        var b = this;
        Ext.Array.forEach([].concat(a), function (e) {
            var d = e.getTask(b);
            if (d) {
                d.onAssignmentMutation(e)
            }
        })
    },
    onAssignmentStructureMutation: function (c, a) {
        var b = this;
        Ext.Array.forEach([].concat(a), function (e) {
            var d = e.getTask(b);
            if (d) {
                d.onAssignmentStructureMutation(e)
            }
        })
    },
    onDependencyUpdate: function (b, c, a) {
        if (a !== Ext.data.Model.COMMIT) {
            this.onDependencyAdd(b, c)
        }
    },
    onDependencyAdd: function (a, c) {
        this.resetEarlyDates();
        this.resetLateDates();
        if (this.cascadeChanges && !this.suspendAutoCascade) {
            var b = this, d = [];
            if (Ext.isArray(c)) {
                Ext.Array.forEach(c, function (e) {
                    var f = e.getSourceTask();
                    f && d.push(f)
                });
                d.length && b.getRoot().propagateChanges(function () {
                    return d
                })
            } else {
                d = c.getSourceTask();
                d && d.propagateChanges()
            }
        }
    },
    onDependencyDelete: function (a, b) {
        this.resetEarlyDates();
        this.resetLateDates()
    },
    onTaskStoreWrite: function (c, b) {
        var d = this, a = b.getRecords(), e;
        Ext.Array.forEach(a, function (f) {
            Ext.each(f.childNodes, function (g) {
                if (g.phantom) {
                    e = true;
                    return false
                }
            })
        });
        if (e && !this.autoSync) {
            setTimeout(function () {
                d.sync()
            }, 1)
        }
    },
    forEachTaskUnordered: function (c, b) {
        var a = this.getRootNode();
        if (a) {
            a.cascadeBy(function (d) {
                if (d !== a) {
                    return c.call(b || this, d)
                }
            })
        }
    },
    getTimeSpanForTasks: function (d) {
        var a = new Date(9999, 0, 1), b = new Date(0);
        var c = function (f) {
            var e = f.getStartDate();
            var g = f.getEndDate();
            if (e && e < a) {
                a = e
            }
            if (e && g && g > b) {
                b = g
            }
        };
        if (d) {
            if (!Ext.isArray(d)) {
                d = [d]
            }
            Ext.Array.each(d, c)
        } else {
            this.forEachTaskUnordered(c)
        }
        a = a < new Date(9999, 0, 1) ? a : null;
        b = b > new Date(0) ? b : null;
        return {start: a, end: b || (a && Ext.Date.add(a, Ext.Date.DAY, 1)) || null}
    },
    getTotalTimeSpan: function () {
        if (this.lastTotalTimeSpan) {
            return this.lastTotalTimeSpan
        }
        this.lastTotalTimeSpan = this.getTimeSpanForTasks();
        return this.lastTotalTimeSpan
    },
    getProjectStartDate: function () {
        return this.getTotalTimeSpan().start
    },
    getProjectEndDate: function () {
        return this.getTotalTimeSpan().end
    },
    getProjects: function () {
        var b = this.getRoot(), d = [], e = b.childNodes;
        for (var c = 0, a = e.length; c < a; c++) {
            if (e[c].isProject) {
                d.push(e[c])
            }
        }
        return d
    },
    getTotalTaskCount: function (b) {
        var a = b === false ? 1 : 0;
        this.forEachTaskUnordered(function () {
            a++
        });
        return a
    },
    toArray: function () {
        var a = [];
        this.getRootNode().cascadeBy(function (b) {
            a.push(b)
        });
        return a
    },
    indent: function (a) {
        this.fireEvent("beforeindentationchange", this, a);
        a = Ext.isArray(a) ? a.slice() : [a];
        a.sort(function (d, c) {
            return d.data.index - c.data.index
        });
        this.suspendEvents(true);
        Ext.Array.forEach(a, function (b) {
            b.indent()
        });
        this.resumeEvents();
        this.fireEvent("indentationchange", this, a)
    },
    outdent: function (a) {
        this.fireEvent("beforeindentationchange", this, a);
        a = Ext.isArray(a) ? a.slice() : [a];
        a.sort(function (d, c) {
            return c.data.index - d.data.index
        });
        this.suspendEvents(true);
        Ext.Array.forEach(a, function (b) {
            b.outdent()
        });
        this.resumeEvents();
        this.fireEvent("indentationchange", this, a)
    },
    getTasksForResource: function (a) {
        return this.getEventsForResource(a)
    },
    getResourcesForTask: function (a) {
        return this.getResourcesForEvent(a)
    },
    forEachScheduledEvent: function (b, a) {
        a = a || this;
        this.forEachTaskUnordered(function (e) {
            var d = e.getStartDate(), c = e.getEndDate();
            if (d && c) {
                return b.call(a, e, d, c)
            }
        })
    },
    onTasksSorted: function () {
        if (this.lastTreeFilter) {
            this.filterTreeBy(this.lastTreeFilter)
        }
    },
    append: function (a) {
        return this.getRootNode().appendChild(a)
    },
    resetEarlyDates: function (a) {
        this.earlyStartDates = {};
        this.earlyEndDates = {};
        if (!a) {
            this.fireEvent("resetearlydates")
        }
    },
    resetLateDates: function (a) {
        this.lateStartDates = {};
        this.lateEndDates = {};
        if (!a) {
            this.fireEvent("resetlatedates")
        }
    },
    getBySequenceNumber: function (a) {
        return this.getRootNode().getBySequenceNumber(a)
    },
    destroy: function () {
        this.setCalendar(null);
        this.setAssignmentStore(null);
        this.setDependencyStore(null);
        this.setResourceStore(null);
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy()
        }
        this.callParent(arguments)
    },
    moveSeveralTasks: function (b) {
        var d = this.startBatchCascade();
        var a;
        while (a = b()) {
            var c = a.task;
            if (c.isLeaf() || !c.childNodes.length) {
                if (!d.affected[c.internalId]) {
                    d.addAffected(c);
                    a.method && c[a.method].apply(c, a.args);
                    if (this.cascadeChanges) {
                        this.cascadeChangesForTask(c)
                    }
                }
            } else {
                if (this.recalculateParents) {
                    d.addAffected(c)
                }
            }
        }
        this.endBatchCascade()
    },
    linearWalkDependentTasks: function (d, a, c) {
        var b = this;
        c = c || {
                self: true,
                ancestors: b.recalculateParents,
                descendants: b.moveParentAsGroup,
                successors: b.cascadeChanges,
                cycles: b.cycleResolutionStrategy
            };
        return Gnt.data.Linearizator.linearWalkBySpecification(d, a, c)
    },
    getLinearWalkingSequenceForDependentTasks: function (c, b) {
        var a = [];
        this.linearWalkDependentTasks(c, function (f, e, d, g) {
            a.push(Array.prototype.slice.call(arguments))
        }, b);
        return a
    },
    isVisible: function (c) {
        var a = c.parentNode, d = c.get("visible"), b = this.getRoot();
        while (d && a) {
            d = a.get("expanded") && a.get("visible");
            a = a.parentNode
        }
        return d && !(c === b && !this.getRootVisible())
    }
}, function () {
    this.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {})
});
Ext.define("Gnt.data.ResourceStore", {
    requires: ["Gnt.model.Resource"],
    extend: "Sch.data.ResourceStore",
    storeId: "resources",
    model: "Gnt.model.Resource",
    alias: "store.gantt_resourcestore",
    taskStore: null,
    proxy: "memory",
    constructor: function (a) {
        this.callParent([a]);
        this.on({load: this.normalizeResources, remove: this.onResourceRemoved, priority: 100})
    },
    normalizeResources: function () {
        this.each(function (b) {
            if (!b.normalized) {
                var a = b.getCalendarId();
                if (a) {
                    b.setCalendarId(a, true)
                }
                b.normalized = true
            }
        })
    },
    onResourceRemoved: function (a, c) {
        var b = this.getAssignmentStore();
        Ext.Array.each(c, function (d) {
            b.removeAssignmentsForResource(d)
        })
    },
    getTaskStore: function () {
        return this.taskStore
    },
    setTaskStore: function (a) {
        this.taskStore = a
    },
    getAssignmentStore: function () {
        var a = this.getTaskStore();
        return a && a.getAssignmentStore() || null
    },
    getDependencyStore: function () {
        var a = this.getTaskStore();
        return a && a.getDependencyStore() || null
    }
});
Ext.define("Gnt.data.AssignmentStore", {
    extend: "Sch.data.AssignmentStore",
    requires: ["Gnt.model.Assignment"],
    model: "Gnt.model.Assignment",
    alias: "store.gantt_assignmentstore",
    storeId: "assignments",
    proxy: "memory",
    attachToEventStore: Ext.emptyFn,
    attachToResourceStore: Ext.emptyFn,
    getTaskStore: function () {
        return this.getEventStore()
    },
    setTaskStore: function (a) {
        return this.setEventStore(a)
    },
    mapAssignmentsForTask: function (a, b, c) {
        return this.mapAssignmentsForEvent(a, b, c)
    },
    getAssignmentsForTask: function (a) {
        return this.getAssignmentsForEvent(a)
    },
    removeAssignmentsForTask: function (a) {
        return this.removeAssignmentsForEvent(a)
    },
    getResourcesForTask: function (a) {
        return this.getResourcesForEvent(a)
    },
    getTasksForResource: function (a) {
        return this.getEventsForResource(a)
    },
    assignTaskToResource: function (b, c, a) {
        return this.assignEventToResource(b, c, function (d) {
            d.setUnits(a);
            return d
        })
    },
    unassignTaskFromResource: function (a, b) {
        return this.unassignEventFromResource(a, b)
    },
    isTaskAssignedToResource: function (a, c, b) {
        return this.isEventAssignedToResource(a, c, b)
    },
    getAssignmentForTaskAndResource: function (a, b) {
        return this.getAssignmentForEventAndResource(a, b)
    }
});
Ext.define("Gnt.data.CrudManager", {
    extend: "Sch.crud.AbstractManager",
    mixins: ["Sch.crud.encoder.Json", "Sch.crud.transport.Ajax"],
    calendarManager: null,
    taskStore: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    addRelatedStores: true,
    constructor: function (d) {
        d = d || {};
        var c = d.calendarManager || this.calendarManager, h = d.taskStore || this.taskStore, g = d.assignmentStore || this.assignmentStore, i = d.resourceStore || this.resourceStore, a = d.dependencyStore || this.dependencyStore, j = [];
        if (h && d.addRelatedStores !== false) {
            var f = this.getTaskStoreInfo(h, d);
            c = c || f.calendarManager;
            g = g || f.assignmentStore;
            i = i || f.resourceStore;
            a = a || f.dependencyStore
        }
        if (c) {
            this.mixins.observable.constructor.call(this, d);
            this.addCalendarManager(c, j)
        }
        if (i) {
            j.push(i)
        }
        if (g) {
            j.push(g)
        }
        if (a) {
            j.push(a)
        }
        if (h) {
            j.push(h)
        }
        if (j.length) {
            var b = [];
            if (c) {
                b.push(c)
            }
            if (i) {
                b.push(i)
            }
            if (h) {
                b.push(h)
            }
            if (g) {
                b.push(g)
            }
            if (a) {
                b.push(a)
            }
            if (b.length) {
                d.syncApplySequence = (d.syncApplySequence || d.stores || []).concat(b)
            }
            var e = d.stores || this.stores;
            if (e && !Ext.isArray(e)) {
                e = [e]
            }
            d.stores = (e || []).concat(j)
        }
        this.callParent([d]);
        this.calendarManager = this.getStoreDescriptor(c);
        this.resourceStore = this.getStoreDescriptor(i);
        this.assignmentStore = this.getStoreDescriptor(g);
        this.dependencyStore = this.getStoreDescriptor(a);
        this.taskStore = this.getStoreDescriptor(h)
    },
    getTaskStoreInfo: function (e, d) {
        if (!(e instanceof Ext.data.AbstractStore)) {
            if (typeof e == "string") {
                e = Ext.data.StoreManager.get(e)
            } else {
                e = e.store
            }
        }
        var a = {}, b = d.calendarManager, g = d.assignmentStore, f = d.resourceStore, c = d.dependencyStore;
        if (!b) {
            a.calendarManager = e.calendarManager
        }
        if (!g) {
            a.assignmentStore = e.getAssignmentStore()
        }
        if (!f) {
            a.resourceStore = e.getResourceStore()
        }
        if (!c) {
            a.dependencyStore = e.getDependencyStore()
        }
        return a
    },
    addCalendarManager: function (c, a) {
        var b, e;
        if (c instanceof Ext.data.AbstractStore) {
            b = c;
            e = {store: c}
        } else {
            if (typeof c == "object") {
                b = c.store;
                e = c
            } else {
                c = Ext.data.StoreManager.get(c);
                b = c;
                e = {store: c}
            }
        }
        var d = (b.getModel && b.getModel() || b.model).prototype;
        if (!e.stores) {
            e.stores = [{storeId: d.daysField, idProperty: d.idProperty}]
        }
        this.calendarManager = e;
        b.on("load", this.onCalendarManagerLoad, this);
        this.mon(b, {
            dayadd: this.onStoreChange,
            dayupdate: this.onStoreChange,
            dayremove: this.onStoreChange,
            daybulkremove: this.onStoreChange,
            scope: this
        });
        a.push(e)
    },
    onCalendarManagerLoad: function (b) {
        var d = b.getProjectCalendar(), c = d && d.getCalendarId(), a = b.metaData && b.metaData.projectCalendar;
        if (c != a) {
            b.setProjectCalendar(a)
        }
    },
    applyLoadResponse: function () {
        var a = this.getCalendarManager();
        a && a.suspendCalendarsEvents();
        this.callParent(arguments);
        a && a.resumeCalendarsEvents()
    },
    getCalendarManager: function () {
        return this.calendarManager && this.calendarManager.store
    },
    getResourceStore: function () {
        return this.resourceStore && this.resourceStore.store
    },
    getDependencyStore: function () {
        return this.dependencyStore && this.dependencyStore.store
    },
    getAssignmentStore: function () {
        return this.assignmentStore && this.assignmentStore.store
    },
    getTaskStore: function () {
        return this.taskStore && this.taskStore.store
    },
    prepareUpdated: function (e, k, h) {
        if (e[0]instanceof Gnt.model.Task) {
            e = Ext.Array.filter(e, function (i) {
                return !i.isRoot()
            });
            var n = this.callParent([e, k, h]);
            if (this.resetIdsBeforeSync) {
                var f = e[0].segmentsField, c = Ext.ClassManager.get(e[0].segmentClassName).prototype, m = c.idProperty, l = c.phantomIdField;
                for (var b = 0; b < n.length; b++) {
                    var g = n[b][f];
                    if (g) {
                        for (var a = 0; a < g.length; a++) {
                            var d = g[a];
                            if (d[l]) {
                                delete d[m]
                            }
                        }
                    }
                }
            }
            return n
        }
        return this.callParent(arguments)
    },
    prepareAdded: function (g) {
        var a = this.callParent(arguments);
        if (this.resetIdsBeforeSync && g[0]instanceof Gnt.model.Task) {
            var c = g[0].segmentsField, e = Ext.ClassManager.get(g[0].segmentClassName).prototype.idProperty;
            for (var f = 0; f < a.length; f++) {
                var b = a[f][c];
                if (b) {
                    for (var d = 0; d < b.length; d++) {
                        delete b[d][e]
                    }
                }
            }
        }
        return a
    },
    applyChangesToTask: function (e, k) {
        if (k.hasOwnProperty(e.segmentsField)) {
            var d = e.getSegments(), h = e.segmentsField, m = d && d[0].phantomIdField, n = d && d[0].idProperty, g = k[h];
            if (g && g.length) {
                for (var c = g.length - 1; c >= 0; c--) {
                    var l = g[c], o = l[m], a = l[n], f = null;
                    for (var b = 0; b < d.length; b++) {
                        f = d[b];
                        if ((f.get(m) == o) || (f.getId() == a)) {
                            this.applyChangesToRecord(f, l);
                            break
                        }
                    }
                }
                delete k[h]
            }
        }
    },
    applyChangesToRecord: function (b, c, a) {
        if (b instanceof Gnt.model.Task) {
            this.ignoreUpdates++;
            this.applyChangesToTask.apply(this, arguments);
            this.ignoreUpdates--
        }
        this.callParent(arguments)
    }
});
Ext.define("Gnt.template.Template", {
    extend: "Ext.XTemplate",
    isLegacyIE: Ext.isIE8m,
    getInnerTpl: Ext.emptyFn,
    innerTpl: null,
    dependencyTerminalMarkup: '<div class="sch-gantt-terminal sch-gantt-terminal-start"></div><div class="sch-gantt-terminal sch-gantt-terminal-end"></div>',
    constructor: function (a) {
        Ext.apply(this, a);
        var c = a.rtl ? "right" : "left";
        var b = this.getInnerTpl(a) || "";
        this.callParent(['<div class="sch-event-wrap {ctcls} ' + Ext.baseCSSPrefix + 'unselectable" style="' + c + ':{offset}px">', '<tpl if="isRollup">', b, "<tpl else>", (a.leftLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{leftLabel}</label></div>' : ""), (a.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : ""), (a.topLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-top"><label class="sch-gantt-label sch-gantt-label-top">{topLabel}</label></div>' : ""), b, (a.bottomLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-bottom"><label class="sch-gantt-label sch-gantt-label-bottom">{bottomLabel}</label></div>' : ""), "</tpl>", "</div>", {disableFormats: true}])
    }
});
Ext.define("Gnt.template.Task", {
    extend: "Gnt.template.Template",
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}" unselectable="on">&#160;</div>',
    getInnerTpl: function (a) {
        var b = a.rtl ? "right" : "left";
        return '<div id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-task-bar {cls}" unselectable="on" style="width:{width}px;{style}"><tpl if="isRollup"><tpl else><tpl if="segments"><div class="sch-gantt-segment-connector"></div></tpl>' + ((a.resizeHandles === "both" || a.resizeHandles === "left") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-start"></div>' : "") + '<tpl for="segments"><div id="' + a.prefix + '{parent.Id}-segment-{[xindex-1]}" class="sch-gantt-task-segment {cls}" style="left:{left}px;width:{width}px;{style}" data-segmentIndex="{[xindex-1]}">' + this.innerTpl + ((a.resizeHandles === "both" || a.resizeHandles === "right") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : "") + "</div></tpl>" + this.innerTpl + ((a.resizeHandles === "both" || a.resizeHandles === "right") ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : "") + (a.enableProgressBarResize ? '<div style="' + b + ':{progressBarWidth}px" class="sch-gantt-progressbar-handle"></div>' : "") + (a.enableDependencyDragDrop ? this.dependencyTerminalMarkup : "") + "</tpl></div>"
    }
});
Ext.define("Gnt.template.Milestone", {
    extend: "Gnt.template.Template",
    innerTpl: (Ext.isIE8m ? ('<div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-top {cls}" unselectable="on"></div><div style="border-width:{[Math.floor(values.side*0.7)]}px;{style}" class="sch-gantt-milestone-diamond-bottom {cls}" unselectable="on"></div>') : ('<img style="{[values.print ? "height:" + values.side + "px;border-left-width:" + values.side + "px" : ""]};{style}" src="' + Ext.BLANK_IMAGE_URL + '" class="sch-gantt-milestone-diamond {cls}" unselectable="on"/>')),
    getInnerTpl: function (a) {
        return "<div " + (this.isLegacyIE ? 'style="width:{[Math.floor(values.side*0.7)]}px"' : "") + ' id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-milestone-diamond-ct">' + this.innerTpl + '<tpl if="isRollup"><tpl else>' + (a.enableDependencyDragDrop ? this.dependencyTerminalMarkup : "") + "</tpl></div>"
    }
});
Ext.define("Gnt.template.ParentTask", {
    extend: "Gnt.template.Template",
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}">&#160;</div><div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-leftarrow"></div><div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-rightarrow"></div>',
    getInnerTpl: function (a) {
        return '<div id="' + a.prefix + '{id}" class="sch-gantt-item sch-gantt-parenttask-bar {cls}" style="width:{width}px; {style}">' + this.innerTpl + ((a.enableDependencyDragDrop && a.allowParentTaskDependencies) ? this.dependencyTerminalMarkup : "") + "</div>"
    }
});
Ext.define("Gnt.template.RollupTask", {
    extend: "Ext.XTemplate",
    isLegacyIE: Ext.isIE8m,
    tplConfig: null,
    constructor: function (a) {
        Ext.apply(this, a);
        var b = ['<div class="sch-rollup-wrap">', '<tpl for=".">', "{[values.tpl.apply(values)]}", "</tpl>", "</div>"];
        this.tplConfig = Ext.apply(this.tplConfig || {}, {disableFormats: true, applyRollup: this.applyRollup});
        this.callParent(b.concat([this.tplConfig]))
    }
});
Ext.define("Gnt.Tooltip", {
    extend: "Ext.ToolTip",
    alias: "widget.gantt_task_tooltip",
    requires: ["Ext.Template"],
    mixins: ["Gnt.mixin.Localizable"],
    mode: "startend",
    autoHide: false,
    anchor: "b-tl",
    maskOnDisable: false,
    template: null,
    initComponent: function () {
        this.rtl = this.gantt.rtl;
        if (this.mode === "startend" && !this.template) {
            this.template = new Ext.Template('<div class="sch-timetipwrap {cls}"><table cellpadding="0" cellspacing="0"><tr><td class="sch-gantt-tip-desc">' + this.L("startText") + '</td><td class="sch-gantt-tip-value">{startText}</td></tr><tr><td class="sch-gantt-tip-desc">' + this.L("endText") + '</td><td class="sch-gantt-tip-value">{endText}</td></tr></table></div>').compile()
        }
        if (this.mode === "duration" && !this.template) {
            this.template = new Ext.Template('<div class="sch-timetipwrap {cls}">', '<table cellpadding="0" cellspacing="0"><tr><td class="sch-gantt-tip-desc">' + this.L("startText") + '</td><td class="sch-gantt-tip-value"> {startText}</td></tr>', '<tr><td class="sch-gantt-tip-desc">' + this.L("durationText") + '</td><td class="sch-gantt-tip-value"> {duration} {unit}</td></tr>', "</table></div>").compile()
        }
        this.callParent(arguments);
        this.update(this.template.apply({}));
        this.addCls("gnt-tooltip")
    },
    updateContent: function (e, b, d, a) {
        var c;
        if (this.mode === "duration") {
            c = this.getDurationContent(e, b, d, a)
        } else {
            c = this.getStartEndContent(e, b, d, a)
        }
        this.update(c)
    },
    getStartEndContent: function (h, b, f, a) {
        var c = this.gantt, e = c.getFormattedDate(h), d = e;
        if (b - h > 0) {
            d = c.getFormattedEndDate(b, h)
        }
        var g = {cls: f ? "sch-tip-ok" : "sch-tip-notok", startText: e, endText: d, task: a};
        return this.template.apply(g)
    },
    getDurationContent: function (f, b, d, a) {
        var c = a.getDurationUnit() || Sch.util.Date.DAY;
        var e = a.calculateDuration(f, b, c);
        return this.template.apply({
            cls: d ? "sch-tip-ok" : "sch-tip-notok",
            startText: this.gantt.getFormattedDate(f),
            duration: parseFloat(Ext.Number.toFixed(e, 1)),
            unit: Sch.util.Date.getReadableNameOfUnit(c, e > 1),
            task: a
        })
    },
    show: function (a, b) {
        if (a && (a.dom || a.className)) {
            this.setTarget(a)
        }
        this.callParent([]);
        if (b !== undefined) {
            this.setX(b)
        }
    }
});
Ext.define("Gnt.feature.TaskDragDrop", {
    extend: "Ext.dd.DragZone",
    requires: ["Gnt.Tooltip", "Ext.dd.StatusProxy"],
    useTooltip: true,
    tooltipConfig: null,
    validatorFn: function (a, b, d, c) {
        return true
    },
    validatorFnScope: null,
    showExactDropPosition: false,
    containerScroll: false,
    dropAllowed: "sch-gantt-dragproxy",
    dropNotAllowed: "sch-gantt-dragproxy",
    valid: false,
    gantt: null,
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    tip: null,
    constructor: function (c, b) {
        b = b || {};
        Ext.apply(this, b);
        if (Ext.isIE && (Ext.isIE8 || Ext.ieVersion < 9) && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true
        }
        this.proxy = this.proxy || new Ext.dd.StatusProxy({
                shadow: false,
                dropAllowed: "sch-gantt-dragproxy",
                dropNotAllowed: "sch-gantt-dragproxy",
                ensureAttachedToBody: Ext.emptyFn
            });
        this.gantt.rtl && this.proxy.addCls("sch-rtl");
        var d = this, a = d.gantt;
        if (d.useTooltip) {
            d.tip = new Gnt.Tooltip(Ext.apply({cls: "gnt-dragdrop-tip", gantt: a}, d.tooltipConfig))
        }
        d.callParent([c, Ext.apply(b, {ddGroup: a.id + "-task-dd"})]);
        d.scroll = false;
        d.isTarget = true;
        d.ignoreSelf = false;
        d.addInvalidHandleClass("sch-resizable-handle");
        d.addInvalidHandleClass(Ext.baseCSSPrefix + "resizable-handle");
        d.addInvalidHandleClass("sch-gantt-terminal");
        d.addInvalidHandleClass("sch-gantt-progressbar-handle");
        d.addInvalidHandleClass("sch-rollup-task");
        a.ownerCt.el.appendChild(this.proxy.el);
        a.on({destroy: d.destroy, scope: d})
    },
    destroy: function () {
        if (this.tip) {
            this.tip.destroy()
        }
        this.callParent(arguments)
    },
    getDragData: function (s) {
        var q = this.gantt;
        var p = s.getTarget(q.eventSelector);
        if (p && !s.getTarget(".sch-gantt-baseline-item")) {
            var b = s.getTarget(".sch-gantt-task-segment");
            var v = q.resolveTaskRecord(p);
            var f;
            var r, d, j;
            if (v.isReadOnly()) {
                return null
            }
            if (b) {
                f = parseInt(b.getAttribute("data-segmentIndex"), 10);
                if (f === 0) {
                    r = p
                } else {
                    r = b
                }
            } else {
                r = p
            }
            var w = v.isMilestone(), i;
            if (f > 0) {
                v = v.getSegment(f)
            }
            if (q.fireEvent("beforetaskdrag", q, v, s) === false) {
                return null
            }
            var a = s.getXY();
            var o = r.cloneNode(true), t = this.showExactDropPosition ? 0 : q.getSnapPixelAmount(), m = Ext.fly(r).getXY();
            var c = [a[0] - m[0], a[1] - m[1]];
            o.id = Ext.id();
            var l = Ext.fly(r).getHeight();
            var n = Ext.fly(r).getWidth();
            var u = 0;
            Ext.fly(o).setHeight(l - u);
            if (Ext.isIE8m && w) {
                Ext.fly(o).setSize(l + 5, l + 5)
            }
            if (!q.rtl) {
                o.style.left = -c[0] + "px"
            } else {
                o.style.left = n - c[0] + "px"
            }
            if (f > 0) {
                var k = v.getPrevSegment();
                var h = v.getNextSegment();
                d = Sch.util.Date.max(k.getEndDate(), q.timeAxis.getStart());
                j = h ? Sch.util.Date.min(h.getStartDate(), q.timeAxis.getEnd()) : q.timeAxis.getEnd();
                i = {
                    left: q.getCoordinateFromDate(d, false) + c[0],
                    right: q.getCoordinateFromDate(j, false) - n + c[0]
                }
            } else {
                i = Ext.fly(q.findItemByChild(r)).getRegion()
            }
            this.constrainTo(i, Ext.fly(r).getRegion(), c[0], c[1]);
            this.valid = false;
            if (t >= 1) {
                this.setXConstraint(this.leftConstraint, this.rightConstraint, t)
            }
            return {
                sourceNode: r,
                repairXY: m,
                offsets: c,
                ddel: o,
                record: v,
                duration: Sch.util.Date.getDurationInMinutes(v.getStartDate(), v.getEndDate()),
                sourceDate: q.getDateFromCoordinate(a[0]),
                minDate: d,
                maxDate: j,
                origStart: v.getStartDate(),
                start: null
            }
        }
        return null
    },
    autoOffset: function (a, b) {
        this.setDelta(0, 0)
    },
    setXConstraint: function (c, b, a) {
        this.leftConstraint = c;
        this.rightConstraint = b;
        this.minX = c;
        this.maxX = b;
        if (a) {
            this.setXTicks(this.initPageX, a)
        }
        this.constrainX = true
    },
    setYConstraint: function (a, c, b) {
        this.topConstraint = a;
        this.bottomConstraint = c;
        this.minY = a;
        this.maxY = c;
        if (b) {
            this.setYTicks(this.initPageY, b)
        }
        this.constrainY = true
    },
    constrainTo: function (b, c, a, d) {
        this.resetConstraints();
        this.initPageX = b.left + a;
        this.initPageY = c.top + d;
        this.setXConstraint(b.left, b.right, this.xTickSize);
        this.setYConstraint(c.top - 1, c.top - 1, this.yTickSize)
    },
    onDragOver: function (m) {
        var i = this.dragData, c = i.record, d = this.gantt;
        if (!i.hidden) {
            Ext.fly(i.sourceNode).hide();
            i.hidden = true
        }
        var a = d.getDateFromCoordinate(m.getXY()[0]) - i.sourceDate;
        var o = new Date(i.origStart - 0 + a);
        var g = this.proxy.el;
        var j;
        if (i.minDate) {
            o = Sch.util.Date.constrain(new Date(i.origStart - 0 + a), i.minDate, i.maxDate)
        }
        if (d.timeAxis.isContinuous()) {
            j = d.timeAxis.roundDate(o, d.snapRelativeToEventStartDate ? i.origStart : false)
        } else {
            var n = g.getX() + (d.rtl ? g.getWidth() : 0) + d.getXOffset(c) - i.offsets[0];
            j = d.getDateFromXY([n, 0], "round")
        }
        if (this.showExactDropPosition && d.taskStore.skipWeekendsDuringDragDrop) {
            var b = Ext.fly(i.ddel.id);
            var k = 0;
            var l = c.skipNonWorkingTime(j, !c.isMilestone());
            if (o.getTime() != l.getTime()) {
                k = d.timeAxisViewModel.getDistanceBetweenDates(o, l)
            }
            var f = c.recalculateEndDate(l);
            if (o > d.timeAxis.getStart()) {
                b.setWidth(d.timeAxisViewModel.getDistanceBetweenDates(l, Sch.util.Date.min(f, d.timeAxis.getEnd())));
                if (k) {
                    g.setX(g.getX() + k)
                }
            }
        }
        if (!j || j - i.start === 0) {
            return
        }
        i.start = j;
        this.valid = this.validatorFn.call(this.validatorFnScope || d, c, j, i.duration, m) !== false;
        if (this.tip) {
            var h = c.calculateEndDate(j, c.getDuration(), c.getDurationUnit());
            this.updateTip(c, j, h, this.valid)
        }
    },
    startDrag: function () {
        var a = Ext.dd.ScrollManager;
        this.gantt.el.ddScrollConfig = {increment: a.increment, hthresh: a.hthresh, vthresh: -1};
        return this.callParent(arguments)
    },
    endDrag: function () {
        delete this.gantt.el.ddScrollConfig;
        return this.callParent(arguments)
    },
    onStartDrag: function () {
        var b = this.dragData.record;
        var a = this.tip;
        if (a) {
            a.enable();
            a.show(this.proxy.el);
            this.updateTip(b, b.getStartDate(), b.getEndDate())
        }
        this.gantt.fireEvent("taskdragstart", this.gantt, b)
    },
    updateTip: function (b, d, a, c) {
        c = c !== false;
        if (b.isMilestone() && d - Ext.Date.clearTime(d, true) === 0) {
            d = Sch.util.Date.add(d, Sch.util.Date.MILLI, -1);
            a = Sch.util.Date.add(a, Sch.util.Date.MILLI, -1)
        }
        this.tip.updateContent(d, a, c, b)
    },
    afterRepair: function () {
        Ext.fly(this.dragData.sourceNode).show();
        if (this.tip) {
            this.tip.hide()
        }
        this.dragging = false
    },
    getRepairXY: function () {
        this.gantt.fireEvent("aftertaskdrop", this.gantt);
        return this.dragData.repairXY
    },
    onDragDrop: function (g, a) {
        var i = this, h = i.cachedTarget || Ext.dd.DragDropMgr.getDDById(a), f = i.dragData, d = i.gantt, c = f.record, b = f.start, j = true;
        f.ddCallbackArgs = [h, g, a];
        if (this.tip) {
            this.tip.disable()
        }
        if (this.valid && b && c.getStartDate() - b !== 0) {
            f.finalize = function () {
                i.finalize.apply(i, arguments)
            };
            j = d.fireEvent("beforetaskdropfinalize", d, f, g) !== false
        }
        if (j) {
            this.finalize(this.valid)
        }
    },
    finalize: function (c) {
        var e = this, f = this.dragData, b = this.gantt, a = f.record, h = f.start, d, g;
        if (c) {
            d = a.getStartDate();
            a.setStartDate(h, true, b.taskStore.skipWeekendsDuringDragDrop, function (j, i) {
                g = a.getStartDate();
                if (d < g || d > g) {
                    b.fireEvent("taskdrop", b, a);
                    if (Ext.isIE9) {
                        e.proxy.el.setStyle("visibility", "hidden");
                        Ext.Function.defer(e.onValidDrop, 10, e, f.ddCallbackArgs)
                    } else {
                        e.onValidDrop.apply(e, f.ddCallbackArgs)
                    }
                } else {
                    e.onInvalidDrop.apply(e, f.ddCallbackArgs)
                }
                b.fireEvent("aftertaskdrop", b, a)
            })
        } else {
            e.onInvalidDrop.apply(e, f.ddCallbackArgs);
            b.fireEvent("aftertaskdrop", b, a)
        }
    },
    onInvalidDrop: function (b, a, c) {
        if (Ext.isIE && !a) {
            a = b;
            b = b.getTarget() || document.body
        }
        return this.callParent([b, a, c])
    }
});
Ext.define("Gnt.feature.DependencyDragZone", {
    extend: "Ext.dd.DragZone",
    mixins: {observable: "Ext.util.Observable"},
    rtl: null,
    useLineProxy: null,
    terminalSelector: null,
    ganttView: null,
    fromText: null,
    toText: null,
    startText: null,
    endText: null,
    toolTipTpl: null,
    constructor: function (b, a) {
        this.mixins.observable.constructor.call(this, a);
        this.callParent(arguments)
    },
    initLineProxy: function (c, b) {
        var e = this.lineProxyEl = this.lineProxyEl || this.el.createChild({cls: "sch-gantt-connector-proxy"});
        var f = Ext.isIE9m ? 0 : 4;
        var d = this.rtl ? (b ? "r" : "l") : (b ? "l" : "r");
        var a = this.ganttView.getScroll();
        e.alignTo(c, d, [b ? -f : f, 0]);
        Ext.apply(this, {
            containerTop: this.el.getTop(),
            containerLeft: this.el.getLeft(),
            startXY: e.getXY(),
            startScrollLeft: a.left,
            startScrollTop: a.top
        })
    },
    onDrag: function (b, a) {
        if (this.useLineProxy) {
            this.updateLineProxy(b.getXY())
        }
    },
    updateLineProxy: function (n) {
        var a = this.lineProxyEl, k = this.ganttView.getScroll(), j = n[0] - this.startXY[0] + k.left - this.startScrollLeft, i = n[1] - this.startXY[1] + k.top - this.startScrollTop, b = Math.max(1, Math.sqrt(Math.pow(j, 2) + Math.pow(i, 2)) - 2), h = Math.atan2(i, j) - (Math.PI / 2), e;
        if (Ext.isIE9m) {
            var l = Math.cos(h), g = Math.sin(h), m = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + l + ", M12 = " + (-g) + ", M21 = " + g + ", M22 = " + l + ")", d, f;
            if (k.top !== this.startScrollTop) {
                d = this.startScrollTop - this.containerTop
            } else {
                d = k.top - this.containerTop
            }
            if (k.left !== this.startScrollLeft) {
                f = this.startScrollLeft - this.containerLeft
            } else {
                f = k.left - this.containerLeft
            }
            e = {
                height: b + "px",
                top: Math.min(0, i) + this.startXY[1] + d + (i < 0 ? 2 : 0) + "px",
                left: Math.min(0, j) + this.startXY[0] + f + (j < 0 ? 2 : 0) + "px",
                filter: m,
                "-ms-filter": m
            }
        } else {
            var c = "rotate(" + h + "rad)";
            e = {
                height: b + "px",
                "-o-transform": c,
                "-webkit-transform": c,
                "-ms-transform": c,
                "-moz-transform": c,
                transform: c
            }
        }
        a.setStyle(e)
    },
    onStartDrag: function () {
        this.el.addCls("sch-gantt-dep-dd-dragging");
        this.proxy.el.addCls("sch-dd-dependency-proxy");
        this.fireEvent("dndstart", this);
        if (this.useLineProxy) {
            var a = this.dragData;
            this.initLineProxy(a.sourceNode, a.isStart);
            this.lineProxyEl.show()
        }
    },
    getDragData: function (f) {
        var d = f.getTarget(this.terminalSelector);
        if (d) {
            var c = this.ganttView.resolveTaskRecord(d);
            if (this.fireEvent("beforednd", this, c) === false) {
                return null
            }
            var b = !!d.className.match("sch-gantt-terminal-start");
            var a = {
                fromLabel: this.fromText,
                fromTaskName: Ext.String.htmlEncode(c.getName()),
                fromSide: b ? this.startText : this.endText,
                toLabel: this.toText,
                toTaskName: "",
                toSide: ""
            };
            var g = Ext.core.DomHelper.createDom({html: this.toolTipTpl.apply(a)}).firstChild;
            return {
                fromId: c.getId() || c.internalId,
                tplData: a,
                isStart: b,
                repairXY: Ext.fly(d).getXY(),
                ddel: g,
                sourceNode: Ext.fly(d).up(this.ganttView.eventSelector)
            }
        }
        return false
    },
    afterRepair: function () {
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        this.dragging = false;
        this.fireEvent("afterdnd", this)
    },
    onMouseUp: function () {
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        if (this.lineProxyEl) {
            var b = Ext.isIE9m ? 0 : 400;
            var a = this.lineProxyEl;
            a.animate({
                to: {height: 0}, duration: b, callback: function () {
                    Ext.destroy(a)
                }
            });
            this.lineProxyEl = null
        }
    },
    getRepairXY: function () {
        return this.dragData.repairXY
    },
    destroy: function () {
        Ext.destroy(this.lineProxyEl);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.feature.DependencyDropZone", {
    extend: "Ext.dd.DropZone",
    mixins: {observable: "Ext.util.Observable"},
    terminalSelector: null,
    dependencyStore: null,
    toText: null,
    startText: null,
    endText: null,
    ganttView: null,
    constructor: function (b, a) {
        this.mixins.observable.constructor.call(this, a);
        this.callParent(arguments)
    },
    getTargetFromEvent: function (a) {
        return a.getTarget(this.terminalSelector)
    },
    onNodeEnter: function (d, a, c, b) {
        Ext.fly(d).addCls("sch-gantt-terminal-drophover")
    },
    onNodeOut: function (d, a, c, b) {
        Ext.fly(d).removeCls("sch-gantt-terminal-drophover");
        this.toolTipTpl.overwrite(a.proxy.el.down(".sch-dd-dependency"), b.tplData)
    },
    onNodeOver: function (d, j, f, c) {
        var a = this.ganttView.resolveTaskRecord(d), i = a.getId() || a.internalId, b = d.className.match("sch-gantt-terminal-start");
        var h = {};
        Ext.apply(h, {
            toLabel: this.toText,
            toTaskName: Ext.String.htmlEncode(a.getName()),
            toSide: b ? this.startText : this.endText
        }, c.tplData);
        this.toolTipTpl.overwrite(j.proxy.el.down(".sch-dd-dependency"), h);
        var g = this.resolveType(c.isStart, d);
        if (this.dependencyStore.isValidDependency(c.fromId, i, g)) {
            return this.dropAllowed
        } else {
            return this.dropNotAllowed
        }
    },
    onNodeDrop: function (i, a, h, f) {
        var d = this.resolveType(f.isStart, i), g, c = this.ganttView.resolveTaskRecord(i), b = c.getId() || c.internalId;
        this.el.removeCls("sch-gantt-dep-dd-dragging");
        g = this.dependencyStore.isValidDependency(f.fromId, b, d);
        if (g) {
            this.fireEvent("drop", this, f.fromId, b, d)
        }
        this.fireEvent("afterdnd", this);
        return g
    },
    resolveType: function (a, d) {
        var c = Gnt.model.Dependency.Type, b = d.className.match("sch-gantt-terminal-start");
        if (a && b) {
            return c.StartToStart
        }
        if (a && !b) {
            return c.StartToEnd
        }
        if (!a && b) {
            return c.EndToStart
        }
        return c.EndToEnd
    }
});
Ext.define("Gnt.feature.DependencyDragDrop", {
    extend: "Ext.util.Observable",
    mixins: {localizable: "Gnt.mixin.Localizable"},
    requires: ["Gnt.feature.DependencyDragZone", "Gnt.feature.DependencyDropZone", "Ext.XTemplate"],
    useLineProxy: true,
    dragZoneConfig: null,
    dropZoneConfig: null,
    toolTipTpl: ['<div class="sch-dd-dependency">', "<table><tbody>", "<tr>", '<td><span class="sch-dd-dependency-from">{fromLabel}:</span></td>', '<td><span class="sch-dd-dependency-from-name">{fromTaskName}</span> - {fromSide}</td>', "</tr>", "<tr>", '<td><span class="sch-dd-dependency-to">{toLabel}:</span></td>', '<td><span class="sch-dd-dependency-to-name">{toTaskName}</span> - {toSide}</td>', "</tr>", "</tbody></table>", "</div>"],
    terminalSelector: ".sch-gantt-terminal",
    el: null,
    rtl: null,
    ddGroup: null,
    ganttView: null,
    dependencyStore: null,
    constructor: function (b) {
        var a = b.ganttView;
        Ext.apply(this, b);
        this.ddGroup = a.id + "-sch-dependency-dd";
        this.el.on("mousemove", this.doSetup, this, {single: true});
        this.callParent(arguments)
    },
    doSetup: function () {
        var a = this;
        this.dragZone = new Gnt.feature.DependencyDragZone(this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            useLineProxy: this.useLineProxy,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            startText: this.L("startText"),
            endText: this.L("endText"),
            fromText: this.L("fromText"),
            toText: this.L("toText"),
            toolTipTpl: Ext.XTemplate.getTpl(this, "toolTipTpl")
        }, this.dragZoneConfig));
        this.relayEvents(this.dragZone, ["beforednd", "dndstart", "afterdnd"]);
        this.dropZone = Ext.create("Gnt.feature.DependencyDropZone", this.el, Ext.apply({
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            ddGroup: this.ddGroup,
            ganttView: this.ganttView,
            dependencyStore: this.dependencyStore,
            startText: this.L("startText"),
            endText: this.L("endText"),
            toText: this.L("toText"),
            toolTipTpl: Ext.XTemplate.getTpl(this, "toolTipTpl")
        }, this.dropZoneConfig));
        this.relayEvents(this.dropZone, ["drop", "afterdnd"]);
        this.configureAllowedSourceTerminals();
        if (this.dependencyStore.allowedDependencyTypes) {
            this.dragZone.on("dndstart", this.configureAllowedTargetTerminals, this)
        } else {
            this.el.addCls(["sch-gantt-terminal-allow-target-start", "sch-gantt-terminal-allow-target-end"])
        }
    },
    configureAllowedSourceTerminals: function () {
        var b = this.dependencyStore.allowedDependencyTypes;
        var a = ["sch-gantt-terminal-allow-source-start", "sch-gantt-terminal-allow-source-end"];
        if (b) {
            a = [];
            if (Ext.Array.indexOf(b, "EndToEnd") > -1 || Ext.Array.indexOf(b, "EndToStart") > -1) {
                a.push("sch-gantt-terminal-allow-source-end")
            }
            if (Ext.Array.indexOf(b, "StartToStart") > -1 || Ext.Array.indexOf(b, "StartToEnd") > -1) {
                a.push("sch-gantt-terminal-allow-source-start")
            }
        }
        this.el.addCls(a)
    },
    configureAllowedTargetTerminals: function () {
        var b = this.dependencyStore.allowedDependencyTypes;
        var a = [];
        this.el.removeCls(["sch-gantt-terminal-allow-target-start", "sch-gantt-terminal-allow-target-end"]);
        if (Ext.Array.contains(b, "EndToEnd") || Ext.Array.contains(b, "StartToEnd")) {
            a.push("sch-gantt-terminal-allow-target-end")
        }
        if (Ext.Array.contains(b, "StartToStart") || Ext.Array.contains(b, "EndToStart")) {
            a.push("sch-gantt-terminal-allow-target-start")
        }
        this.el.addCls(a)
    },
    destroy: function () {
        if (this.dragZone) {
            this.dragZone.destroy()
        }
        if (this.dropZone) {
            this.dropZone.destroy()
        }
    }
});
Ext.define("Gnt.feature.DragCreator", {
    requires: ["Ext.Template", "Sch.util.DragTracker", "Gnt.Tooltip"],
    constructor: function (a) {
        Ext.apply(this, a || {});
        this.init()
    },
    disabled: false,
    showDragTip: true,
    tooltipConfig: null,
    dragTolerance: 2,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    setDisabled: function (a) {
        this.disabled = a;
        if (this.dragTip) {
            this.dragTip.setDisabled(a)
        }
    },
    getProxy: function () {
        if (!this.proxy) {
            this.proxy = this.template.append(this.ganttView.ownerCt.el, {}, true)
        }
        return this.proxy
    },
    onBeforeDragStart: function (f) {
        var c = this.ganttView, b = f.getTarget("." + c.timeCellCls, 2);
        if (b) {
            var a = c.resolveTaskRecord(b);
            var d = c.getDateFromDomEvent(f);
            if (!this.disabled && !a.isReadOnly() && !a.getStartDate() && !a.getEndDate() && c.fireEvent("beforedragcreate", c, a, d, f) !== false) {
                f.stopEvent();
                this.record = a;
                this.originalStart = d;
                this.rowRegion = c.getScheduleRegion(this.record, this.originalStart);
                this.dateConstraints = c.getDateConstraints(this.resourceRecord, this.originalStart);
                return true
            }
        }
        return false
    },
    onDragStart: function () {
        var c = this, a = c.ganttView, b = c.getProxy();
        c.start = c.originalStart;
        c.end = c.start;
        c.rowBoundaries = {top: c.rowRegion.top, bottom: c.rowRegion.bottom};
        b.setBox({
            x: c.tracker.startXY[0],
            y: c.rowBoundaries.top,
            width: 1,
            height: c.rowBoundaries.bottom - c.rowBoundaries.top
        });
        b.show();
        c.ganttView.fireEvent("dragcreatestart", c.ganttView);
        if (c.showDragTip) {
            c.dragTip.updateContent(c.start, c.end, true, this.record);
            c.dragTip.enable();
            c.dragTip.show(b)
        }
    },
    onDrag: function (g) {
        var d = this, c = d.ganttView, b = d.tracker.getRegion().constrainTo(d.rowRegion), f = c.getStartEndDatesFromRegion(b, "round");
        if (!f) {
            return
        }
        d.start = f.start || d.start;
        d.end = f.end || d.end;
        var a = d.dateConstraints;
        if (a) {
            d.end = Sch.util.Date.constrain(d.end, a.start, a.end);
            d.start = Sch.util.Date.constrain(d.start, a.start, a.end)
        }
        d.valid = this.validatorFn.call(d.validatorFnScope || d, this.record, d.start, d.end, g) !== false;
        if (d.showDragTip) {
            d.dragTip.updateContent(d.start, d.end, d.valid, this.record)
        }
        Ext.apply(b, d.rowBoundaries);
        this.getProxy().setBox(b)
    },
    onDragEnd: function (d) {
        var c = this, a = c.ganttView, b = false;
        c.createContext = {
            start: c.start, end: c.end, e: d, record: c.record, finalize: function () {
                c.finalize.apply(c, arguments)
            }
        };
        if (c.showDragTip) {
            c.dragTip.disable()
        }
        if (!c.start || !c.end || (c.end < c.start)) {
            c.valid = false
        }
        if (c.valid) {
            b = a.fireEvent("beforedragcreatefinalize", c, c.createContext, d) !== false
        }
        if (b) {
            c.finalize(c.valid)
        }
    },
    finalize: function (b) {
        var d = this, c = d.createContext, a = d.ganttView;
        if (b) {
            c.record.setStartEndDate(c.start, c.end, c.record.getTaskStore().skipWeekendsDuringDragDrop);
            a.fireEvent("dragcreateend", a, c.record, c.e)
        }
        d.proxy.hide();
        a.fireEvent("afterdragcreate", a)
    },
    init: function () {
        var c = this.ganttView, a = c.el, b = Ext.Function.bind;
        this.lastTime = new Date();
        this.template = this.template || Ext.create("Ext.Template", '<div class="sch-gantt-dragcreator-proxy"></div>', {
                compiled: true,
                disableFormats: true
            });
        c.on({destroy: this.onGanttDestroy, scope: this});
        this.tracker = new Sch.util.DragTracker({
            el: a,
            tolerance: this.dragTolerance,
            onBeforeStart: b(this.onBeforeDragStart, this),
            onStart: b(this.onDragStart, this),
            onDrag: b(this.onDrag, this),
            onEnd: b(this.onDragEnd, this)
        });
        if (this.showDragTip) {
            this.dragTip = new Gnt.Tooltip(Ext.apply({
                mode: "duration",
                cls: "sch-gantt-dragcreate-tip",
                gantt: c
            }, this.tooltipConfig))
        }
    },
    onGanttDestroy: function () {
        if (this.dragTip) {
            this.dragTip.destroy()
        }
        if (this.tracker) {
            this.tracker.destroy()
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null
        }
    }
});
Ext.define("Gnt.feature.LabelEditor", {
    extend: "Ext.Editor",
    labelPosition: "",
    triggerEvent: "dblclick",
    delegate: null,
    dataIndex: null,
    shadow: false,
    completeOnEnter: true,
    cancelOnEsc: true,
    ignoreNoChange: true,
    constructor: function (b, a) {
        this.ganttView = b;
        this.ganttView.on("afterrender", this.onGanttRender, this);
        Ext.apply(this, a);
        if (this.labelPosition === "left") {
            this.alignment = "r-r"
        } else {
            if (this.labelPosition === "right") {
                this.alignment = "l-l"
            }
        }
        this.delegate = ".sch-gantt-label-" + this.labelPosition;
        this.callParent([a])
    },
    edit: function (c) {
        if (!c.isEditable(this.dataIndex)) {
            return
        }
        var a = this.ganttView.getElementFromEventRecord(c);
        if (a) {
            var e = a.up(this.ganttView.eventWrapSelector);
            var d, b;
            this.record = c;
            if (!this.rendered) {
                this.render(this.ganttView.getSecondaryCanvasEl())
            }
            if (Ext.isIE) {
                d = this.ganttView.up("panel");
                b = d.handleFocusEnter;
                d.handleFocusEnter = Ext.emptyFn
            }
            this.startEdit(e.down(this.delegate), this.dataIndex ? c.get(this.dataIndex) : "");
            if (Ext.isIE) {
                d.handleFocusEnter = b
            }
        }
    },
    onGanttRender: function (a) {
        if (!this.field.width) {
            this.autoSize = "width"
        }
        this.on({
            beforestartedit: function (c, b, d) {
                return a.fireEvent("labeledit_beforestartedit", a, this.record, d, c)
            }, beforecomplete: function (c, d, b) {
                return a.fireEvent("labeledit_beforecomplete", a, d, b, this.record, c)
            }, complete: function (c, d, b) {
                this.record.set(this.dataIndex, d);
                a.fireEvent("labeledit_complete", a, d, b, this.record, c)
            }, scope: this
        });
        a.el.on(this.triggerEvent, function (c, b) {
            this.edit(a.resolveTaskRecord(b))
        }, this, {delegate: this.delegate})
    }
});
Ext.define("Gnt.feature.ProgressBarResize", {
    requires: ["Ext.ToolTip", "Ext.resizer.Resizer"],
    constructor: function (a) {
        Ext.apply(this, a || {});
        var b = this.ganttView;
        b.on({destroy: this.cleanUp, scope: this});
        b.el.on("mousedown", this.onMouseDown, this, {delegate: ".sch-gantt-progressbar-handle"});
        this.callParent(arguments)
    },
    useTooltip: true,
    increment: 10,
    tip: null,
    resizable: null,
    ganttView: null,
    onMouseDown: function (d, b) {
        var c = this.ganttView, f = c.resolveTaskRecord(b);
        if (c.fireEvent("beforeprogressbarresize", c, f) !== false) {
            var a = Ext.fly(b).prev(".sch-gantt-progress-bar");
            d.stopEvent();
            a.addCls("active");
            this.resizable = this.createResizable(a, f, d);
            c.fireEvent("progressbarresizestart", c, f);
            Ext.getBody().on("mouseup", this.onBodyMouseUp, this, {single: true, delay: 1})
        }
    },
    createResizable: function (b, g, d) {
        var i = d.getTarget(), h = this.ganttView.rtl, f = b.up(this.ganttView.eventSelector), j = f.getWidth() - 2 * this.ganttView.eventBorderWidth, c = j * this.increment / 100;
        var a = Ext.create("Ext.resizer.Resizer", {
            target: b,
            taskRecord: g,
            handles: h ? "w" : "e",
            minWidth: 0,
            maxWidth: j,
            minHeight: 1,
            widthIncrement: c,
            listeners: {resizedrag: this.partialResize, resize: this.afterResize, scope: this}
        });
        a.resizeTracker.onMouseDown(d, a[h ? "west" : "east"].dom);
        f.addCls("sch-gantt-resizing");
        if (this.useTooltip) {
            this.tip = Ext.create("Ext.ToolTip", {autoHide: false, anchor: "b", html: "%"});
            this.tip.setTarget(b);
            this.tip.update(g.getPercentDone() + "%");
            this.tip.show()
        }
        return a
    },
    partialResize: function (c, b) {
        var a = Math.round(b * 100 / (c.maxWidth * this.increment)) * this.increment;
        if (this.tip) {
            this.tip.body.update(a + "%")
        }
    },
    afterResize: function (f, b, c, g) {
        var i = f.taskRecord;
        if (this.tip) {
            this.tip.destroy();
            this.tip = null
        }
        var a = f.taskRecord.getPercentDone();
        if (Ext.isNumber(b)) {
            var d = Math.round(b * 100 / (f.maxWidth * this.increment)) * this.increment;
            d = Math.min(100, Math.max(0, d));
            f.taskRecord.setPercentDone(d)
        }
        if (a === f.taskRecord.getPercentDone()) {
            this.ganttView.refreshNode(this.ganttView.indexOf(f.taskRecord))
        }
        f.destroy();
        this.resizable = null;
        this.ganttView.fireEvent("afterprogressbarresize", this.ganttView, i)
    },
    onBodyMouseUp: function () {
        if (this.resizable) {
            this.afterResize(this.resizable)
        }
    },
    cleanUp: function () {
        if (this.tip) {
            this.tip.destroy()
        }
    }
});
Ext.define("Gnt.feature.TaskResize", {
    requires: ["Ext.resizer.Resizer", "Gnt.Tooltip"],
    constructor: function (a) {
        Ext.apply(this, a);
        var b = this.ganttView;
        b.on({destroy: this.cleanUp, scope: this});
        b.mon(b.el, "mousedown", this.onMouseDown, this, {delegate: ".sch-resizable-handle"});
        this.callParent(arguments)
    },
    showDuration: true,
    showExactResizePosition: false,
    useTooltip: true,
    tooltipConfig: null,
    validatorFn: Ext.emptyFn,
    validatorFnScope: null,
    taskRec: null,
    taskEl: null,
    isStart: null,
    ganttView: null,
    resizable: null,
    onMouseDown: function (g, d) {
        var c = this.ganttView;
        var h = g.getTarget(".sch-gantt-task-segment");
        var b = g.getTarget(c.eventSelector);
        var a = c.resolveTaskRecord(b);
        if (h) {
            b = h;
            a = a.getSegment(parseInt(h.getAttribute("data-segmentIndex"), 10))
        }
        var f = a.isResizable();
        if (g.button !== 0 || f === false || typeof f === "string" && !b.className.match(f)) {
            return
        }
        if (c.fireEvent("beforetaskresize", c, a, g) === false) {
            return
        }
        g.stopEvent();
        this.taskEl = Ext.get(b);
        this.taskRec = a;
        this.isStart = !!d.className.match("sch-resizable-handle-start");
        c.el.on({mousemove: this.onMouseMove, mouseup: this.onMouseUp, scope: this, single: true})
    },
    onMouseMove: function (j, p) {
        var h = this.ganttView, f = this.taskRec, l = this.taskEl, m = h.rtl, a = this.isStart, d = (m && !a) || (!m && a), c = h.getSnapPixelAmount(), b = l.getWidth(), o, n;
        c = Math.max(1, c);
        var i = {
            otherEdgeX: d ? l.getRight() : l.getLeft(),
            target: l,
            record: f,
            isStart: a,
            isWest: d,
            handles: d ? "w" : "e",
            minHeight: 1,
            minWidth: c,
            widthIncrement: c,
            listeners: {resizedrag: this.partialResize, resize: this.afterResize, scope: this}
        };
        if (f instanceof Gnt.model.TaskSegment && (n = this.taskEl.next(".sch-gantt-task-segment"))) {
            i.maxWidth = m ? n.getRight() - l.getRight() : n.getLeft() - l.getLeft()
        }
        i.constrainRegion = l.up(h.getItemSelector()).getRegion();
        l.addCls("sch-gantt-resizing");
        this.ganttView.fireEvent("taskresizestart", this.ganttView, this.taskRec);
        var k = l.down(".sch-gantt-progress-bar");
        if (k) {
            k.setWidth(100 * k.getWidth() / l.getWidth() + "%")
        }
        this.resizable = Ext.create("Ext.resizer.Resizer", i);
        this.resizable.resizeTracker.onMouseDown(j, this.resizable[d ? "west" : "east"].dom);
        if (this.useTooltip) {
            if (!this.tip) {
                this.tip = Ext.create("Gnt.Tooltip", Ext.apply({
                    mode: this.showDuration ? "duration" : "startend",
                    gantt: this.ganttView
                }, this.tooltipConfig))
            } else {
                this.tip.enable()
            }
            this.tip.show(l, j.getX() - 15);
            this.tip.updateContent(f.getStartDate(), f.getEndDate(), true, f);
            Ext.getBody().on("mouseup", function () {
                this.tip.disable()
            }, this, {single: true})
        }
    },
    onMouseUp: function (c, a) {
        var b = this.ganttView;
        b.el.un({mousemove: this.onMouseMove, mouseup: this.onMouseUp, scope: this, single: true})
    },
    partialResize: function (k, j, l, p) {
        var h = this.ganttView, f = k.isWest, o = k.record, g;
        if (f) {
            g = h.getDateFromCoordinate(k.otherEdgeX - Math.min(j, this.resizable.maxWidth), !this.showExactResizePosition ? "round" : null)
        } else {
            g = h.getDateFromCoordinate(k.otherEdgeX + Math.min(j, this.resizable.maxWidth), !this.showExactResizePosition ? "round" : null)
        }
        if (!g || k.date - g === 0) {
            return
        }
        var b, a, d;
        if (this.showExactResizePosition) {
            var n = h.timeAxis.roundDate(g, h.snapRelativeToEventStartDate ? o.getStartDate() : false);
            n = o.skipNonWorkingTime(n, !o.isMilestone());
            var s = k.target.el, c;
            if (f) {
                b = o.skipNonWorkingTime(n, !o.isMilestone());
                d = b;
                c = h.timeAxisViewModel.getDistanceBetweenDates(b, o.getEndDate());
                s.setWidth(c);
                var q = h.timeAxisViewModel.getDistanceBetweenDates(g, b);
                s.setX(s.getX() + q)
            } else {
                var r = Gnt.util.Data.cloneModelSet([o])[0];
                var i = o.getTaskStore();
                r.setTaskStore(i);
                r.setCalendar(o.getCalendar());
                r.setEndDateWithoutPropagation(n, false, i.skipWeekendsDuringDragDrop);
                a = r.getEndDate();
                d = a;
                c = h.timeAxisViewModel.getDistanceBetweenDates(o.getStartDate(), a);
                s.setWidth(c)
            }
        } else {
            b = k.isStart ? g : k.record.getStartDate();
            a = k.isStart ? k.record.getEndDate() : g;
            d = g
        }
        k.date = d;
        h.fireEvent("partialtaskresize", h, o, b, a, k.el, p);
        if (this.useTooltip) {
            var m = this.validatorFn.call(this.validatorFnScope || this, o, b, a) !== false;
            this.tip.updateContent(b, a, m, o)
        }
    },
    afterResize: function (n, l, d, i) {
        if (this.useTooltip) {
            this.tip.disable()
        }
        var j = this, f = n.record, c = f.getStartDate(), o = f.getEndDate(), a = n.isStart ? n.date : c, b = n.isStart ? o : n.date, g = j.ganttView, m = false, k = true;
        j.resizeContext = {
            record: f, start: a, end: b, oldStart: f.getStartDate(), finalize: function () {
                j.finalize.apply(j, arguments)
            }
        };
        if (a && b && (a - c || b - o) && j.validatorFn.call(j.validatorFnScope || j, f, a, b, i) !== false) {
            k = g.fireEvent("beforetaskresizefinalize", j, j.resizeContext, i) !== false;
            m = true
        } else {
            g.refreshKeepingScroll()
        }
        if (k) {
            j.finalize(m)
        }
    },
    finalize: function (i) {
        var e = this, g = e.ganttView, c = e.resizeContext, d = c.record, a = d.task || d, b = g.taskStore.skipWeekendsDuringDragDrop, f, h;
        if (i) {
            if (c.start - c.oldStart !== 0) {
                f = d.getStartDate();
                h = c.start <= c.end ? c.start : c.end;
                d.setStartDate(h, false, b, function (k, j) {
                    h = d.getStartDate();
                    if (!(h < f || h > f)) {
                        g.refreshNode(g.store.indexOf(a))
                    }
                    g.fireEvent("aftertaskresize", g, a)
                })
            } else {
                f = d.getEndDate();
                h = c.start <= c.end ? c.end : c.start;
                d.setEndDate(h, false, b, function (k, j) {
                    h = d.getEndDate();
                    if (!(h < f || h > f)) {
                        g.refreshNode(g.store.indexOf(a))
                    }
                    g.fireEvent("aftertaskresize", g, a)
                })
            }
        } else {
            g.refreshNode(g.store.indexOf(a));
            g.fireEvent("aftertaskresize", g, a)
        }
        e.resizable.destroy();
        e.resizeContext = null
    },
    cleanUp: function () {
        if (this.tip) {
            this.tip.destroy()
        }
    }
});
Ext.define("Gnt.feature.WorkingTime", {
    extend: "Sch.plugin.Zones",
    requires: ["Ext.data.Store", "Sch.model.Range"],
    expandToFitView: true,
    calendar: null,
    init: function (a) {
        if (!this.calendar) {
            Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Gnt.feature.WorkingTime'")
        }
        this.bindCalendar(this.calendar);
        Ext.apply(this, {store: new Ext.data.Store({model: "Sch.model.Range"})});
        this.callParent(arguments);
        a.on("viewchange", this.onViewChange, this);
        this.onViewChange()
    },
    bindCalendar: function (b) {
        var a = {datachanged: this.refresh, update: this.refresh, scope: this, delay: 1};
        if (this.calendar) {
            this.calendar.un(a)
        }
        if (b) {
            b.on(a)
        }
        this.calendar = b
    },
    onViewChange: function () {
        var a = Sch.util.Date;
        if (a.compareUnits(this.timeAxis.unit, a.WEEK) > 0) {
            this.setDisabled(true)
        } else {
            this.setDisabled(false);
            this.refresh()
        }
    },
    refresh: function () {
        var a = this.schedulerView;
        this.store.removeAll(true);
        this.store.add(this.calendar.getHolidaysRanges(a.timeAxis.getStart(), a.timeAxis.getEnd(), true))
    },
    destroy: function () {
        this.bindCalendar(null);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.ProjectLines", {
    extend: "Sch.plugin.Lines",
    alias: "plugin.gantt_projectlines",
    requires: ["Gnt.model.ProjectLine", "Ext.data.Store"],
    innerTpl: '<span class="sch-gantt-project-line-text">{Text}</span>',
    showHeaderElements: true,
    taskStore: null,
    linesFor: "both",
    allRemoved: false,
    init: function (a) {
        this.taskStore = this.taskStore || a.getTaskStore();
        this.bindTaskStore(this.taskStore);
        if (!this.store) {
            this.store = new Ext.data.Store({model: "Gnt.model.ProjectLine"})
        }
        this.callParent(arguments);
        a.on("viewchange", this.onViewChange, this);
        this.onViewChange()
    },
    bindTaskStore: function (a) {
        var b = {datachanged: this.onDataChanged, update: this.onUpdate, scope: this, delay: 1};
        if (this.taskStore) {
            this.taskStore.un(b)
        }
        if (a) {
            a.on(b)
        }
        this.taskStore = a
    },
    onDataChanged: function (a) {
        this.refresh()
    },
    onUpdate: function (d, a, c) {
        if (a && a.isProject && c == Ext.data.Model.EDIT) {
            var b = a.modified && a.modified.Id || a.getId();
            this.store.remove(this.getProjectLines(b));
            this.store.add(this.retrieveProjectLines(a))
        }
    },
    onViewChange: function () {
        this.refresh()
    },
    loadStore: function () {
        this.store.removeAll(true);
        this.store.add(this.retrieveProjectLines())
    },
    refresh: function () {
        this.loadStore()
    },
    getProjectLines: function (b) {
        var a = [];
        this.store.each(function (c) {
            if (c.get("ProjectId") == b) {
                a.push(c)
            }
        });
        return a
    },
    prepareProjectStartLine: function (a) {
        return {
            Date: a.getStartDate(),
            Text: "Start of: " + a.getName(),
            Cls: "sch-gantt-project-line-start sch-gantt-project-line-" + a.getId(),
            ProjectId: a.getId()
        }
    },
    prepareProjectEndLine: function (a) {
        return {
            Date: a.getEndDate(),
            Text: "End of: " + a.getName(),
            Cls: "sch-gantt-project-line-end sch-gantt-project-line-" + a.getId(),
            ProjectId: a.getId()
        }
    },
    retrieveProjectLines: function (f) {
        var e = this, c = Ext.isArray(f) ? f : f && [f] || this.taskStore.getProjects(), b = [], d = e.linesFor;
        for (var a = 0; a < c.length; a++) {
            d != "end" && b.push(e.prepareProjectStartLine(c[a]));
            d != "start" && b.push(e.prepareProjectEndLine(c[a]))
        }
        return b
    },
    destroy: function () {
        this.bindTaskStore(null);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.DependencyEditor", {
    extend: "Ext.form.Panel",
    alias: "plugin.gantt_dependencyeditor",
    ptype: "gantt_dependencyeditor",
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    header: false,
    requires: ["Ext.util.Filter", "Ext.form.field.Display", "Ext.form.field.ComboBox", "Ext.form.field.Number", "Gnt.model.Dependency", "Ext.data.ArrayStore"],
    hideOnBlur: true,
    showLag: false,
    border: false,
    width: 260,
    frame: true,
    labelWidth: 60,
    triggerEvent: "dependencydblclick",
    constrain: false,
    initComponent: function () {
        Ext.apply(this, {defaults: {width: 240}, floating: true, hideMode: "offsets"});
        this.callParent(arguments);
        this.addCls("sch-gantt-dependencyeditor")
    },
    getState: function () {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    init: function (a) {
        a.on(this.triggerEvent, this.onDependencyDblClick, this);
        a.on("afterrender", this.onGanttRender, this, {delay: 50});
        this.gantt = a;
        this.taskStore = a.getTaskStore();
        this.add(this.buildFields())
    },
    onGanttRender: function () {
        this.render(Ext.getBody());
        this.collapse(Ext.Component.DIRECTION_TOP, true);
        this.hide();
        if (this.hideOnBlur) {
            this.on({
                show: function () {
                    this.mon(Ext.getBody(), {click: this.onMouseClick, scope: this})
                }, hide: function () {
                    this.mun(Ext.getBody(), {click: this.onMouseClick, scope: this})
                }, delay: 50
            })
        }
    },
    show: function (b, c) {
        this.dependencyRecord = b;
        this.getForm().loadRecord(b);
        this.fromLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getSourceTask().getName()));
        this.toLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getTargetTask().getName()));
        if (this.typeField) {
            var a = this.taskStore && this.taskStore.getDependencyStore(), d = a && a.allowedDependencyTypes;
            this.typeField.store.filter();
            this.typeField.setReadOnly(d && d.length < 2)
        }
        this.callParent([]);
        this.el.setXY(c);
        this.expand(!this.constrain);
        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()))
        }
    },
    buildFields: function () {
        var c = this, b = this.taskStore && this.taskStore.getDependencyStore(), d = Gnt.model.Dependency;
        var a = [this.fromLabel = new Ext.form.DisplayField({fieldLabel: this.L("fromText")}), this.toLabel = new Ext.form.DisplayField({fieldLabel: this.L("toText")}), this.typeField = this.buildTypeField()];
        if (this.showLag) {
            a.push(this.lagField = new Ext.form.NumberField({
                name: b ? b.model.prototype.lagField : d.prototype.lagField,
                fieldLabel: this.L("lagText")
            }))
        }
        return a
    },
    onDependencyDblClick: function (c, a, d, b) {
        if (a != this.dependencyRecord) {
            this.show(a, d.getXY())
        }
    },
    filterAllowedTypes: function (b) {
        var c = this.taskStore && this.taskStore.getDependencyStore();
        if (!c || !c.allowedDependencyTypes) {
            return true
        }
        var f = c.allowedDependencyTypes;
        var g = c.model.Type;
        for (var d = 0, a = f.length; d < a; d++) {
            var e = g[f[d]];
            if (b.getId() == e) {
                return true
            }
        }
        return false
    },
    buildTypeField: function () {
        var b = this.taskStore ? this.taskStore.getDependencyStore().model : Gnt.model.Dependency;
        var c = b.Type;
        this.typesFilter = new Ext.util.Filter({filterFn: this.filterAllowedTypes, scope: this});
        var a = new Ext.data.ArrayStore({
            fields: [{name: "id", type: "int"}, "text"],
            data: [[c.EndToStart, this.L("endToStartText")], [c.StartToStart, this.L("startToStartText")], [c.EndToEnd, this.L("endToEndText")], [c.StartToEnd, this.L("startToEndText")]]
        });
        a.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            name: b.prototype.typeField,
            fieldLabel: this.L("typeText"),
            triggerAction: "all",
            queryMode: "local",
            editable: false,
            valueField: "id",
            displayField: "text",
            store: a
        })
    },
    onMouseClick: function (a) {
        if (this.collapsed || a.within(this.getEl()) || a.getTarget("." + Ext.baseCSSPrefix + "layer") || a.getTarget(".sch-ignore-click")) {
            return
        }
        this.collapse()
    },
    afterCollapse: function () {
        delete this.dependencyRecord;
        this.hide();
        this.callParent(arguments);
        if (this.hideOnBlur) {
            this.mun(Ext.getBody(), "click", this.onMouseClick, this)
        }
    }
});
Ext.define("Gnt.plugin.TaskContextMenu", {
    extend: "Ext.menu.Menu",
    alias: "plugin.gantt_taskcontextmenu",
    ptype: "gantt_taskcontextmenu",
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    requires: ["Gnt.model.Task"],
    plain: true,
    triggerEvent: ["itemcontextmenu", "containercontextmenu"],
    hideEvent: null,
    grid: null,
    rec: null,
    triggerEventXY: null,
    lastHighlightedItem: null,
    taskEditorInjected: false,
    config: {
        splitDuration: 0,
        splitDurationUnit: "d",
        maxSplitDuration: 1,
        maxSplitDurationUnit: "d",
        minSplitDuration: 1,
        minSplitDurationUnit: "h"
    },
    getState: function () {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    isNotProject: function (a) {
        return !a || !a.isProject
    },
    createMenuItems: function () {
        var a = this;
        return [{
            handler: this.deleteTask,
            requiresTask: true,
            itemId: "deleteTask",
            text: this.L("deleteTask")
        }, {
            handler: this.editLeftLabel,
            requiresTask: true,
            itemId: "editLeftLabel",
            text: this.L("editLeftLabel"),
            isValidAction: function () {
                return a.grid.getSchedulingView().getLeftEditor()
            }
        }, {
            handler: this.editRightLabel,
            requiresTask: true,
            itemId: "editRightLabel",
            text: this.L("editRightLabel"),
            isValidAction: function () {
                return a.grid.getSchedulingView().getRightEditor()
            }
        }, {
            handler: this.toggleMilestone,
            requiresTask: true,
            itemId: "toggleMilestone",
            text: this.L("convertToMilestone"),
            isValidAction: this.isNotProject
        }, {
            handler: this.splitTask, requiresTask: true, itemId: "splitTask", isValidAction: function (c, b) {
                return c && c.getStartDate() && c.getEndDate() && !c.isMilestone() && c.isLeaf() && b && b.getTarget(".sch-gantt-task-bar")
            }, text: this.L("splitTask")
        }, {
            text: this.L("add"),
            itemId: "addTaskMenu",
            menu: {
                plain: true,
                defaults: {scope: this},
                items: [{
                    handler: this.addTaskAboveAction,
                    requiresTask: true,
                    itemId: "addTaskAbove",
                    text: this.L("addTaskAbove")
                }, {
                    handler: this.addTaskBelowAction,
                    requiresTask: true,
                    itemId: "addTaskBelow",
                    text: this.L("addTaskBelow")
                }, {
                    handler: this.addMilestone,
                    itemId: "addMilestone",
                    requiresTask: true,
                    text: this.L("addMilestone")
                }, {
                    handler: this.addSubtask,
                    requiresTask: true,
                    itemId: "addSubtask",
                    text: this.L("addSubtask")
                }, {
                    handler: this.addSuccessor,
                    requiresTask: true,
                    itemId: "addSuccessor",
                    text: this.L("addSuccessor"),
                    isValidAction: this.isNotProject
                }, {
                    handler: this.addPredecessor,
                    requiresTask: true,
                    itemId: "addPredecessor",
                    text: this.L("addPredecessor"),
                    isValidAction: this.isNotProject
                }]
            }
        }, {
            text: this.L("deleteDependency"),
            requiresTask: true,
            itemId: "deleteDependencyMenu",
            isValidAction: function (b) {
                return b && b.getAllDependencies().length > 0
            },
            menu: {
                plain: true,
                listeners: {
                    beforeshow: this.populateDependencyMenu,
                    mouseover: this.onDependencyMouseOver,
                    mouseleave: this.onDependencyMouseOut,
                    scope: this
                }
            }
        }]
    },
    buildMenuItems: function () {
        this.items = this.createMenuItems()
    },
    initComponent: function () {
        var b = this.triggerEvent, a = this.hideEvent;
        this.defaults = this.defaults || {};
        this.defaults.scope = this;
        if (b) {
            if (!Ext.isArray(b)) {
                b = [b]
            }
        }
        this.triggerEvent = b;
        if (a) {
            if (!Ext.isArray(a)) {
                a = [a]
            }
        }
        if (Ext.isIE) {
            a = a || [];
            a.push("itemclick")
        }
        this.hideEvent = a;
        this.buildMenuItems();
        this.callParent(arguments)
    },
    init: function (a) {
        this.grid = a;
        this.bindTriggerEvent();
        this.bindHideEvent()
    },
    bindTriggerEvent: function () {
        var c = this.triggerEvent, b = this.grid || this.getCmp();
        if (c) {
            for (var a = c.length - 1; a >= 0; a--) {
                b.on(c[a], this.onTriggerEvent, this)
            }
        }
    },
    bindHideEvent: function () {
        var c = this.hideEvent, b = this.grid || this.getCmp();
        if (c) {
            for (var a = c.length - 1; a >= 0; a--) {
                b.on(c[a], this.onHideEvent, this)
            }
        }
    },
    onHideEvent: function () {
        this.hide()
    },
    populateDependencyMenu: function (f) {
        if (f.up("menuitem").isDisabled()) {
            return false
        }
        var d = this.grid, b = d.getTaskStore(), e = this.rec.getAllDependencies(), a = d.dependencyStore;
        f.removeAll();
        if (!e.length) {
            return false
        }
        var c = this.rec.getId() || this.rec.internalId;
        Ext.Array.forEach(e, function (i) {
            var h = i.getSourceId(), g = b.getModelById(h == c ? i.getTargetId() : h);
            if (g) {
                f.add({
                    depId: i.getId(),
                    text: Ext.util.Format.ellipsis(Ext.String.htmlEncode(g.getName()), 30),
                    scope: this,
                    handler: function (j) {
                        a.remove(a.getModelById(j.depId))
                    }
                })
            }
        }, this)
    },
    onDependencyMouseOver: function (d, a, b) {
        if (a) {
            var c = this.grid.getSchedulingView();
            if (this.lastHighlightedItem) {
                c.unhighlightDependency(this.lastHighlightedItem.depId)
            }
            this.lastHighlightedItem = a;
            c.highlightDependency(a.depId)
        }
    },
    onDependencyMouseOut: function (b, a) {
        if (this.lastHighlightedItem) {
            this.grid.getSchedulingView().unhighlightDependency(this.lastHighlightedItem.depId)
        }
    },
    onTriggerEvent: function () {
        var a = this.getTriggerEventContext.apply(this, arguments);
        this.activateMenu(a.record, a.e)
    },
    getTriggerEventContext: function () {
        var a = {};
        for (var c = 0, b = arguments.length - 1; c <= b; c++) {
            if (arguments[c]instanceof Gnt.model.Task) {
                a.record = arguments[c];
                break
            }
        }
        for (c = arguments.length - 1; c >= 0; c--) {
            if (arguments[c]instanceof Ext.EventObjectImpl) {
                a.e = arguments[c];
                break
            }
        }
        return a
    },
    activateMenu: function (b, a) {
        if (this.grid.isReadOnly() || this.grid.taskStore.getRootNode() === b) {
            return
        }
        a.stopEvent();
        this.rec = b;
        this.triggerEventXY = a.getXY();
        this.configureMenuItems(a);
        this.showAt(a.getXY());
        this.focus()
    },
    addTaskEditorEntry: function () {
        this.insert(0, {
            text: this.L("taskInformation"),
            itemId: "taskEditor",
            requiresTask: true,
            handler: function () {
                this.grid.getTaskEditor(this.rec).showTask(this.rec)
            },
            isValidAction: function (a) {
                return this.grid.getTaskEditor(a)
            },
            scope: this
        });
        this.taskEditorInjected = true
    },
    setTaskEditorEntryLabel: function (a) {
        var b = this.down("#taskEditor");
        if (a && b) {
            b.setText(a.isProject ? this.L("projectInformation") : this.L("taskInformation"))
        }
    },
    configureMenuItems: function (a) {
        var b = this.rec;
        if (this.grid.getTaskEditor()) {
            if (!this.taskEditorInjected) {
                this.addTaskEditorEntry()
            }
            this.setTaskEditorEntryLabel(b)
        }
        Ext.Array.forEach(this.query("menuitem"), function (e) {
            var d = (e.requiresTask && !b) || (e.isValidAction && !e.isValidAction.call(e.scope || e, b, a));
            e.setDisabled(d)
        });
        var c = this.down("#toggleMilestone");
        if (b && c) {
            c.setText(b.isMilestone() ? this.L("convertToRegular") : this.L("convertToMilestone"))
        }
    },
    copyTask: function (c) {
        var b = this.grid.getTaskStore().model;
        var a = new b({leaf: true});
        a.setPercentDone(0);
        a.setName(this.L("newTaskText", this.texts));
        a.set(a.startDateField, (c && c.getStartDate()) || null);
        a.set(a.endDateField, (c && c.getEndDate()) || null);
        a.set(a.durationField, (c && c.getDuration()) || null);
        a.set(a.durationUnitField, (c && c.getDurationUnit()) || "d");
        return a
    },
    addTaskAbove: function (a) {
        var b = this.rec;
        if (b) {
            b.addTaskAbove(a)
        } else {
            this.grid.taskStore.getRootNode().appendChild(a)
        }
    },
    addTaskBelow: function (a) {
        var b = this.rec;
        if (b) {
            b.addTaskBelow(a)
        } else {
            this.grid.taskStore.getRootNode().appendChild(a)
        }
    },
    deleteTask: function () {
        var a = this.grid.getSelectionModel();
        a.selected.each(function (b) {
            b.parentNode ? b.parentNode.removeSubtask(b) : b.remove()
        })
    },
    editLeftLabel: function () {
        this.grid.getSchedulingView().editLeftLabel(this.rec)
    },
    editRightLabel: function () {
        this.grid.getSchedulingView().editRightLabel(this.rec)
    },
    addTaskAboveAction: function () {
        this.addTaskAbove(this.copyTask(this.rec))
    },
    addTaskBelowAction: function () {
        this.addTaskBelow(this.copyTask(this.rec))
    },
    addSubtask: function () {
        var a = this.rec;
        a.addSubtask(this.copyTask(a))
    },
    addSuccessor: function () {
        var a = this.rec;
        a.addSuccessor(this.copyTask(a))
    },
    addPredecessor: function () {
        var a = this.rec;
        a.addPredecessor(this.copyTask(a))
    },
    addMilestone: function () {
        var b = this.rec, a = this.copyTask(b);
        b.addTaskBelow(a);
        a.setStartEndDate(b.getEndDate(), b.getEndDate())
    },
    toggleMilestone: function () {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular()
        } else {
            this.rec.convertToMilestone()
        }
    },
    getSplitDate: function (e) {
        var b = e.task, c = e.date, d = e.tick, g = e.timeAxis, f = this.getMaxSplitDuration(), a;
        if (d) {
            a = d.getStartDate();
            if (f) {
                f = b.getUnitConverter().convertDurationToMs(f, this.getMaxSplitDurationUnit());
                if (f < d.getEndDate() - d.getStartDate()) {
                    a = null
                }
            }
        }
        return a || g.roundDate(c, b.getStartDate())
    },
    getSplitDuration: function (b) {
        if (this.splitDuration) {
            return this.splitDuration
        }
        var c = b.task, h = b.pos, d = b.date, g = b.tick;
        if (g) {
            var i = c.calculateDuration(g.getStartDate(), g.getEndDate(), Sch.util.Date.MILLI), e = c.getUnitConverter(), a = this.getMinSplitDuration(), f = this.getMaxSplitDuration();
            if (a || f) {
                if (f) {
                    i = Math.min(i, e.convertDurationToMs(f, this.getMaxSplitDurationUnit()))
                }
                if (a) {
                    i = Math.max(i, e.convertDurationToMs(a, this.getMinSplitDurationUnit()))
                }
            }
            return e.convertMSDurationToUnit(i, this.getSplitDurationUnit(c, h, d, g))
        }
    },
    getSplitDurationUnit: function (a) {
        return this.splitDuration ? this.splitDurationUnit : Sch.util.Date.MILLI
    },
    splitTask: function () {
        var d = this, b = d.grid.getSchedulingView(), a = b.getDateFromX(d.triggerEventXY[0]), e = b.timeAxis;
        var c = {
            task: d.rec,
            pos: d.triggerEventXY,
            date: a,
            timeAxis: e,
            tick: e.getAt(Math.floor(e.getTickFromDate(a)))
        };
        c.task.split(d.getSplitDate(c), d.getSplitDuration(c), d.getSplitDurationUnit(c))
    }
});
Ext.define("Gnt.plugin.exporter.mixin.DependencyPainter", {
    taskBoxes: null,
    dependencyPainter: null,
    dependenciesHtml: "",
    ganttView: null,
    initDependencyPainter: function () {
        var a = this;
        a.dependencyPainter = a.normalView.dependencyView.painter;
        a.ganttView = a.dependencyPainter.ganttView;
        a.taskBoxes = {}
    },
    getLineCoordinates: function () {
        var a = this;
        return a.dependencyPainter.getLineCoordinates.apply(a.dependencyPainter, arguments)
    },
    renderDependencies: function (b) {
        var a = this;
        a.dependenciesHtml = a.normalView.dependencyView.lineTpl.apply(a.getDependencyTplData(b))
    },
    fillTaskBox: function (b) {
        var d = this, a = d.normalView.dependencyView.painter;
        if (b.hasIncomingDependencies() || b.hasOutgoingDependencies()) {
            var c;
            if (d.ganttView.bufferedRenderer) {
                c = d.ganttView.bufferedRenderer.bodyTop;
                d.ganttView.bufferedRenderer.bodyTop = 0
            }
            d.taskBoxes[b.getId()] = a.getTaskBox(b);
            if (d.ganttView.bufferedRenderer) {
                d.ganttView.bufferedRenderer.bodyTop = c
            }
        }
    },
    getRenderData: function (c) {
        var d = this, b = c.getSourceTask(), a = c.getTargetTask();
        if (b && a) {
            return {fromBox: d.taskBoxes[b.getId()], toBox: d.taskBoxes[a.getId()]}
        }
    },
    getDependencyTplData: function (a) {
        a = a || this.normalView.dependencyView.store.getRange();
        return this.dependencyPainter.getDependencyTplData.call(this, a)
    }
});
Ext.define("Gnt.plugin.exporter.MultiPage", {
    extend: "Sch.plugin.exporter.MultiPage",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    depsTopOffset: 0,
    normalGridOffset: 0,
    collectNormalRow: function (c, a) {
        var b = this, d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    setComponent: function () {
        var a = this;
        a.callParent(arguments);
        a.initDependencyPainter()
    },
    onRowsCollected: function () {
        var a = this;
        a.renderDependencies();
        a.depsTopOffset = 0;
        a.normalGridOffset = 0;
        a.callParent(arguments)
    },
    commitPage: function (a) {
        var b = this;
        b.callParent(arguments);
        b.depsTopOffset -= a.rowsHeight
    },
    startPage: function (c, a) {
        var b = this;
        b.normalGridOffset = c.normalGridOffset;
        if (a) {
            b.depsTopOffset = 0
        }
        b.callParent(arguments)
    },
    buildPageFrame: function (a, c) {
        var b = this;
        var d = b.callParent(arguments);
        d.normalHidden = b.normalGrid.hidden;
        d.lockedHidden = b.lockedGrid.hidden;
        return d
    },
    preparePageToCommit: function () {
        var h = this, j = h.callParent(arguments), e = j.select(".sch-dependencyview-ct").first(), a = j.select("." + Ext.baseCSSPrefix + "splitter").first(), i = h.pageFrames[h.columnPageIndex - 1], c = function (m) {
            var l = j.select("#" + m).first();
            return l && l.dom
        };
        if (a) {
            if (i.lockedHidden) {
                a.hide()
            } else {
                a.setHeight("100%")
            }
        }
        if (!i.normalHidden) {
            e.dom.innerHTML = h.dependenciesHtml;
            e.applyStyles({top: h.depsTopOffset + "px"});
            var g = h.normalGrid, b = g.getView().id;
            var d = c(b);
            if (d) {
                var f = g.el.down(h.tableSelector).getWidth();
                d.style.width = f + "px";
                d.style.overflow = "hidden"
            }
        }
        if (!i.lockedHidden) {
            var k = c(h.lockedView.id);
            if (k) {
                k.style.overflow = "hidden"
            }
        }
        return j
    }
});
Ext.define("Gnt.plugin.exporter.MultiPageVertical", {
    extend: "Sch.plugin.exporter.MultiPageVertical",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    depsTopOffset: 0,
    collectNormalRow: function (c, a) {
        var b = this, d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    setComponent: function () {
        var a = this;
        a.callParent(arguments);
        a.initDependencyPainter()
    },
    onRowsCollected: function () {
        var a = this;
        a.renderDependencies();
        a.depsTopOffset = 0;
        a.callParent(arguments)
    },
    commitPage: function (a) {
        var b = this;
        b.callParent(arguments);
        b.depsTopOffset -= a.rowsHeight
    },
    preparePageToCommit: function () {
        var h = this, i = h.callParent(arguments), e = i.select(".sch-dependencyview-ct").first(), a = i.select("." + Ext.baseCSSPrefix + "splitter").first(), c = function (l) {
            var k = i.select("#" + l).first();
            return k && k.dom
        };
        e.dom.innerHTML = h.dependenciesHtml;
        e.applyStyles({top: h.depsTopOffset + "px", left: "0px"});
        a && a.setHeight("100%");
        var g = h.normalGrid, f = g.el.down(h.tableSelector).getWidth(), b = g.getView().id;
        var d = c(b);
        d.style.width = f + "px";
        d.style.overflow = "hidden";
        var j = c(h.lockedView.id);
        j.style.overflow = "hidden";
        return i
    }
});
Ext.define("Gnt.plugin.exporter.SinglePage", {
    extend: "Sch.plugin.exporter.SinglePage",
    mixins: ["Gnt.plugin.exporter.mixin.DependencyPainter"],
    setComponent: function () {
        this.callParent(arguments);
        this.initDependencyPainter()
    },
    collectNormalRow: function (c, a) {
        var b = this, d = b.callParent(arguments);
        b.fillTaskBox(d.record);
        return d
    },
    onRowsCollected: function () {
        var a = this;
        a.renderDependencies();
        this.callParent(arguments)
    },
    preparePageToCommit: function () {
        var d = this, h = d.callParent(arguments), b = h.select(".sch-dependencyview-ct").first(), e = h.select("." + Ext.baseCSSPrefix + "splitter").first();
        b.dom.innerHTML = d.dependenciesHtml;
        b.applyStyles({top: "0px", left: "0px"});
        e && e.setHeight("100%");
        var f = d.component.normalGrid, a = f.el.down(d.tableSelector).getWidth(), g = f.getView().id, c = h.select("#" + g).first().dom;
        c.style.width = a + "px";
        return h
    }
});
Ext.define("Gnt.plugin.Export", {
    extend: "Sch.plugin.Export",
    alias: "plugin.gantt_export",
    alternateClassName: "Gnt.plugin.PdfExport",
    requires: ["Gnt.plugin.exporter.SinglePage", "Gnt.plugin.exporter.MultiPage", "Gnt.plugin.exporter.MultiPageVertical"],
    buildExporters: function () {
        return ["Gnt.plugin.exporter.SinglePage", "Gnt.plugin.exporter.MultiPage", "Gnt.plugin.exporter.MultiPageVertical"]
    },
    showExportDialog: function () {
        this.exportDialogConfig.scrollerDisabled = true;
        this.callParent(arguments)
    }
});
Ext.define("Gnt.plugin.Printable", {
    extend: "Sch.plugin.Printable",
    alias: "plugin.gantt_printable",
    getGridContent: function (e) {
        var j = e.getSchedulingView();
        j._print = true;
        var a = this.callParent(arguments), h = j.dependencyView, n = h.painter.getDependencyTplData(j.dependencyStore.getRange()), d = '<div class="' + h.getDependencyCanvas().dom.className + '">' + h.lineTpl.apply(n) + "</div>", m = a.normalRows;
        if (Ext.select(".sch-gantt-critical-chain").first()) {
            var b = Ext.DomHelper.createDom({tag: "div", html: d}).cloneNode(true);
            b = Ext.get(b);
            var p = Ext.DomHelper.createDom({tag: "div", html: m}).cloneNode(true);
            p = Ext.get(p);
            var q = j.getCriticalPaths(), c = j.dependencyStore, o, g, f, k;
            Ext.Array.forEach(q, function (i) {
                Ext.Array.forEach(i, function (l, r) {
                    this.highlightTask(l, e, p);
                    if (r < (i.length - 1)) {
                        k = c.getAt(c.findBy(function (s) {
                            return s.getTargetId() === (l.getId() || l.internalId) && s.getSourceId() === (i[r + 1].getId() || i[r + 1].internalId)
                        }));
                        this.highlightDependency(k, b, h)
                    }
                }, this)
            }, this);
            m = p.dom.innerHTML;
            d = b.dom.innerHTML
        }
        a.normalRows = d + m;
        delete j._print;
        return a
    },
    highlightTask: function (b, a, e) {
        var d = a.getSchedulingView().getElementFromEventRecord(b), c = d.id;
        if (d) {
            e.select("#" + c).first().parent("tr").addCls("sch-gantt-task-highlighted")
        }
    },
    highlightDependency: function (c, b, a) {
        var d = c instanceof Ext.data.Model ? c.internalId : c;
        return b.select(".sch-dep-" + d).addCls(a.selectedCls)
    }
});
Ext.define("Gnt.view.DependencyPainter", {
    ganttView: null,
    rowHeight: null,
    arrowOffset: 8,
    lineWidth: 2,
    xOffset: 6,
    constructor: function (a) {
        a = a || {};
        Ext.apply(this, a)
    },
    setRowHeight: function (a) {
        this.rowHeight = a
    },
    getTaskBox: function (t) {
        var i = Sch.util.Date, k = t.getStartDate(), s = t.getEndDate(), o = this.ganttView, n = o.bufferedRenderer, f = o.timeAxis.getStart(), d = o.timeAxis.getEnd();
        if (!t.isVisible() || !k || !s || !i.intersectSpans(k, s, f, d)) {
            return null
        }
        if (o.store.indexOf(t) < 0) {
            var m = o.taskStore;
            if (!n) {
                return null
            }
            if (m.isTreeFiltered() && !m.lastTreeFilter.filter.call(m.lastTreeFilter.scope || m, t)) {
                return null
            }
        }
        var g, c = o.getXFromDate(i.max(k, f)), b = o.getXFromDate(i.min(s, d)), a = o.getNodeByRecord(t);
        if (a || n) {
            var w = o.getXOffset(t), q, j, x = t.isMilestone(), v = true;
            if (c > w) {
                c -= w
            }
            b += w;
            var h = o.el;
            var l = o.getScroll().top - (o.bufferedRenderer ? o.bufferedRenderer.bodyTop : 0);
            if (a) {
                var p = o.getElementsFromEventRecord(t), u = p.length && p[0];
                if (!u) {
                    return null
                }
                g = Ext.fly(u).getOffsetsTo(h);
                q = g[1] + l + (x && Ext.isIE8 ? 3 : 0);
                j = q + Ext.fly(u).getHeight();
                if (x) {
                    b += 1
                }
            } else {
                var r = o.all.elements;
                var e = o.store.getAt(o.all.startIndex);
                if (t.isAbove(e)) {
                    a = r[o.all.startIndex];
                    g = Ext.fly(a).getOffsetsTo(h);
                    g[1] -= o.getRowHeight()
                } else {
                    a = r[o.all.endIndex];
                    g = Ext.fly(a).getOffsetsTo(h);
                    g[1] += o.getRowHeight()
                }
                q = g[1] + l;
                j = q + this.rowHeight;
                v = false
            }
            return {top: q, end: b, bottom: j, start: c, rendered: v}
        }
    },
    getRenderData: function (g) {
        var f = g.getSourceTask(), d = g.getTargetTask();
        if (!f || !f.getTreeStore() || !d || !d.getTreeStore()) {
            return null
        }
        var a = this.getTaskBox(f);
        var e = this.getTaskBox(d);
        var c = this.ganttView;
        if (c.bufferRender && a && !a.rendered && e && !e.rendered) {
            var h = c.store.getAt(c.all.startIndex);
            var b = c.store.getAt(c.all.endIndex);
            if ((f.isAbove(h) && d.isAbove(h)) || (b.isAbove(f) && b.isAbove(d))) {
                return null
            }
        }
        return {fromBox: a, toBox: e}
    },
    getDependencyTplData: function (m) {
        var g = this, j = g.ganttView;
        if (m instanceof Ext.data.Model) {
            m = [m]
        }
        if (m.length === 0 || j.store.getCount() === 0) {
            return
        }
        var a = [], k, h, f, b;
        for (var e = 0, c = m.length; e < c; e++) {
            b = m[e];
            var d = this.getRenderData(b);
            if (d) {
                h = d.fromBox;
                f = d.toBox;
                if (h && f) {
                    k = g.getLineCoordinates(h, f, b);
                    if (k) {
                        a.push({dependency: b, id: b.internalId, cls: b.getCls(), lineCoordinates: k})
                    }
                }
            }
        }
        return a
    },
    getLineCoordinates: function (r, p, k) {
        var g, s, q = [0, r.top - 1 + ((r.bottom - r.top) / 2)], a = [0, p.top - 1 + ((p.bottom - p.top) / 2)], c = a[1] > q[1], h = k.self.Type, e = this.arrowOffset + this.xOffset, d = k.getType(), n = [], b = k.getTargetTask().isMilestone(), l, j, t;
        switch (d) {
            case h.StartToEnd:
                q[0] = r.start;
                a[0] = p.end + e;
                g = "l";
                s = "r";
                break;
            case h.StartToStart:
                q[0] = r.start;
                a[0] = p.start - e;
                g = "l";
                s = "l";
                break;
            case h.EndToStart:
                q[0] = r.end;
                a[0] = p.start - e;
                g = "r";
                s = "l";
                break;
            case h.EndToEnd:
                q[0] = r.end;
                a[0] = p.end + e;
                g = "r";
                s = "r";
                break;
            default:
                throw"Invalid dependency type: " + k.getType()
        }
        n.push(q);
        var o = q[0] + (g === "r" ? this.xOffset : -this.xOffset);
        if (c && d === h.EndToStart && r.end < (p.start + 5)) {
            l = Math.min(p.start, p.end) + this.xOffset;
            n.push([l, q[1]]);
            n.push([l, p.top - this.arrowOffset - (b ? 2 : 0)])
        } else {
            if (g !== s && ((g === "r" && o > a[0]) || (g === "l" && o < a[0]))) {
                j = p[s === "l" ? "start" : "end"];
                t = a[1] + (c ? -1 : 1) * (this.rowHeight / 2);
                n.push([o, q[1]]);
                n.push([o, t]);
                n.push([a[0], t]);
                n.push(a);
                n.push([j + (a[0] < j ? -this.arrowOffset : this.arrowOffset) - (b && s === "l" && !Ext.isIE8m ? 2 : 0), a[1]])
            } else {
                j = p[s === "l" ? "start" : "end"];
                if (g === "r") {
                    l = Math.max(o, a[0])
                } else {
                    l = Math.min(o, a[0])
                }
                n.push([l, q[1]]);
                n.push([l, a[1]]);
                n.push([j + (l < j ? -this.arrowOffset : this.arrowOffset) - (b && s === "l" ? 2 : 0), a[1]])
            }
        }
        var f = [];
        for (var m = 0; m < n.length - 1; m++) {
            f.push({x1: n[m][0], y1: n[m][1], x2: n[m + 1][0], y2: n[m + 1][1]})
        }
        return f
    }
});
Ext.define("Gnt.view.Dependency", {
    extend: "Ext.util.Observable",
    requires: ["Ext.XTemplate", "Gnt.feature.DependencyDragDrop", "Gnt.view.DependencyPainter"],
    lineWidth: 1,
    dragZoneConfig: null,
    dropZoneConfig: null,
    dependencyPainterClass: "Gnt.view.DependencyPainter",
    ganttView: null,
    painter: null,
    taskStore: null,
    store: null,
    dnd: null,
    lineTpl: null,
    renderTimer: null,
    enableDependencyDragDrop: true,
    renderAllDepsBuffered: false,
    dependencyCls: "sch-dependency",
    selectedCls: "sch-dependency-selected",
    constructor: function (a) {
        this.callParent(arguments);
        var c = this.ganttView;
        if (c.bufferedRenderer) {
            c.on({itemadd: this.renderAllDependenciesBuffered, scope: this})
        }
        c.on({refresh: this.renderAllDependenciesBuffered, itemupdate: this.onTaskUpdated, scope: this});
        this.bindTaskStore(c.getTaskStore());
        this.bindDependencyStore(a.store);
        if (!this.lineTpl) {
            var d = this.rtl;
            var b = d ? "right" : "left";
            this.lineTpl = new Ext.XTemplate('<tpl for=".">' + ('<tpl for="lineCoordinates"><div class="{0} {[ parent.dependency.isHighlighted ? "{1}" : "" ]} {[values.x1==values.x2 ? "sch-dependency-line-v" : "sch-dependency-line-h"]} {lineCls} sch-dep-{parent.id} {0}-line {[this.getSuffixedCls(parent.cls, "-line")]}" style="' + b + ":{[Math.min(values.x1, values.x2)]}px;top:{[Math.min(values.y1, values.y2)]}px;width:{[Math.abs(values.x1-values.x2)+" + this.lineWidth + "]}px;height:{[Math.abs(values.y1-values.y2)+" + this.lineWidth + ']}px"></div></tpl><div style="' + b + ':{[values.lineCoordinates[values.lineCoordinates.length - 1].x2]}px;top:{[values.lineCoordinates[values.lineCoordinates.length - 1].y2]}px" class="{0}-arrow-ct {0} {[ values.dependency.isHighlighted ? "{1}" : "" ]} sch-dep-{id} {[this.getSuffixedCls(values.cls, "-arrow-ct")]}"><img src="' + Ext.BLANK_IMAGE_URL + '" class="{0}-arrow {0}-arrow-{[this.getArrowDirection(values.lineCoordinates)]} {[this.getSuffixedCls(values.cls, "-arrow")]}" /></div>').replace(/\{0\}/g, this.dependencyCls).replace(/\{1\}/g, this.selectedCls) + "</tpl>", {
                disableFormats: true,
                getArrowDirection: function (f) {
                    var e = f[f.length - 1];
                    if (e.y2 < e.y1) {
                        return "up"
                    }
                    if (e.x1 === e.x2) {
                        return "down"
                    } else {
                        if ((!d && e.x1 > e.x2) || (d && e.x1 < e.x2)) {
                            return "left"
                        } else {
                            return "right"
                        }
                    }
                },
                getSuffixedCls: function (e, f) {
                    if (e && e.indexOf(" ") != -1) {
                        return e.replace(/^\s*(.*)\s*$/, "$1").split(/\s+/).join(f + " ") + f
                    } else {
                        return e + f
                    }
                }
            })
        }
        this.painter = Ext.create(this.dependencyPainterClass, Ext.apply({
            rowHeight: c.getRowHeight(),
            ganttView: c
        }, a));
        if (this.enableDependencyDragDrop) {
            this.dnd = Ext.create("Gnt.feature.DependencyDragDrop", {
                el: c.getEl(),
                rtl: c.rtl,
                ganttView: c,
                dragZoneConfig: this.dragZoneConfig,
                dropZoneConfig: this.dropZoneConfig,
                dependencyStore: this.store
            });
            this.dnd.on("drop", this.onDependencyDrop, this);
            this.relayEvents(this.dnd, ["beforednd", "dndstart", "afterdnd", "drop"])
        }
        if (c.rendered) {
            this.renderAllDependenciesBuffered()
        }
        this.initDependencyListeners()
    },
    initDependencyListeners: function () {
        var a = this;
        a.ganttView.mon(a.ganttView.getEl(), {
            dblclick: a.onDependencyClick,
            click: a.onDependencyClick,
            contextmenu: a.onDependencyClick,
            scope: a,
            delegate: "." + a.dependencyCls
        })
    },
    createDependencyCanvas: function (a) {
        return Ext.fly(a).insertFirst({cls: "sch-dependencyview-ct " + (this.lineWidth === 1 ? " sch-dependencyview-thin " : "")})
    },
    getDependencyCanvas: function () {
        var b = this, c = b.ganttView.getNodeContainer() || b.ganttView.scrollerEl, a = c && Ext.fly(c).child("div.sch-dependencyview-ct");
        if (c && !a) {
            a = b.createDependencyCanvas(c)
        }
        return a
    },
    bindDependencyStore: function (a) {
        this.depStoreListeners = {
            refresh: this.renderAllDependenciesBuffered,
            clear: this.renderAllDependenciesBuffered,
            load: this.renderAllDependenciesBuffered,
            add: this.onDependencyAdd,
            update: this.onDependencyUpdate,
            remove: this.onDependencyDelete,
            scope: this
        };
        a.on(this.depStoreListeners);
        this.store = a
    },
    unBindDependencyStore: function () {
        if (this.depStoreListeners) {
            this.store.un(this.depStoreListeners)
        }
    },
    bindTaskStore: function (a) {
        this.taskStoreListeners = {
            cascade: this.onTaskStoreCascade,
            noderemove: this.renderAllDependenciesBuffered,
            nodeinsert: this.renderAllDependenciesBuffered,
            nodeappend: this.renderAllDependenciesBuffered,
            nodemove: this.renderAllDependenciesBuffered,
            nodeexpand: this.renderAllDependenciesBuffered,
            nodecollapse: this.renderAllDependenciesBuffered,
            sort: this.renderAllDependenciesBuffered,
            scope: this
        };
        a.on(this.taskStoreListeners);
        this.taskStore = a
    },
    onTaskStoreCascade: function (a, b) {
        if (b && b.nbrAffected > 0) {
            this.renderAllDependenciesBuffered()
        }
    },
    unBindTaskStore: function (a) {
        a = a || this.taskStore;
        if (!a) {
            return
        }
        if (this.ganttViewListeners) {
            this.ganttView.un(this.ganttViewListeners)
        }
        a.un(this.taskStoreListeners)
    },
    onDependencyClick: function (b, a) {
        var c = this.getRecordForDependencyEl(a);
        this.fireEvent("dependency" + b.type, this, c, b, a)
    },
    highlightDependency: function (a) {
        if (!(a instanceof Ext.data.Model)) {
            a = this.getDependencyRecordByInternalId(a)
        }
        if (a) {
            a.isHighlighted = true;
            this.getElementsForDependency(a).addCls(this.selectedCls)
        }
    },
    unhighlightDependency: function (a) {
        if (!(a instanceof Ext.data.Model)) {
            a = this.getDependencyRecordByInternalId(a)
        }
        if (a) {
            a.isHighlighted = false;
            this.getElementsForDependency(a).removeCls(this.selectedCls)
        }
    },
    getElementsForDependency: function (c) {
        var a = this, d = c instanceof Ext.data.Model ? c.internalId : c, b = a.getDependencyCanvas();
        return b && b.select(".sch-dep-" + d)
    },
    depRe: new RegExp("sch-dep-([^\\s]+)"),
    getDependencyRecordByInternalId: function (a) {
        return this.store.getModelByInternalId(a)
    },
    getRecordForDependencyEl: function (c) {
        var a = c.className.match(this.depRe), d = null;
        if (a && a[1]) {
            var b = a[1];
            d = this.getDependencyRecordByInternalId(b)
        }
        return d
    },
    renderAllDependenciesBuffered: function () {
        var b = this, c;
        var a = b.ganttView.up("{isHidden()}");
        if (a) {
            clearTimeout(b.renderTimer);
            b.renderTimer = null;
            a.on("show", b.renderAllDependenciesBuffered, b, {single: true});
            return
        }
        if (b.renderTimer) {
            return
        }
        c = b.getDependencyCanvas();
        b.renderTimer = setTimeout(function () {
            b.renderTimer = null;
            if (!b.ganttView.isDestroyed) {
                b.renderAllDependencies()
            }
        }, 0)
    },
    renderAllDependencies: function () {
        var a = this, b = a.getDependencyCanvas();
        if (!b) {
            return
        }
        a.renderDependencies(this.store.data.items, true);
        a.fireEvent("refresh", this)
    },
    getDependencyElements: function () {
        var a = this, b = a.getDependencyCanvas();
        return b && b.select("." + a.dependencyCls)
    },
    renderDependencies: function (e, b) {
        var c = this, d = c.getDependencyCanvas(), a;
        if (!d) {
            return
        }
        if (e && !Ext.isArray(e)) {
            e = [e]
        }
        if (e && e.length > 0) {
            a = c.painter.getDependencyTplData(e);
            c.lineTpl[b ? "overwrite" : "append"](d, a)
        } else {
            if (b) {
                d.update()
            }
        }
    },
    renderTaskDependencies: function (d) {
        var c = [];
        if (d instanceof Ext.data.Model) {
            d = [d]
        }
        for (var a = 0, b = d.length; a < b; a++) {
            c = c.concat(d[a].getAllDependencies())
        }
        this.renderDependencies(c)
    },
    onDependencyUpdate: function (b, a) {
        this.removeDependencyElements(a, false);
        this.renderDependencies(a)
    },
    onDependencyAdd: function (a, b) {
        this.renderDependencies(b)
    },
    removeDependencyElements: function (a, b) {
        if (b !== false) {
            this.getElementsForDependency(a).fadeOut({remove: true})
        } else {
            this.getElementsForDependency(a).remove()
        }
    },
    onDependencyDelete: function (a, b) {
        Ext.Array.each(b, function (c) {
            this.removeDependencyElements(c)
        }, this)
    },
    dimEventDependencies: function (a) {
        var b = this, c = b.getDependencyCanvas();
        c && c.select(b.depRe + a).setOpacity(0.2)
    },
    clearSelectedDependencies: function () {
        var a = this, b = a.getDependencyCanvas();
        b.select("." + a.selectedCls).removeCls(a.selectedCls);
        a.store.each(function (c) {
            c.isHighlighted = false
        })
    },
    onTaskUpdated: function (a) {
        if (!this.taskStore.cascading && (!a.previous || a.startDateField in a.previous || a.endDateField in a.previous)) {
            this.updateDependencies(a)
        }
    },
    updateDependencies: function (b) {
        var a = this;
        if (b instanceof Ext.data.Model) {
            b = [b]
        }
        Ext.Array.forEach(b, function (c) {
            Ext.Array.forEach(c.getAllDependencies(), function (d) {
                a.removeDependencyElements(d, false)
            })
        });
        this.renderTaskDependencies(b)
    },
    onNewDependencyCreated: function () {
    },
    onDependencyDrop: function (g, d, a, e) {
        var f = this, c = f.taskStore, b;
        b = c && c.getModelById(d);
        b && b.linkTo(a, e, null, Ext.Function.bind(f.onNewDependencyCreated, f))
    },
    destroy: function () {
        if (this.dnd) {
            this.dnd.destroy()
        }
        this.unBindTaskStore();
        this.unBindDependencyStore()
    },
    setRowHeight: function (a, b) {
        this.rowHeight = a;
        this.painter.setRowHeight(a);
        if (!b) {
            this.renderAllDependencies()
        }
    }
});
Ext.define("Gnt.view.Gantt", {
    extend: "Sch.view.TimelineGridView",
    alias: ["widget.ganttview"],
    requires: ["Ext.dd.ScrollManager", "Gnt.view.Dependency", "Gnt.model.Task", "Gnt.template.Task", "Gnt.template.ParentTask", "Gnt.template.Milestone", "Gnt.template.RollupTask", "Gnt.feature.TaskDragDrop", "Gnt.feature.ProgressBarResize", "Gnt.feature.TaskResize", "Sch.view.Horizontal"],
    uses: ["Gnt.feature.LabelEditor", "Gnt.feature.DragCreator"],
    mixins: ["Sch.mixin.FilterableTreeView"],
    _cmpCls: "sch-ganttview",
    barMargin: 4,
    scheduledEventName: "task",
    trackOver: false,
    toggleOnDblClick: false,
    eventSelector: ".sch-gantt-item",
    eventWrapSelector: ".sch-event-wrap",
    progressBarResizer: null,
    taskResizer: null,
    taskDragDrop: null,
    dragCreator: null,
    dependencyView: null,
    resizeConfig: null,
    createConfig: null,
    dragDropConfig: null,
    progressBarResizeConfig: null,
    dependencyViewConfig: null,
    externalGetRowClass: null,
    outsideLabelsGatherWidth: 200,
    constructor: function (a) {
        a = a || {};
        if (a) {
            this.externalGetRowClass = a.getRowClass;
            delete a.getRowClass
        }
        this.callParent(arguments);
        this.on("boxready", this.onMyBoxReady, this);
        this.initTreeFiltering()
    },
    onRender: function () {
        this.addCls("sch-ganttview-touch-only");
        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments);
        Ext.getBody().on("mousemove", function () {
            this.removeCls("sch-ganttview-touch-only")
        }, this, {single: true})
    },
    onMyBoxReady: function () {
        if (Ext.supports.Touch && this.getNodeContainer()) {
            this.getDependencyView().getDependencyCanvas().insertBefore(this.getNodeContainer())
        }
    },
    getDependencyStore: function () {
        return this.dependencyStore
    },
    configureFeatures: function () {
        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create("Gnt.feature.ProgressBarResize", Ext.apply({ganttView: this}, this.progressBarResizeConfig || {}));
            this.on({
                beforeprogressbarresize: this.onBeforeTaskProgressBarResize,
                progressbarresizestart: this.onTaskProgressBarResizeStart,
                afterprogressbarresize: this.onTaskProgressBarResizeEnd,
                scope: this
            })
        }
        if (this.resizeHandles !== "none") {
            this.taskResizer = Ext.create("Gnt.feature.TaskResize", Ext.apply({
                ganttView: this,
                validatorFn: this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.resizeConfig || {}));
            this.on({
                beforedragcreate: this.onBeforeDragCreate,
                beforetaskresize: this.onBeforeTaskResize,
                taskresizestart: this.onTaskResizeStart,
                aftertaskresize: this.onTaskResizeEnd,
                scope: this
            })
        }
        if (this.enableTaskDragDrop) {
            this.taskDragDrop = Ext.create("Gnt.feature.TaskDragDrop", this.ownerCt.el, Ext.apply({
                gantt: this,
                validatorFn: this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.dragDropConfig));
            this.on({
                beforetaskdrag: this.onBeforeTaskDrag,
                taskdragstart: this.onDragDropStart,
                aftertaskdrop: this.onDragDropEnd,
                scope: this
            })
        }
        if (this.enableDragCreation) {
            this.dragCreator = Ext.create("Gnt.feature.DragCreator", Ext.apply({
                ganttView: this,
                validatorFn: this.createValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.createConfig))
        }
    },
    getTemplateForTask: function (b, a) {
        if (b.isMilestone(a)) {
            return this.milestoneTemplate
        }
        if (b.isLeaf()) {
            return this.eventTemplate
        }
        return this.parentEventTemplate
    },
    refreshParentNode: function (a) {
        var b = a.parentNode;
        if (b) {
            this.refreshNode(b)
        }
    },
    refreshChildNodes: function (b, a) {
        var c = this;
        b.cascadeBy(function (d) {
            if (!a || d !== b) {
                c.refreshNode(d)
            }
        })
    },
    setShowRollupTasks: function (a) {
        this.showRollupTasks = a;
        var b = {};
        this.taskStore.getRootNode().cascadeBy(function (f) {
            if (f.getRollup()) {
                var e = f.parentNode;
                b[e.internalId] = e
            }
        });
        for (var d in b) {
            var c = this.store.indexOf(b[d]);
            if (c >= 0) {
                this.refreshNode(c)
            }
        }
    },
    getRollupRenderData: function (e) {
        var a = [];
        var j = this.timeAxis, k = j.getStart(), n = j.getEnd();
        for (var h = 0; h < e.childNodes.length; h++) {
            var f = e.childNodes[h];
            if (f.getRollup()) {
                var q = f.getStartDate(), d = f.getEndDate() || Sch.util.Date.add(q, f.getDurationUnit() || Sch.util.Date.DAY, 1);
                if (Sch.util.Date.intersectSpans(q, d, k, n)) {
                    var g = {}, o = f.isMilestone();
                    g.isRollup = true;
                    g.id = "rollup_" + f.getId();
                    var c = d > n, b = Sch.util.Date.betweenLesser(q, k, n), m = Math.floor(this.getXFromDate(b ? q : k)), p = Math.floor(this.getXFromDate(c ? n : d)), l = o ? 0 : p - m;
                    g.offset = (o ? (p || m) - this.getXOffset(f) : m);
                    g.tpl = o ? this.milestoneTemplate : this.eventTemplate;
                    g.cls = f.getCls();
                    g.ctcls = "";
                    g.record = f;
                    if (o) {
                        g.side = Ext.isIE8m ? Math.round(0.3 * this.getRowHeight()) : Math.round(0.5 * this.getRowHeight());
                        g.ctcls += " sch-gantt-milestone"
                    } else {
                        g.width = Math.max(1, l);
                        if (c) {
                            g.ctcls += " sch-event-endsoutside "
                        }
                        if (!b) {
                            g.ctcls += " sch-event-startsoutside "
                        }
                        g.ctcls += " sch-gantt-task"
                    }
                    g.cls += " sch-rollup-task";
                    a.push(g)
                }
            }
        }
        return a
    },
    getLabelRenderData: function (b) {
        var e = this.leftLabelField, a = this.rightLabelField, f = this.topLabelField, c = this.bottomLabelField, d = {};
        if (e) {
            d.leftLabel = Ext.util.Format.htmlEncode(e.renderer.call(e.scope || this, b.data[e.dataIndex], b))
        }
        if (a) {
            d.rightLabel = Ext.util.Format.htmlEncode(a.renderer.call(a.scope || this, b.data[a.dataIndex], b))
        }
        if (f) {
            d.topLabel = Ext.util.Format.htmlEncode(f.renderer.call(f.scope || this, b.data[f.dataIndex], b))
        }
        if (c) {
            d.bottomLabel = Ext.util.Format.htmlEncode(c.renderer.call(c.scope || this, b.data[c.dataIndex], b))
        }
        return d
    },
    columnRenderer: function (R, p, z) {
        var S = z.getStartDate(), j = this.timeAxis, u = Sch.util.Date, y = {}, q = "", K = "", B = j.getStart(), Q = j.getEnd(), G = z.isMilestone(), F = z.isLeaf(), O = z.isProject, x = z.isReadOnly(), f = false, n, b, C;
        if (S) {
            var U = z.getEndDate() || u.add(S, z.getDurationUnit() || u.DAY, 1), a = j.getAt(0), L = (a.getEndDate() - a.getStartDate()) / this.timeAxisViewModel.getTickWidth(), H = L * this.outsideLabelsGatherWidth, r = u.intersectSpans(S, U, B, Q), g = this.outsideLabelsGatherWidth > 0, d = g && u.intersectSpans(S, U, Q, new Date(Q.getTime() + H)), w = g && u.intersectSpans(S, U, new Date(B.getTime() - H), B);
            if (r || d || w) {
                C = U > Q;
                b = u.betweenLesser(S, B, Q);
                var J, A, e;
                if (r) {
                    J = Math.floor(this.getXFromDate(b ? S : B));
                    A = Math.floor(this.getXFromDate(C ? Q : U));
                    e = G ? 0 : A - J
                } else {
                    b = true;
                    e = 0;
                    if (d) {
                        J = Math.floor(this.getXFromDate(Q) + (S - Q) / L)
                    } else {
                        J = Math.floor(this.getXFromDate(B) - (B - U) / L)
                    }
                }
                var X = G ? (A || J) - this.getXOffset(z) : J;
                var I = Math.min(z.getPercentDone() || 0, 100) / 100, T, N, Y;
                var W = z.getSegments(), t;
                if (W) {
                    var l = 0, E = W.length, V, v;
                    for (V = 0; V < E; V++) {
                        v = W[V];
                        l += (v.getEndDate() - v.getStartDate()) * I
                    }
                    t = [];
                    var P, h, o, c;
                    for (V = 0; V < E; V++) {
                        v = W[V];
                        var k = {}, M = v.getCls() || "";
                        c = v.getEndDate() || z.getStartDate();
                        o = v.getStartDate();
                        if (u.betweenLesser(o, B, Q)) {
                            P = Math.floor(this.getXFromDate(o));
                            if (u.betweenLesser(c, B, Q)) {
                                h = Math.floor(this.getXFromDate(c))
                            } else {
                                h = Math.floor(this.getXFromDate(Q))
                            }
                        } else {
                            P = Math.floor(this.getXFromDate(B));
                            if (u.betweenLesser(c, B, Q)) {
                                h = Math.floor(this.getXFromDate(c))
                            } else {
                                if (o > Q && c > Q) {
                                    P = h = Math.floor(this.getXFromDate(Q)) + 100
                                } else {
                                    if (o < B && c < B) {
                                        P = h = Math.floor(this.getXFromDate(B)) - 100
                                    } else {
                                        h = Math.floor(this.getXFromDate(Q))
                                    }
                                }
                            }
                        }
                        k.left = P - J;
                        k.width = h - P;
                        if (!T) {
                            l -= (c - o);
                            if (l <= 0) {
                                T = u.add(c, u.MILLI, l);
                                M += " sch-segment-in-progress";
                                N = Math.floor(this.getXFromDate(T));
                                k.progressBarWidth = Math.min(Math.abs(N - P), k.width)
                            } else {
                                k.progressBarWidth = v.width
                            }
                        } else {
                            k.progressBarWidth = 0
                        }
                        k.percentDone = I * 100;
                        Ext.apply(k, v.data);
                        k.cls = M;
                        k.SegmentIndex = V;
                        t.push(k)
                    }
                    t[0].cls += " sch-gantt-task-segment-first";
                    t[E - 1].cls += " sch-gantt-task-segment-last"
                } else {
                    T = new Date((U - S) * I + S.getTime());
                    if (T < B) {
                        T = B
                    } else {
                        if (T > Q) {
                            T = Q
                        }
                    }
                }
                N = Math.floor(this.getXFromDate(T));
                Y = Math.min(Math.abs(N - J), e);
                y = Ext.apply({}, {
                    id: z.internalId + "-x-x",
                    offset: X,
                    width: Math.max(1, e),
                    ctcls: "",
                    cls: "",
                    print: this._print,
                    record: z,
                    percentDone: I * 100,
                    progressBarWidth: Math.max(0, Y - 2 * this.eventBorderWidth),
                    segments: t
                }, z.data);
                n = this.eventRenderer.call(this.eventRendererScope || this, z, y, z.store) || {};
                Ext.apply(y, this.getLabelRenderData(z));
                f = true;
                Ext.apply(y, n);
                var m = " sch-event-resizable-" + z.getResizable();
                if (G) {
                    y.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.getRowHeight());
                    K += " sch-gantt-milestone"
                } else {
                    y.width = Math.max(1, e);
                    if (C) {
                        K += " sch-event-endsoutside "
                    }
                    if (!b) {
                        K += " sch-event-startsoutside "
                    }
                    if (F) {
                        K += " sch-gantt-task"
                    } else {
                        K += " sch-gantt-parent-task"
                    }
                    if (x) {
                        K += " sch-gantt-task-readonly"
                    }
                }
                if (O) {
                    K += " sch-gantt-project-task"
                }
                if (z.dirty) {
                    m += " sch-dirty "
                }
                if (z.isDraggable() === false) {
                    m += " sch-event-fixed "
                }
                m += z.isSegmented() ? " sch-event-segmented " : " sch-event-notsegmented ";
                if(z.isReadOnly()){
                    m += " sch-event-readonly "
                }
                y.cls = (y.cls || "") + (z.getCls() || "") + m;
                y.ctcls += " " + K;
                if (this.showRollupTasks) {
                    var s = this.getRollupRenderData(z);
                    if (s.length > 0) {
                        q += this.rollupTemplate.apply(s)
                    }
                }
                q += this.getTemplateForTask(z).apply(y)
            }
        }
        if (this.enableBaseline) {
            if (!n) {
                n = this.eventRenderer.call(this, z, y, z.store) || {}
            }
            q += this.baselineRenderer(z, n, B, Q, f)
        }
        return q
    },
    baselineRenderer: function (i, d, l, n, g) {
        var a = Sch.util.Date, p = i.getBaselineStartDate(), m = i.getBaselineEndDate();
        if (p && m && a.intersectSpans(p, m, l, n)) {
            var f = m > n;
            var e = a.betweenLesser(p, l, n);
            var k = i.isBaselineMilestone(), q = Math.floor(this.getXFromDate(e ? p : l)), o = Math.floor(this.getXFromDate(f ? n : m)), h = Math.max(1, k ? 0 : o - q), c = this.getTemplateForTask(i, true), j = {
                progressBarStyle: d.baseProgressBarStyle || "",
                id: "base-" + i.internalId,
                progressBarWidth: Math.min(100, i.getBaselinePercentDone()) * h / 100,
                percentDone: i.getBaselinePercentDone(),
                offset: k ? (o || q) - this.getXOffset(i, true) : q,
                print: this._print,
                width: Math.max(1, h),
                baseline: true
            };
            var b = "";
            if (k) {
                j.side = Math.round(0.4 * this.getRowHeight());
                b = "sch-gantt-milestone-baseline sch-gantt-baseline-item"
            } else {
                if (i.isLeaf()) {
                    b = "sch-gantt-task-baseline sch-gantt-baseline-item"
                } else {
                    b = "sch-gantt-parenttask-baseline sch-gantt-baseline-item"
                }
            }
            if (f) {
                b += " sch-event-endsoutside "
            }
            if (!e) {
                b += " sch-event-startsoutside "
            }
            j.ctcls = b + " " + (d.basecls || "");
            if (!g) {
                Ext.apply(j, this.getLabelRenderData(i))
            }
            return c.apply(j)
        }
        return ""
    },
    setupTemplates: function () {
        var a = {
            leftLabel: this.leftLabelField,
            rightLabel: this.rightLabelField,
            topLabel: this.topLabelField,
            bottomLabel: this.bottomLabelField,
            prefix: this.eventPrefix,
            resizeHandles: this.resizeHandles,
            enableDependencyDragDrop: this.enableDependencyDragDrop !== false,
            allowParentTaskDependencies: this.allowParentTaskDependencies !== false,
            enableProgressBarResize: this.enableProgressBarResize,
            rtl: this.rtl
        };
        var b;
        if (!this.eventTemplate) {
            b = this.taskBodyTemplate ? Ext.apply({innerTpl: this.taskBodyTemplate}, a) : a;
            this.eventTemplate = Ext.create("Gnt.template.Task", b)
        }
        if (!this.parentEventTemplate) {
            b = this.parentTaskBodyTemplate ? Ext.apply({innerTpl: this.parentTaskBodyTemplate}, a) : a;
            this.parentEventTemplate = Ext.create("Gnt.template.ParentTask", b)
        }
        if (!this.milestoneTemplate) {
            b = this.milestoneBodyTemplate ? Ext.apply({innerTpl: this.milestoneBodyTemplate}, a) : a;
            this.milestoneTemplate = Ext.create("Gnt.template.Milestone", b)
        }
        if (!this.rollupTemplate) {
            this.rollupTemplate = Ext.create("Gnt.template.RollupTask", a)
        }
    },
    getDependencyView: function () {
        return this.dependencyView
    },
    getTaskStore: function () {
        return this.taskStore
    },
    initDependencies: function () {
        if (this.dependencyStore) {
            var b = this, a = Ext.create("Gnt.view.Dependency", Ext.apply({
                containerEl: b.el,
                ganttView: b,
                enableDependencyDragDrop: b.enableDependencyDragDrop,
                allowParentTaskDependencies: b.allowParentTaskDependencies,
                store: b.dependencyStore,
                rtl: b.rtl
            }, this.dependencyViewConfig));
            a.on({
                beforednd: b.onBeforeDependencyDrag,
                dndstart: b.onDependencyDragStart,
                drop: b.onDependencyDrop,
                afterdnd: b.onAfterDependencyDragDrop,
                scope: b
            });
            b.dependencyView = a;
            b.relayEvents(a, ["dependencyclick", "dependencycontextmenu", "dependencydblclick"])
        }
    },
    setupGanttEvents: function () {
        var a = this.taskStore;
        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick: function (b, d) {
                    if (!d.isLeaf() && (!a.isTreeFiltered() || a.allowExpandCollapseWhileFiltered)) {
                        var e = this;
                        var c = function () {
                            this.fireEvent.apply(this, ["taskdblclick"].concat(Array.prototype.slice.apply(arguments)))
                        };
                        this.on("taskclick", c);
                        setTimeout(function () {
                            e.un("taskclick", c)
                        }, 300);
                        d.isExpanded() ? d.collapse() : d.expand()
                    }
                }
            })
        }
    },
    configureLabels: function () {
        var a = {
            renderer: function (b) {
                return b
            }, dataIndex: undefined
        };
        Ext.Array.forEach(["left", "right", "top", "bottom"], function (c) {
            var b = this[c + "LabelField"];
            if (b) {
                if (Ext.isString(b)) {
                    b = this[c + "LabelField"] = {dataIndex: b}
                }
                Ext.applyIf(b, a);
                if (b.editor) {
                    b.editor = Ext.create("Gnt.feature.LabelEditor", this, {
                        labelPosition: c,
                        field: b.editor,
                        dataIndex: b.dataIndex
                    })
                }
            }
        }, this);
        this.on("labeledit_beforestartedit", this.onBeforeLabelEdit, this)
    },
    onBeforeTaskDrag: function (b, a) {
        return !this.readOnly && a.isDraggable() !== false && (this.allowParentTaskMove || a.isLeaf())
    },
    onDragDropStart: function () {
        if (this.tip) {
            this.tip.on("beforeshow", this.falseReturningFn)
        }
    },
    falseReturningFn: function () {
        return false
    },
    onDragDropEnd: function () {
        if (this.tip) {
            this.tip.un("beforeshow", this.falseReturningFn)
        }
    },
    onTaskProgressBarResizeStart: function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
    },
    onTaskProgressBarResizeEnd: function () {
        if (this.tip) {
            this.tip.enable()
        }
    },
    onTaskResizeStart: function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(true)
        }
    },
    onTaskResizeEnd: function () {
        if (this.tip) {
            this.tip.enable()
        }
        if (this.scrollManager) {
            this.scrollManager.scroller.setDisabled(false)
        }
    },
    onBeforeDragCreate: function () {
        return !this.readOnly
    },
    onBeforeTaskResize: function (a, b) {
        return !this.readOnly && b.getSchedulingMode() !== "EffortDriven"
    },
    onBeforeTaskProgressBarResize: function () {
        return !this.readOnly
    },
    onBeforeLabelEdit: function () {
        return !this.readOnly
    },
    onBeforeEdit: function () {
        return !this.readOnly
    },
    afterRender: function () {
        this.initDependencies();
        this.callParent(arguments);
        this.el.on("mousemove", this.configureFeatures, this, {single: true});
        Ext.dd.ScrollManager.register(this.el)
    },
    resolveTaskRecord: function (a) {
        var b = this.findItemByChild(a);
        if (b) {
            return this.getRecord(this.findItemByChild(a))
        }
        return null
    },
    resolveEventRecord: function (a) {
        return this.resolveTaskRecord(a)
    },
    resolveEventRecordFromResourceRow: function (a) {
        return this.resolveTaskRecord(a)
    },
    highlightTask: function (c, b) {
        if (!(c instanceof Ext.data.Model)) {
            c = this.taskStore.getModelById(c)
        }
        if (c) {
            c.isHighlighted = true;
            var e = this.getRow(c);
            if (e) {
                Ext.fly(e).addCls("sch-gantt-task-highlighted")
            }
            if (b !== false) {
                for (var d = 0, a = c.successors.length; d < a; d++) {
                    var f = c.successors[d];
                    this.highlightDependency(f);
                    this.highlightTask(f.getTargetTask(), b)
                }
            }
        }
    },
    unhighlightTask: function (b, e) {
        if (!(b instanceof Ext.data.Model)) {
            b = this.taskStore.getModelById(b)
        }
        if (b) {
            b.isHighlighted = false;
            var d = this.getRow(b);
            if (d) {
                Ext.fly(d).removeCls("sch-gantt-task-highlighted")
            }
            if (e !== false) {
                for (var c = 0, a = b.successors.length; c < a; c++) {
                    var f = b.successors[c];
                    this.unhighlightDependency(f);
                    this.unhighlightTask(f.getTargetTask(), e)
                }
            }
        }
    },
    getRowClass: function (b) {
        var a = "";
        if (b.isHighlighted) {
            a = "sch-gantt-task-highlighted"
        }
        if (this.externalGetRowClass) {
            a += " " + (this.externalGetRowClass.apply(this, arguments) || "")
        }
        return a
    },
    clearSelectedTasksAndDependencies: function () {
        this.getDependencyView().clearSelectedDependencies();
        this.el.select(".sch-gantt-task-highlighted").removeCls("sch-gantt-task-highlighted");
        this.taskStore.getRootNode().cascadeBy(function (a) {
            a.isHighlighted = false
        })
    },
    getCriticalPaths: function () {
        return this.taskStore.getCriticalPaths()
    },
    highlightCriticalPaths: function () {
        this.clearSelectedTasksAndDependencies();
        var f = this.getCriticalPaths(), c = this.getDependencyView(), e, d, b, a;
        Ext.Array.forEach(f, function (i) {
            for (d = 0, b = i.length; d < b; d++) {
                e = i[d];
                this.highlightTask(e, false);
                if (d < b - 1) {
                    for (var h = 0, g = e.predecessors.length; h < g; h++) {
                        if (e.predecessors[h].getSourceId() == i[d + 1].getId()) {
                            a = e.predecessors[h];
                            break
                        }
                    }
                    c.highlightDependency(a)
                }
            }
        }, this);
        this.addCls("sch-gantt-critical-chain")
    },
    unhighlightCriticalPaths: function () {
        this.removeCls("sch-gantt-critical-chain");
        this.clearSelectedTasksAndDependencies()
    },
    getXOffset: function (b, a) {
        var c = 0;
        if (b.isMilestone(a)) {
            c = Math.floor(this.getRowHeight() * Math.sqrt(2) / 4) - 2
        }
        return c
    },
    onDestroy: function () {
        if (this.dependencyView) {
            this.dependencyView.destroy()
        }
        if (this.rendered) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
        this.callParent(arguments)
    },
    highlightDependency: function (a) {
        this.dependencyView.highlightDependency(a)
    },
    unhighlightDependency: function (a) {
        this.dependencyView.unhighlightDependency(a)
    },
    onBeforeDependencyDrag: function (b, a) {
        return this.fireEvent("beforedependencydrag", this, a)
    },
    onDependencyDragStart: function (a) {
        this.fireEvent("dependencydragstart", this);
        if (this.tip) {
            this.tip.disable()
        }
        this.preventOverCls = true
    },
    onDependencyDrop: function (b, c, a, d) {
        this.fireEvent("dependencydrop", this, this.taskStore.getModelById(c), this.taskStore.getModelById(a), d)
    },
    onAfterDependencyDragDrop: function () {
        this.fireEvent("afterdependencydragdrop", this);
        if (this.tip) {
            this.tip.enable()
        }
        this.preventOverCls = false
    },
    getLeftEditor: function () {
        return this.leftLabelField && this.leftLabelField.editor
    },
    getRightEditor: function () {
        return this.rightLabelField && this.rightLabelField.editor
    },
    getTopEditor: function () {
        return this.topLabelField && this.topLabelField.editor
    },
    getBottomEditor: function () {
        return this.bottomLabelField && this.bottomLabelField.editor
    },
    editLeftLabel: function (a) {
        var b = this.getLeftEditor();
        if (b) {
            b.edit(a)
        }
    },
    editRightLabel: function (a) {
        var b = this.getRightEditor();
        if (b) {
            b.edit(a)
        }
    },
    editTopLabel: function (a) {
        var b = this.getTopEditor();
        if (b) {
            b.edit(a)
        }
    },
    editBottomLabel: function (a) {
        var b = this.getBottomEditor();
        if (b) {
            b.edit(a)
        }
    },
    getDependenciesForTask: function (a) {
        return a.getAllDependencies()
    },
    onUpdate: function (c, a, b) {
        this.callParent(arguments);
        if (b == Ext.data.Model.EDIT) {
            var d = a.previous;
            if (d) {
                if (a.rollupField in d || a.getRollup()) {
                    this.refreshParentNode(a)
                }
                if (a.isProject && a.readOnlyField in d) {
                    this.refreshChildNodes(a, true)
                }
            }
        }
    },
    handleScheduleEvent: function (c) {
        var a = c.getTarget("." + this.timeCellCls, 3);
        if (a) {
            var b = this.findRowByChild(a);
            if (c.type.indexOf("pinch") >= 0) {
                this.fireEvent("schedule" + c.type, this, c)
            } else {
                this.fireEvent("schedule" + c.type, this, this.getDateFromDomEvent(c, "floor"), this.indexOf(b), c)
            }
        }
    },
    scrollEventIntoView: function (d, e, b, m, n) {
        n = n || this;
        var i = this;
        var j = this.taskStore;
        var k = function (p, o) {
            i.up("panel").scrollTask.cancel();
            i.scrollElementIntoView(p, o, b);
            if (e) {
                if (typeof e === "boolean") {
                    p.highlight()
                } else {
                    p.highlight(null, e)
                }
            }
            m && m.call(n)
        };
        if (!d.isVisible()) {
            d.bubble(function (o) {
                o.expand()
            })
        }
        var l;
        var c = d.getStartDate();
        var h = d.getEndDate();
        var a = Boolean(c && h);
        if (a) {
            var g = this.timeAxis;
            if (!g.dateInAxis(c) || !g.dateInAxis(h)) {
                var f = g.getEnd() - g.getStart();
                g.setTimeSpan(new Date(c.getTime() - f / 2), new Date(h.getTime() + f / 2))
            }
            l = this.getElementFromEventRecord(d)
        } else {
            l = this.getNode(d);
            if (l) {
                l = Ext.fly(l).down(this.getCellSelector())
            }
        }
        if (l) {
            k(l, a)
        } else {
            if (this.bufferedRenderer) {
                Ext.Function.defer(function () {
                    i.bufferedRenderer.scrollTo(j.getIndexInTotalDataset(d), false, function () {
                        var o = i.getElementFromEventRecord(d);
                        if (o) {
                            k(o, true)
                        } else {
                            m && m.call(n)
                        }
                    })
                }, 10)
            }
        }
    },
    setRowHeight: function (a) {
        this.getDependencyView().setRowHeight(a, true);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.view.ResourceHistogram", {
    extend: "Sch.view.TimelineGridView",
    alias: "widget.resourcehistogramview",
    requires: ["Ext.XTemplate", "Ext.util.Format", "Sch.util.Date"],
    _cmpCls: "gnt-resourcehistogramview",
    scheduledEventName: "bar",
    eventSelector: ".gnt-resourcehistogram-bar",
    barTpl: null,
    barRenderer: Ext.emptyFn,
    limitLineRenderer: Ext.emptyFn,
    lineRenderer: Ext.emptyFn,
    lineTpl: null,
    limitLineTpl: null,
    _barCls: "gnt-resourcehistogram-bar",
    _limitLineCls: "gnt-resourcehistogram-limitline",
    _limitLineVerticalCls: "gnt-resourcehistogram-limitline-vertical",
    _lineCls: "gnt-resourcehistogram-line",
    barCls: null,
    limitLineCls: null,
    lineCls: null,
    limitLineWidth: 1,
    rowHeight: 60,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    labelMode: false,
    labelPercentFormat: "0",
    labelUnitsFormat: "0.0",
    histogram: null,
    unitHeight: null,
    availableRowHeight: null,
    initComponent: function (a) {
        if (this.barCls) {
            this.eventSelector = "." + this.barCls
        }
        if (!this.barTpl) {
            this.barTpl = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="gnt-resourcehistogram-bar ' + (this.barCls || "") + ' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">', "<tpl if=\"text !== ''\">", '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight / 2) + 'px">{text}</span>', "</tpl>", "</div>", "</tpl>")
        }
        if (!this.lineTpl) {
            this.lineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-line ' + (this.lineCls || "") + ' {cls}" style="top:{top}px;"></div>', "</tpl>")
        }
        if (!this.limitLineTpl) {
            this.limitLineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-limitline ' + (this.limitLineCls || "") + ' {cls}" style="left:{left}px;top:{top}px;width:{width}px;height:{height}px"></div>', "</tpl>")
        }
        this.callParent(arguments);
        this.unitHeight = this.getAvailableRowHeight() / (this.scaleMax - this.scaleMin + this.scaleStep)
    },
    renderLines: function () {
        return this.lineTpl.apply(this.prepareLines())
    },
    prepareLines: function () {
        var e = this.scaleMin, j = this.scaleMax, k = e, f = this.scaleLabelStep, a = this.getAvailableRowHeight(), g = [], o = this._lineCls, m = o + "min";
        var n, b;
        if (this.scalePoints) {
            for (var d = 0, c = this.scalePoints.length; d < c; d++) {
                var h = this.scalePoints[d];
                n = {
                    value: h.value,
                    top: h.top || Math.round(a - this.unitHeight * (h.value - e)),
                    cls: h.cls + (h.label ? " " + o + "-label" : "") + (d === 0 ? " " + o + "-min" : (d == c ? " " + o + "-max" : ""))
                };
                b = this.lineRenderer(g, n);
                g.push(Ext.apply(n, b))
            }
        } else {
            while (k <= j) {
                n = {value: k, top: Math.round(a - this.unitHeight * (k - e)), cls: m};
                b = this.lineRenderer(g, n);
                g.push(Ext.apply(n, b));
                k += this.scaleStep;
                m = k % f ? "" : o + "-label";
                if (k == j) {
                    m += " " + o + "-max"
                }
            }
            if (g.length && g[g.length - 1].value !== j) {
                n = {
                    value: j,
                    top: Math.round(a - this.unitHeight * (j - e)),
                    cls: (j % f ? "" : o + "-label") + " " + o + "-max"
                };
                b = this.lineRenderer(g, n);
                g.push(Ext.apply(n, b))
            }
        }
        return g
    },
    renderLimitLines: function (a) {
        return this.limitLineTpl.apply(this.prepareLimitLines(a))
    },
    getLimitLinesConnector: function (b, a) {
        return {
            left: b.right,
            width: 1,
            top: Math.min(b.top, a.top),
            height: Math.abs(b.top - a.top) + this.limitLineWidth,
            cls: this._limitLineCls + "-top " + this._limitLineVerticalCls
        }
    },
    pushLimitLine: function (c, b, d) {
        var e = c[c.length - 1];
        if (d) {
            if (e) {
                e.width = d.right - e.left;
                e.right = d.right
            } else {
                b.left = d.left;
                b.width = b.right - d.left
            }
        }
        if (e && this.showVerticalLimitLines) {
            if (!e.visible) {
                c.pop()
            }
            c.push(this.getLimitLinesConnector(e, b))
        }
        var a = this.limitLineRenderer(c, b, d);
        c.push(Ext.apply(b, a))
    },
    prepareLimitLines: function (v) {
        if (!v) {
            return
        }
        var b = [], a = this.scaleMin, d = this.scaleMax, k = this.scaleStep, s = this.scaleUnit, c = this.getAvailableRowHeight(), o = this._limitLineCls, t = this.getTimeAxisViewModel() && this.getTimeAxisViewModel().getTotalWidth(), p, j, m;
        for (var r = 0, q = v.length; r < q; r++) {
            var e = this.calendar.convertMSDurationToUnit(v[r].allocationMS, s);
            var f = true;
            if (e * this.unitHeight > c) {
                e = d + k;
                f = false
            } else {
                if (e <= 0) {
                    e = 0;
                    f = false
                }
            }
            var g = v[r].startDate && this.getXFromDate(v[r].startDate, true) || 0;
            var u = v[r].endDate && this.getXFromDate(v[r].endDate, true) || t;
            if (g < 0) {
                g = 0
            }
            if (u < 0) {
                u = t
            }
            j = {left: g, width: u - g, right: u, top: "", height: 0, cls: "", visible: f};
            j.top = Math.round(c - (e - a) * this.unitHeight);
            if (f) {
                j.cls += " " + o + "-top"
            }
            m = b[b.length - 1] || p;
            var h = j.width <= this.showLimitLinesThreshold;
            if (m && (j.top == m.top || (h && !f))) {
                m.width = u - m.left;
                m.right = u;
                j = null;
                if (b[b.length - 1]) {
                    p = null
                } else {
                    if (p.width > this.showLimitLinesThreshold) {
                        this.pushLimitLine(b, p);
                        p = null
                    }
                }
            } else {
                if (h && f) {
                    if (p) {
                        var n = p.width + j.width;
                        p.top = Math.round(j.top * j.width / n + p.top * p.width / n);
                        p.width = u - p.left;
                        p.right = u
                    } else {
                        p = j
                    }
                    if (p.width > this.showLimitLinesThreshold) {
                        this.pushLimitLine(b, p);
                        j = p = null
                    }
                } else {
                    this.pushLimitLine(b, j, p);
                    j = p = null
                }
            }
        }
        j && this.pushLimitLine(b, j, p);
        m = b[b.length - 1];
        if (m && !m.visible) {
            b.pop()
        }
        return b
    },
    renderBars: function (a, b) {
        return this.barTpl.apply(this.prepareBars(a, b))
    },
    prepareBars: function (j, m) {
        if (!j) {
            return
        }
        var p = [], a = this.getAvailableRowHeight(), r = this._barCls, d = this.scaleUnit, g = Sch.util.Date.getShortNameOfUnit(d), k = this.scaleMin, q = this.scaleMax, o = this.scaleStep, f = q + o, c, n;
        for (var h = 0, e = j.length; h < e; h++) {
            if (j[h].totalAllocation) {
                n = this.calendar.convertMSDurationToUnit(j[h].allocationMS, d);
                c = {
                    id: m + "-" + h,
                    index: h,
                    left: this.getXFromDate(j[h].startDate, true),
                    width: this.getXFromDate(j[h].endDate, true) - this.getXFromDate(j[h].startDate, true),
                    height: a,
                    top: 0,
                    text: "",
                    cls: ""
                };
                if (this.labelMode) {
                    switch (this.labelMode) {
                        case"percent":
                            c.text = Ext.util.Format.number(j[h].totalAllocation, this.labelPercentFormat) + "%";
                            break;
                        case"units":
                            c.text = Ext.util.Format.number(n, this.labelUnitsFormat) + g;
                            break;
                        default:
                            c.text = this.labelMode.apply({allocation: n, percent: j[h].totalAllocation})
                    }
                }
                if (n <= f) {
                    c.height = n >= k ? Math.round((n - k) * this.unitHeight) : 0;
                    c.top = a - c.height
                } else {
                    c.cls += " " + r + "-partofbar"
                }
                if (j[h].totalAllocation > 100 || j[h].totalOverAllocationMS > 0) {
                    c.cls += " " + r + "-overwork"
                }
                var b = this.barRenderer(m, j[h], c);
                if (b && b.cls) {
                    b.cls = c.cls + " " + b.cls
                }
                c = Ext.apply(c, b);
                p.push(c)
            }
        }
        return p
    },
    getAvailableRowHeight: function () {
        if (this.availableRowHeight) {
            return this.availableRowHeight
        }
        this.availableRowHeight = this.rowHeight - this.cellTopBorderWidth - this.cellBottomBorderWidth;
        return this.availableRowHeight
    },
    resolveEventRecord: function (c) {
        var e = this.findItemByChild(c);
        if (e) {
            var g = this.getRecord(e);
            if (g) {
                var a = {resource: g};
                var f = this.histogram.allocationData[g.getId()];
                var b = c.getAttribute("gnt-bar-index");
                var d = f.bars[b];
                if (d) {
                    a.startDate = d.startDate;
                    a.endDate = d.endDate;
                    a.assignments = d.assignments;
                    a.allocationMS = d.allocationMS;
                    a.totalAllocation = d.totalAllocation
                }
                return a
            }
        }
        return null
    },
    resolveEventRecordFromResourceRow: function (a) {
        return this.resolveEventRecord(a)
    },
    getDataForTooltipTpl: function (a) {
        return a
    }
});
Ext.define("Gnt.column.Scale", {
    extend: "Ext.grid.column.Template",
    alias: "widget.scalecolumn",
    tpl: null,
    sortable: false,
    scalePoints: null,
    scaleStep: 2,
    scaleLabelStep: 4,
    scaleMin: 0,
    scaleMax: 24,
    width: 40,
    availableHeight: 48,
    scaleCellCls: "gnt-scalecolumn",
    initComponent: function () {
        this.tdCls = (this.tdCls || "") + " " + this.scaleCellCls;
        if (!this.tpl) {
            this.tpl = new Ext.XTemplate('<div class="' + this.scaleCellCls + '-wrap" style="height:{scaleHeight}px;">', '<tpl for="scalePoints">', "<tpl if=\"label !== ''\">", '<span class="' + this.scaleCellCls + '-label-line {cls}" style="top:{top}px"><span class="' + this.scaleCellCls + '-label">{label}</span></span>', "<tpl else>", '<span class="' + this.scaleCellCls + '-line {cls}" style="top:{top}px"></span>', "</tpl>", "</tpl>", "</div>")
        }
        this.setAvailableHeight(this.availableHeight, true);
        this.callParent(arguments)
    },
    setAvailableHeight: function (a, b) {
        this.availableHeight = a;
        if (!this.scalePoints) {
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            this.scalePoints = this.buildScalePoints()
        } else {
            if (b) {
                this.scalePoints.sort(function (d, c) {
                    return d.value - c.value
                });
                this.scaleMin = this.scalePoints[0].value;
                this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
                this.scaleStep = (this.scaleMax - this.scaleMin) / 10
            }
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            this.updateScalePointsTops()
        }
    },
    defaultRenderer: function (c, d, a) {
        var b = {
            record: Ext.apply({}, a.data, a.getAssociatedData()),
            scaleHeight: this.availableHeight,
            scalePoints: this.scalePoints
        };
        return this.tpl.apply(b)
    },
    buildScalePoints: function () {
        var g = this.scaleMin, h = g, c = this.scaleStep, f = this.scaleLabelStep, d = this.scaleStepHeight, b = this.availableHeight, a = this.scaleCellCls, i = a + "-min", j = [];
        var e = function (m, l, k) {
            return {top: Math.round(b - (m - g) * d), value: m, label: l != "undefined" ? l : "", cls: k || ""}
        };
        while (h < this.scaleMax) {
            j.push(e(h, h % f || h === g ? "" : h, i));
            i = "";
            h += c
        }
        j.push(e(this.scaleMax, this.scaleMax, a + "-max"));
        return j
    },
    updateScalePointsTops: function () {
        var a = this.scaleStepHeight, b = this.availableHeight;
        Ext.Array.forEach(this.scalePoints, function (c) {
            c.top = Math.round(b - c.value * a)
        })
    }
});
Ext.define("Gnt.field.mixin.TaskField", {
    extend: "Ext.Mixin",
    taskField: "",
    getTaskValueMethod: "",
    setTaskValueMethod: "",
    isTaskField: true,
    task: null,
    taskStore: null,
    suppressTaskUpdate: 0,
    highlightTaskUpdates: true,
    highlightColor: "#009900",
    lastHighlight: 0,
    instantUpdate: true,
    mixinConfig: {
        before: {constructor: "beforeConstructed", destroy: "beforeDestroyed"},
        after: {constructor: "afterConstructed"}
    },
    beforeConstructed: function () {
        this.setSuppressTaskUpdate(true)
    },
    afterConstructed: function () {
        this.task && this.setTask(this.task);
        this.setSuppressTaskUpdate(false)
    },
    beforeDestroyed: function () {
        this.destroyTaskListener()
    },
    setTask: function (a) {
        if (!a) {
            return
        }
        this.destroyTaskListener();
        this.updateReadOnly(a);
        this.task = a;
        a.on("taskupdated", this.onTaskUpdateProcess, this);
        if (!a.getCalendar(true) && !a.getTaskStore(true)) {
            a.taskStore = a.getTaskStore(true) || this.taskStore;
            if (!a.taskStore) {
                throw"Configuration issue: Gnt.data.taskStore instance should be provided."
            }
            if (!a.getCalendar(true) && !a.taskStore.getCalendar()) {
                throw"Configuration issue: Gnt.data.Calendar instance should be provided."
            }
        }
        this.setSuppressTaskUpdate(true);
        this.onSetTask(a);
        this.setSuppressTaskUpdate(false)
    },
    onSetTask: function (a) {
        a = a || this.task;
        this.setValue(this.getTaskValue(a))
    },
    setSuppressTaskUpdate: function (a) {
        a ? this.suppressTaskUpdate++ : this.suppressTaskUpdate--
    },
    getSuppressTaskUpdate: function () {
        return this.suppressTaskUpdate
    },
    updateReadOnly: function (a) {
        if (!this.disabled && !this.forceReadOnly) {
            if (this.editable === false) {
                if (!a.isEditable(a[this.taskField])) {
                    this.setReadOnly(true)
                } else {
                    if (this.inputEl) {
                        this.setReadOnly(false);
                        this.inputEl.dom.readOnly = true
                    }
                }
            } else {
                this.setReadOnly(!a.isEditable(a[this.taskField]))
            }
        }
    },
    onTaskUpdateProcess: function (a, d) {
        if (d !== this) {
            var c = this.getValue();
            this.updateReadOnly(a);
            this.setSuppressTaskUpdate(true);
            if (this.onTaskUpdate) {
                this.onTaskUpdate(a, d)
            } else {
                this.onSetTask(a)
            }
            this.setSuppressTaskUpdate(false);
            if (this.highlightTaskUpdates) {
                var e = this.getValue(), b = Ext.isDate(c);
                if (b && (c - e !== 0) || (!b && String(c) !== String(e))) {
                    this.highlightField()
                }
            }
        }
    },
    highlightField: function (a, b) {
        if (this.rendered && (new Date() - this.lastHighlight > 1000)) {
            this.lastHighlight = new Date();
            this.inputEl.highlight(a || this.highlightColor, b || {attr: "color"})
        }
    },
    destroyTaskListener: function () {
        if (this.task) {
            this.task.un("taskupdated", this.onTaskUpdateProcess, this)
        }
    },
    callTaskMethod: function (a, c, b) {
        a = a || this.task;
        return a && a[c].apply(a, b)
    },
    getTaskValue: function (a) {
        return this.callTaskMethod(a, this.getTaskValueMethod, Ext.Array.slice(arguments, 1))
    },
    setTaskValue: function (a) {
        return this.callTaskMethod(a, this.setTaskValueMethod, Ext.Array.slice(arguments, 1))
    },
    applyChanges: function (a) {
        a = a || this.task;
        this.setTaskValue(a, this.getValue());
        a.fireEvent("taskupdated", a, this)
    }
});
Ext.define("Gnt.field.Date", {
    extend: "Ext.form.field.Date",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    adjustMilestones: true,
    keepDuration: false,
    reAssertValue: true,
    keepTime: true,
    onExpand: function () {
        var a = this.valueToVisible(this.getValue());
        if (!this.isValid()) {
            a = this.getRawValue();
            if (a) {
                a = Ext.Date.parse(a, this.format)
            }
        }
        this.picker.setValue(Ext.isDate(a) ? a : new Date())
    },
    applyKeptTimeToValue: function (a) {
        if (this.keepTime && !Ext.Date.formatContainsHourInfo(this.format)) {
            this.applyTimeToValue(a, this.getTaskValue())
        }
        return a
    },
    applyTimeToValue: function (a, b) {
        b = b || this.getTaskValue();
        if (Ext.isDate(a) && b) {
            a.setHours(b.getHours());
            a.setMinutes(b.getMinutes())
        }
        return a
    },
    onSelect: function (c, a) {
        var d = this;
        if (Ext.Date.formatContainsHourInfo(this.format)) {
            d.applyTimeToValue(a, this.getTaskValue())
        }
        var b = d.getValue();
        var f = this.visibleToValue(a);
        var e = Ext.Date.format(a, this.format);
        if (b != f) {
            if (this.getErrors(e).length > 0) {
                d.setRawValue(e);
                d.collapse();
                d.validate()
            } else {
                d.setValue(f, true);
                d.fireEvent("select", d, f);
                d.collapse()
            }
        }
    },
    setValue: function (c, b) {
        this.callParent([c]);
        var a = this.task;
        if ((b || this.instantUpdate) && !this.getSuppressTaskUpdate() && a && a.taskStore && c) {
            this.applyChanges();
            if (this.reAssertValue) {
                var d = this.getTaskValue();
                if (d - this.getValue() !== 0) {
                    this.callParent([d])
                }
            }
            a.fireEvent("taskupdated", a, this)
        }
    },
    rawToValue: function (b) {
        if (!b) {
            return null
        }
        var a = this.applyKeptTimeToValue(this.parseDate(b));
        return this.visibleToValue(a)
    },
    valueToRaw: function (a) {
        if (!a) {
            return a
        }
        return Ext.Date.format(this.valueToVisible(a), this.format)
    },
    getValue: function () {
        return Ext.isEmpty(this.value) ? null : this.value
    },
    visibleToValue: function () {
        throw"Abstract visibleToValue method called"
    },
    valueToVisible: function () {
        throw"Abstract valueToVisible method called"
    },
    checkChange: function () {
        if (!this.suspendCheckChange) {
            var c = this, b = c.rawToValue((c.inputEl ? c.inputEl.getValue() : Ext.valueFrom(c.rawValue, ""))), a = c.lastValue;
            if (!c.isEqual(b, a) && !c.isDestroyed) {
                c.lastValue = b;
                c.fireEvent("change", c, b, a);
                c.onChange(b, a)
            }
        }
    },
    assertValue: function () {
        var c = this, d = c.rawValue, f = c.getRawValue(), a = c.getValue(), e = c.rawToValue(f), b = c.focusTask;
        if (b) {
            b.cancel()
        }
        if ((d != f) || (e - a !== 0)) {
            if (!c.validateOnBlur || c.isValid()) {
                c.setValue(e, true)
            }
        }
    },
    applyChanges: function (a) {
        a = a || this.task;
        var b = a.getTaskStore(true) || this.taskStore;
        if (this.value) {
            this.setTaskValue(a, this.value, this.keepDuration, b.skipWeekendsDuringDragDrop)
        } else {
            this.setTaskValue(a, null)
        }
    },
    beforeBlur: function () {
        this.assertValue()
    }
});
Ext.define("Gnt.field.EndDate", {
    extend: "Gnt.field.Date",
    requires: ["Sch.util.Date"],
    alias: "widget.enddatefield",
    taskField: "endDateField",
    getTaskValueMethod: "getEndDate",
    setTaskValueMethod: "setEndDate",
    validateStartDate: true,
    valueToVisible: function (b, a) {
        a = a || this.task;
        return a.getDisplayEndDate(this.format, this.adjustMilestones, b, true)
    },
    visibleToValue: function (a) {
        if (a && this.task) {
            if (!Ext.Date.formatContainsHourInfo(this.format) && a - Ext.Date.clearTime(a, true) === 0) {
                a = this.task.getCalendar().getCalendarDay(a).getAvailabilityEndFor(a) || Sch.util.Date.add(a, Sch.util.Date.DAY, 1)
            }
        } else {
            a = null
        }
        return a
    },
    getErrors: function (a) {
        var b = this.callParent(arguments);
        if (b && b.length) {
            return b
        }
        if (this.validateStartDate) {
            a = this.rawToValue(a);
            if (this.task && a) {
                if (a < this.task.getStartDate()) {
                    return [this.L("endBeforeStartText")]
                }
            }
        }
        return []
    }
});
Ext.define("Gnt.field.StartDate", {
    extend: "Gnt.field.Date",
    alias: "widget.startdatefield",
    keepDuration: true,
    taskField: "startDateField",
    getTaskValueMethod: "getStartDate",
    setTaskValueMethod: "setStartDate",
    isBaseline: false,
    valueToVisible: function (b, a) {
        a = a || this.task;
        return a.getDisplayStartDate(this.format, this.adjustMilestones, b, true, this.isBaseline)
    },
    visibleToValue: function (c) {
        var b = this.task;
        if (b && c) {
            var a = !this.lastValue || this.lastValue - Ext.Date.clearTime(this.lastValue, true) === 0;
            if (this.adjustMilestones && b.isMilestone(this.isBaseline) && c - Ext.Date.clearTime(c, true) === 0 && a) {
                c = b.getCalendar().getCalendarDay(c).getAvailabilityEndFor(c) || c
            }
        }
        return c
    }
});
Ext.define("Gnt.field.Duration", {
    extend: "Ext.form.field.Number",
    requires: ["Gnt.util.DurationParser"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.durationfield",
    alternateClassName: "Gnt.widget.DurationField",
    disableKeyFilter: true,
    allowExponential: false,
    minValue: 0,
    durationUnit: "h",
    useAbbreviation: false,
    getDurationUnitMethod: "getDurationUnit",
    setTaskValueMethod: "setDuration",
    getTaskValueMethod: "getDuration",
    taskField: "durationField",
    durationParser: null,
    durationParserConfig: null,
    constructor: function (a) {
        var b = this;
        Ext.apply(this, a);
        this.durationParser = new Gnt.util.DurationParser(Ext.apply({
            parseNumberFn: function () {
                return b.parseValue.apply(b, arguments)
            }, allowDecimals: this.decimalPrecision > 0
        }, this.durationParserConfig));
        this.callParent(arguments);
        this.invalidText = this.L("invalidText")
    },
    onSetTask: function () {
        this.durationUnit = this.task[this.getDurationUnitMethod]();
        var a = this.getTaskValueMethod ? this.getTaskValue() : this.task.get(this.task[this.taskField]);
        this.setValue(a);
        this.setSpinUpEnabled(a == null || a < this.maxValue, true);
        this.setSpinDownEnabled(a > this.minValue, true)
    },
    rawToValue: function (b) {
        var a = this.parseDuration(b);
        if (!a) {
            return null
        }
        this.durationUnit = a.unit;
        return a.value != null ? a.value : null
    },
    valueToVisible: function (c, d) {
        if (Ext.isNumber(c)) {
            var b = parseInt(c, 10), a = Ext.Number.toFixed(c, this.decimalPrecision);
            return String(b == a ? b : a).replace(".", this.decimalSeparator) + " " + Sch.util.Date[this.useAbbreviation ? "getShortNameOfUnit" : "getReadableNameOfUnit"](d || this.durationUnit, c !== 1)
        }
        return ""
    },
    valueToRaw: function (a) {
        return this.valueToVisible(a, this.durationUnit, this.decimalPrecision, this.useAbbreviation)
    },
    parseDuration: function (a) {
        if (a == null) {
            return null
        }
        var b = this.durationParser.parse(a);
        if (!b) {
            return null
        }
        b.unit = b.unit || this.durationUnit;
        return b
    },
    getDurationValue: function () {
        return this.parseDuration(this.getRawValue())
    },
    getErrors: function (b) {
        var a;
        if (b) {
            a = this.parseDuration(b);
            if (!a) {
                return [this.L("invalidText")]
            }
            b = a.value
        }
        return this.callParent(arguments)
    },
    checkChange: function () {
        if (!this.suspendCheckChange) {
            var d = this, c = d.getDurationValue(), a = d.lastValue;
            var b = c && !a || !c && a || c && a && (c.value != a.value || c.unit != a.unit);
            if (b && !d.isDestroyed) {
                d.lastValue = c;
                d.fireEvent("change", d, c, a);
                d.onChange(c, a)
            }
        }
    },
    getValue: function () {
        return this.value
    },
    applyChanges: function (a) {
        a = a || this.task;
        this.setTaskValue(a, this.getValue(), this.durationUnit);
        a.fireEvent("taskupdated", a, this)
    },
    setValue: function (b, a) {
        var c = b;
        if (Ext.isObject(b)) {
            this.durationUnit = b.unit;
            c = b.value
        }
        this.callParent([c]);
        if ((a || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges()
        }
    },
    assertValue: function () {
        var d = this, a = d.getValue(), e = d.durationUnit, c = d.getDurationValue();
        if (this.isValid()) {
            var b = !c && a || c && (c.value != a || c.unit != e);
            if (b) {
                d.setValue(c, true)
            }
        }
    },
    beforeBlur: function () {
        this.assertValue()
    },
    onSpinUp: function () {
        var a = this;
        if (!a.readOnly) {
            var b = a.getValue() || 0;
            a.setSpinValue(Ext.Number.constrain(b + a.step, a.minValue, a.maxValue))
        }
    },
    onSpinDown: function () {
        var a = this;
        if (!a.readOnly) {
            var b = a.getValue() || 0;
            a.setSpinValue(Ext.Number.constrain(b - a.step, a.minValue, a.maxValue))
        }
    }
});
Ext.define("Gnt.field.Effort", {
    extend: "Gnt.field.Duration",
    requires: ["Gnt.util.DurationParser"],
    alias: "widget.effortfield",
    alternateClassName: "Gnt.widget.EffortField",
    mixins: ["Gnt.mixin.Localizable"],
    taskField: "effortField",
    getDurationUnitMethod: "getEffortUnit",
    setTaskValueMethod: "setEffort",
    getTaskValueMethod: "getEffort",
    applyChanges: function (a) {
        a = a || this.task;
        this.setTaskValue(a, this.getValue() || null, this.durationUnit);
        a.fireEvent("taskupdated", a, this)
    }
});
Ext.define("Gnt.field.ManuallyScheduled", {
    extend: "Ext.form.field.Checkbox",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.manuallyscheduledfield",
    alternateClassName: ["Gnt.widget.ManuallyScheduledField"],
    taskField: "manuallyScheduledField",
    setTaskValueMethod: "setManuallyScheduled",
    getTaskValueMethod: "isManuallyScheduled",
    valueToVisible: function (a) {
        return a ? this.L("yes") : this.L("no")
    },
    getValue: function () {
        return this.value
    },
    setValue: function (a) {
        this.callParent([a]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges()
        }
    }
});
Ext.define("Gnt.field.ReadOnly", {
    extend: "Ext.form.field.Checkbox",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.readonlyfield",
    alternateClassName: ["Gnt.widget.ReadOnlyField"],
    taskField: "readOnlyField",
    setTaskValueMethod: "setReadOnly",
    getTaskValueMethod: "isReadOnly",
    instantUpdate: true,
    valueToVisible: function (a) {
        return a ? this.L("yes") : this.L("no")
    },
    getValue: function () {
        return this.value
    },
    setValue: function (a) {
        this.callParent([a]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges()
        }
    }
});
Ext.define("Gnt.field.SchedulingMode", {
    extend: "Ext.form.field.ComboBox",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.schedulingmodefield",
    alternateClassName: "Gnt.widget.SchedulingmodeField",
    taskField: "schedulingModeField",
    setTaskValueMethod: "setSchedulingMode",
    getTaskValueMethod: "getSchedulingMode",
    pickerAlign: "tl-bl?",
    matchFieldWidth: true,
    editable: false,
    forceSelection: true,
    triggerAction: "all",
    constructor: function (a) {
        a = a || {};
        if (!a.store) {
            this.initStore(a)
        }
        this.callParent([a]);
        this.on("change", this.onFieldChange, this)
    },
    initStore: function (a) {
        var b = this;
        a.store = b.getDefaultSchedulingModes()
    },
    getDefaultSchedulingModes: function () {
        var a = this;
        return [["Normal", a.L("Normal")], ["FixedDuration", a.L("FixedDuration")], ["EffortDriven", a.L("EffortDriven")], ["DynamicAssignment", a.L("DynamicAssignment")]]
    },
    valueToVisible: function (e, b) {
        var c = this, d = [];
        var a = this.findRecordByValue(e);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText)) {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    getValue: function () {
        return this.value
    },
    onFieldChange: function (a) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task && this.value) {
            this.applyChanges()
        }
    }
});
Ext.define("Gnt.field.Calendar", {
    extend: "Ext.form.field.ComboBox",
    requires: ["Ext.data.Store", "Gnt.model.Calendar", "Gnt.data.Calendar"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.calendarfield",
    alternateClassName: "Gnt.widget.CalendarField",
    taskField: "calendarIdField",
    getTaskValueMethod: "getCalendarId",
    setTaskValueMethod: "setCalendarId",
    pickerAlign: "tl-bl?",
    matchFieldWidth: true,
    editable: true,
    triggerAction: "all",
    valueField: "Id",
    displayField: "Name",
    queryMode: "local",
    forceSelection: true,
    allowBlank: true,
    initComponent: function () {
        var b = this, a = b.getInitialConfig();
        if (!a.store || b.store.isEmptyStore) {
            b.store = {xclass: "Ext.data.Store", model: "Gnt.model.Calendar"}
        }
        if (!(b.store instanceof Ext.data.Store)) {
            b.store = Ext.create(b.store)
        }
        b.callParent(arguments);
        b.updateCalendarsStore();
        b.mon(Ext.data.StoreManager, {
            add: function (d, c, e) {
                if (c instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore()
                }
            }, remove: function (d, c, e) {
                if (c instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore()
                }
            }, scope: b
        });
        b.on({show: b.setReadOnlyIfEmpty, scope: b});
        b.on("change", b.onFieldChange, b)
    },
    updateCalendarsStore: function () {
        this.store.loadData(this.getCalendarData())
    },
    setReadOnlyIfEmpty: function () {
        if (!this.store.count()) {
            this.setReadOnly(true)
        }
    },
    getCalendarData: function () {
        return Ext.Array.map(Gnt.data.Calendar.getAllCalendars(), function (a) {
            return {Id: a.calendarId, Name: a.name || a.calendarId}
        })
    },
    onSetTask: function () {
        this.setReadOnlyIfEmpty();
        this.setValue(this.getTaskValue())
    },
    valueToVisible: function (e, b) {
        var c = this, d = [];
        var a = this.findRecordByValue(e);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText) && typeof c.valueNotFoundText == "string") {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    getValue: function () {
        return this.value || ""
    },
    getErrors: function (b) {
        if (b) {
            var a = this.findRecordByDisplay(b);
            if (a) {
                if (this.task && !this.task.isCalendarApplicable(a.getId())) {
                    return [this.L("calendarNotApplicable")]
                }
            }
        }
        return this.callParent(arguments)
    },
    onFieldChange: function (b, a) {
        this.setValue(a)
    },
    setValue: function (a) {
        this.callParent([a]);
        if (undefined === a || null === a || "" === a) {
            this.value = ""
        }
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.getTaskValue() != this.value) {
                this.applyChanges()
            }
        }
    },
    assertValue: function () {
        var a = this.getRawValue();
        if (!a && this.value) {
            this.setValue("")
        } else {
            this.callParent(arguments)
        }
    }
});
Ext.define("Gnt.field.Percent", {
    extend: "Ext.form.field.Number",
    alias: "widget.percentfield",
    mixins: ["Gnt.mixin.Localizable"],
    alternateClassName: "Gnt.widget.PercentField",
    disableKeyFilter: false,
    minValue: 0,
    maxValue: 100,
    allowExponential: false,
    baseChars: "0123456789%",
    constructor: function () {
        this.callParent(arguments);
        this.invalidText = this.L("invalidText")
    },
    valueToRaw: function (a) {
        if (Ext.isNumber(a)) {
            return parseFloat(Ext.Number.toFixed(a, this.decimalPrecision)) + "%"
        }
        return ""
    },
    getErrors: function (b) {
        var a = this.parseValue(b);
        if (a === null) {
            if (b !== null && b !== "") {
                return [this.invalidText]
            } else {
                a = ""
            }
        }
        return this.callParent([a])
    }
});
Ext.define("Gnt.field.Dependency", {
    extend: "Ext.form.field.Text",
    alternateClassName: "Gnt.widget.DependencyField",
    alias: "widget.dependencyfield",
    requires: ["Gnt.util.DependencyParser"],
    mixins: ["Gnt.mixin.Localizable"],
    type: "predecessors",
    separator: ";",
    task: null,
    dependencyParser: null,
    dependencyParserConfig: null,
    useSequenceNumber: false,
    constructor: function (a) {
        var b = this;
        Ext.apply(this, a);
        this.dependencyParser = new Gnt.util.DependencyParser(Ext.apply({
            parseNumberFn: function () {
                return Gnt.widget.DurationField.prototype.parseValue.apply(b, arguments)
            }
        }, this.dependencyParserConfig));
        this.callParent(arguments);
        this.addCls("gnt-field-dependency")
    },
    isPredecessor: function () {
        return this.type === "predecessors"
    },
    setTask: function (a) {
        this.task = a;
        this.setRawValue(this.getFieldDisplayValue(a))
    },
    getDependencies: function () {
        return this.dependencyParser.parse(this.getRawValue())
    },
    getTaskIdFromDependency: function (c) {
        var b = this.task.getTaskStore(), d = c.taskId, a;
        if (this.useSequenceNumber) {
            a = b.getBySequenceNumber(d);
            d = a && a.getId()
        }
        return d
    },
    getErrors: function (n) {
        if (!n) {
            return []
        }
        var e = this.dependencyParser.parse(n);
        if (!e) {
            return [this.L("invalidFormatText")]
        }
        var g = this.getDependencies(), m = this.isPredecessor(), s = this.task, u = s.getTaskStore().dependencyStore, l = s[m ? "predecessors" : "successors"], h = this.dependencyParser.types, d = u.allowedDependencyTypes, f = u.model.Type, a;
        var t = [];
        for (var r = 0; r < g.length; r++) {
            var p = g[r];
            a = this.getTaskIdFromDependency(p);
            if (!a) {
                return [this.L("invalidDependencyText")]
            }
            if (u.allowedDependencyTypes && !u.isValidDependencyType(p.type)) {
                var b = "";
                for (var q = 0, o = d.length; q < o; q++) {
                    b += h[f[d[q]]] + ","
                }
                return [Ext.String.format(this.L("invalidDependencyType"), h[p.type], b.substring(0, b.length - 1))]
            }
            var c = new u.model();
            c.setSourceId(m ? a : s.getId());
            c.setTargetId(m ? s.getId() : a);
            c.setType(p.type);
            c.setLag(p.lag);
            c.setLagUnit(p.lagUnit);
            t.push(c)
        }
        for (r = 0; r < t.length; r++) {
            if (!u.isValidDependency(t[r], t, l)) {
                return [this.invalidDependencyText]
            }
        }
        return this.callParent([e.value])
    },
    getFieldDisplayValue: function (b) {
        var j = this.isPredecessor(), a = b.getTaskStore().getDependencyStore(), m = j ? b.getIncomingDependencies(true) : b.getOutgoingDependencies(true), k = this.dependencyParser.types, f = Gnt.model.Dependency.Type.EndToStart, l = [], n;
        for (var e = 0; e < m.length; e++) {
            var h = m[e];
            n = j ? h.getSourceTask() : h.getTargetTask();
            if (n && h.isValid(false)) {
                var g = h.getType(), c = h.getLag(), d = h.getLagUnit();
                l.push(Ext.String.format("{0}{1}{2}{3}{4}", this.useSequenceNumber ? n.getSequenceNumber() : n.getId(), c || g !== f ? k[g] : "", c > 0 ? "+" : "", c || "", c && d !== "d" ? d : ""))
            }
        }
        return l.join(this.separator)
    },
    isDirty: function (c) {
        c = c || this.task;
        if (!c) {
            return false
        }
        var a = this.isPredecessor(), d = c.getTaskStore().dependencyStore, h = a ? c.getIncomingDependencies() : c.getOutgoingDependencies(), f = c.getId();
        for (var e = 0, b = h.length; e < b; e++) {
            if (h[e].dirty || h[e].phantom) {
                return true
            }
        }
        if (d) {
            var g = a ? "getTargetId" : "getSourceId";
            h = d.getRemovedRecords();
            for (e = 0, b = h.length; e < b; e++) {
                if (h[e][g]() == f) {
                    return true
                }
            }
        }
        return false
    },
    applyChanges: function (d) {
        d = d || this.task;
        var l = d.getTaskStore().dependencyStore, g = this.getDependencies(), j = this.isPredecessor(), k = j ? d.getIncomingDependencies(true) : d.getOutgoingDependencies(true), c = [], f;
        var a = Ext.Array.map(g, function (i) {
            return this.getTaskIdFromDependency(i)
        }, this);
        for (f = 0; f < k.length; f++) {
            if (!Ext.Array.contains(a, k[f][j ? "getSourceId" : "getTargetId"]())) {
                c.push(k[f])
            }
        }
        if (c.length > 0) {
            l.remove(c)
        }
        var m = [];
        for (f = 0; f < g.length; f++) {
            var e = g[f];
            var b = this.getTaskIdFromDependency(e);
            var h = l.getByTaskIds(b, d.getId());
            if (h) {
                h.beginEdit();
                h.setType(e.type);
                h.setLag(e.lag);
                h.setLagUnit(e.lagUnit);
                h.endEdit()
            } else {
                h = new l.model();
                h.setSourceId(j ? b : d.getId());
                h.setTargetId(j ? d.getId() : b);
                h.setType(e.type);
                h.setLag(e.lag);
                h.setLagUnit(e.lagUnit);
                m.push(h)
            }
        }
        if (m.length > 0) {
            l.add(m)
        }
        if (m.length || c.length) {
            d.triggerUIUpdate()
        }
    }
});
Ext.define("Gnt.field.Milestone", {
    extend: "Ext.form.field.ComboBox",
    requires: "Ext.data.JsonStore",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    alias: "widget.milestonefield",
    instantUpdate: false,
    allowBlank: false,
    forceSelection: true,
    displayField: "text",
    valueField: "value",
    queryMode: "local",
    constructor: function (a) {
        Ext.apply(this, a);
        this.store = new Ext.data.JsonStore({
            fields: ["value", "text"],
            data: [{value: 0, text: this.L("no")}, {value: 1, text: this.L("yes")}]
        });
        this.callParent(arguments);
        this.on("change", this.onFieldChange, this)
    },
    onSetTask: function () {
        this.setValue(this.task.isMilestone() ? 1 : 0)
    },
    valueToVisible: function (a) {
        return a ? this.L("yes") : this.L("no")
    },
    onFieldChange: function (a) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.task.isMilestone() != Boolean(this.value)) {
                this.applyChanges()
            }
        }
    },
    getValue: function () {
        return this.value
    },
    applyChanges: function (a) {
        a = a || this.task;
        if (this.getValue()) {
            a.convertToMilestone()
        } else {
            a.convertToRegular()
        }
        a.fireEvent("taskupdated", a, this)
    }
});
Ext.define("Gnt.field.ConstraintType", {
    extend: "Ext.form.field.ComboBox",
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    uses: ["Gnt.constraint.Base"],
    alias: "widget.constrainttypefield",
    alternateClassName: "Gnt.widget.ConstraintType.Field",
    taskField: "constraintTypeField",
    getTaskValueMethod: "getConstraintType",
    setTaskValueMethod: "setConstraint",
    pickerAlign: "tl-bl?",
    matchFieldWidth: false,
    editable: false,
    forceSelection: true,
    triggerAction: "all",
    initComponent: function () {
        var a = this;
        a.store = a.store || Gnt.field.ConstraintType.buildDefaultConstraintTypeList(a.L("none"));
        a.callParent(arguments);
        this.on("change", this.onFieldChange, this)
    },
    valueToVisible: function (e, b) {
        var c = this, d = [];
        var a = this.findRecordByValue(!Ext.isEmpty(e) ? e : null);
        if (a) {
            d.push(a.data)
        } else {
            if (Ext.isDefined(c.valueNotFoundText)) {
                d.push(c.valueNotFoundText)
            }
        }
        return c.displayTpl.apply(d)
    },
    applyChanges: function (a) {
        var c = this, d = c.getValue(), b;
        a = a || c.task;
        b = Gnt.constraint.Base.getConstraintClass(d);
        c.setTaskValue(a, d, b && b.getInitialConstraintDate(a) || null);
        a.fireEvent("taskupdated", a, c)
    },
    onFieldChange: function (b) {
        var a = this;
        if (!a.getSuppressTaskUpdate() && a.task && b) {
            a.applyChanges()
        }
    },
    statics: {
        buildDefaultConstraintTypeList: function (b) {
            var a = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression("gntconstraint.*"), function (c) {
                var e = Ext.ClassManager.get(c), d = e.alias[0], f = d.split(".").pop();
                e && (a.push([f, e.L("name")]))
            });
            a = Ext.Array.sort(a, function (d, c) {
                return d[1] > c[1] ? 1 : -1
            });
            b && a.unshift([null, b]);
            return a
        }
    }
});
Ext.define("Gnt.field.ConstraintDate", {
    extend: "Gnt.field.Date",
    alias: "widget.constraintdatefield",
    taskField: "constraintDateField",
    getTaskValueMethod: "getConstraintDate",
    setTaskValueMethod: "setConstraintDate",
    reAssertValue: false,
    valueToVisible: function (d, a) {
        a = a || this.task;
        var c = this, b = a && a.getConstraintClass(), e = c.format || Ext.Date.defaultFormat;
        if (b) {
            return b.getDisplayableConstraintDateForFormat(d, e, a)
        } else {
            return d
        }
    },
    visibleToValue: function (d) {
        var c = this, e = c.format || Ext.Date.defaultFormat, a = c.task, b = a && a.getConstraintClass();
        if (b && !Ext.isEmpty(d)) {
            d = b.adjustConstraintDateFromDisplayableWithFormat(d, e, a)
        }
        return d
    }
});
Ext.define("Gnt.field.BaselineStartDate", {
    extend: "Gnt.field.StartDate",
    alias: "widget.baselinestartdatefield",
    taskField: "baselineStartDateField",
    getTaskValueMethod: "getBaselineStartDate",
    setTaskValueMethod: "setBaselineStartDate",
    isBaseline: true,
    applyChanges: function (a, b) {
        a = a || this.task;
        this.setTaskValue(a, this.value);
        if (!b) {
            a.fireEvent("taskupdated", a, this)
        }
    }
});
Ext.define("Gnt.field.BaselineEndDate", {
    extend: "Gnt.field.EndDate",
    alias: "widget.baselineenddatefield",
    taskField: "baselineEndDateField",
    getTaskValueMethod: "getBaselineEndDate",
    setTaskValueMethod: "setBaselineEndDate",
    applyChanges: function (a, b) {
        a = a || this.task;
        this.setTaskValue(a, this.value || null);
        if (!b) {
            a.fireEvent("taskupdated", a, this)
        }
    }
});
Ext.define("Gnt.column.ResourceName", {
    extend: "Ext.grid.column.Column",
    alias: "widget.resourcenamecolumn",
    mixins: ["Gnt.mixin.Localizable"],
    dataIndex: "ResourceName",
    flex: 1,
    align: "left",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        Ext.apply(this, a);
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.AssignmentUnits", {
    extend: "Ext.grid.column.Number",
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.assignmentunitscolumn",
    dataIndex: "Units",
    format: "0 %",
    align: "left",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.scope = this;
        this.callParent(arguments)
    },
    renderer: function (b, c, a) {
        if (b) {
            return Ext.util.Format.number(b, this.format)
        }
    }
});
Ext.define("Gnt.widget.AssignmentGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.assignmentgrid",
    requires: ["Gnt.model.AssignmentEditing", "Gnt.column.ResourceName", "Gnt.column.AssignmentUnits", "Ext.grid.plugin.CellEditing"],
    assignmentStore: null,
    resourceStore: null,
    readOnly: false,
    cls: "gnt-assignmentgrid",
    defaultAssignedUnits: 100,
    taskId: null,
    cellEditing: null,
    assignmentUnitsEditor: null,
    bufferedRenderer: false,
    sorter: {
        sorterFn: function (b, a) {
            var d = b.getUnits(), c = a.getUnits();
            if ((!d && !c) || (d && c)) {
                return b.get("ResourceName") < a.get("ResourceName") ? -1 : 1
            }
            return d ? -1 : 1
        }
    },
    constructor: function (a) {
        var b = this;
        this.store = Ext.create("Ext.data.JsonStore", {model: "Gnt.model.AssignmentEditing"});
        this.columns = this.buildColumns();
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        Ext.applyIf(this, {selModel: {selType: "checkboxmodel", mode: "MULTI", checkOnly: true}});
        this.callParent(arguments)
    },
    initComponent: function () {
        this.loadResources();
        this.mon(this.resourceStore, {datachanged: this.loadResources, scope: this});
        this.callParent(arguments);
        this.getSelectionModel().on({select: this.onSelect, deselect: this.onDeselect, scope: this})
    },
    onSelect: function (b, a) {
        if ((!this.cellEditing || !this.cellEditing.getActiveEditor()) && !a.getUnits()) {
            a.setUnits(this.defaultAssignedUnits)
        }
    },
    onDeselect: function (b, a) {
        a.setUnits(0)
    },
    loadResources: function () {
        var e = [], b = this.resourceStore;
        for (var c = 0, a = b.getCount(); c < a; c++) {
            var d = b.getAt(c);
            e.push({ResourceId: d.getId(), ResourceName: d.getName(), Units: ""})
        }
        this.store.loadData(e)
    },
    buildPlugins: function () {
        var a = this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {clicksToEdit: 1});
        a.on("edit", this.onEditingDone, this);
        return [a]
    },
    hide: function () {
        this.cellEditing.cancelEdit();
        this.callParent(arguments)
    },
    onEditingDone: function (a, b) {
        if (b.value) {
            this.getSelectionModel().select(b.record, true)
        } else {
            this.getSelectionModel().deselect(b.record);
            b.record.reject()
        }
    },
    buildColumns: function () {
        return [{xtype: "resourcenamecolumn"}, {
            xtype: "assignmentunitscolumn",
            assignmentStore: this.assignmentStore,
            editor: {xtype: "numberfield", minValue: 0, step: 10, selectOnFocus: true}
        }]
    },
    setEditableFields: function (c) {
        if (!this.assignmentUnitsEditor) {
            this.assignmentUnitsEditor = this.down("assignmentunitscolumn").getEditor()
        }
        var b = this.assignmentStore && this.assignmentStore.getTaskStore(), a = b && b.getModelById(c);
        if (a) {
            switch (a.getSchedulingMode()) {
                case"DynamicAssignment":
                    this.assignmentUnitsEditor.setReadOnly(true);
                    break;
                default:
                    this.assignmentUnitsEditor.setReadOnly(false)
            }
        }
    },
    loadTaskAssignments: function (e) {
        var c = this.store, g = this.getSelectionModel();
        this.taskId = e;
        g.deselectAll(true);
        for (var d = 0, b = c.getCount(); d < b; d++) {
            var a = c.getAt(d);
            /*a.data.Units = 0;*/
            a.setUnits(0);
            a.data.Id = null;
            delete a.__id__
        }
        var f = this.assignmentStore.queryBy(function (h) {
            return h.getTaskId() == e
        });
        f.each(function (i) {
            var h = c.findRecord("ResourceId", i.getResourceId(), 0, false, true, true);
            if (h) {
                h.setUnits(i.getUnits());
                h.__id__ = i.getId();
                g.select(h, true, true)
            }
        });
        if (Ext.isSafari) {
            this.focus()
        }
        c.sort(this.sorter);
        c.getSorters().removeAll();
        this.setEditableFields(e)
    },
    saveTaskAssignments: function () {
        var a = this.assignmentStore, e = this.taskId;
        var d = {};
        var c = [];
        this.getSelectionModel().selected.each(function (g) {
            var f = g.getUnits();
            if (f > 0) {
                var i = g.__id__;
                if (i) {
                    d[i] = true;
                    a.getModelById(i).setUnits(f)
                } else {
                    var h = Ext.create(a.model);
                    h.setTaskId(e);
                    h.setResourceId(g.getResourceId());
                    h.setUnits(f);
                    d[h.internalId] = true;
                    c.push(h)
                }
            }
        });
        var b = [];
        a.each(function (f) {
            if (f.getTaskId() == e && !d[f.getId() || f.internalId]) {
                b.push(f)
            }
        });
        a.fireEvent("beforetaskassignmentschange", a, e, c);
        a.suspendAutoSync();
        a.remove(b);
        a.add(c);
        a.resumeAutoSync();
        a.fireEvent("taskassignmentschanged", a, e, c);
        if (a.autoSync) {
            a.sync()
        }
    },
    isDataChanged: function () {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function () {
        var a = true;
        this.store.each(function (b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    }
});
Ext.define("Gnt.field.Assignment", {
    extend: "Ext.form.field.Picker",
    alias: ["widget.assignmentfield", "widget.assignmenteditor"],
    alternateClassName: "Gnt.widget.AssignmentField",
    requires: ["Gnt.widget.AssignmentGrid"],
    mixins: ["Gnt.mixin.Localizable"],
    matchFieldWidth: false,
    editable: false,
    task: null,
    assignmentStore: null,
    resourceStore: null,
    gridConfig: null,
    formatString: "{0} [{1}%]",
    expandPickerOnFocus: false,
    afterRender: function () {
        this.callParent(arguments);
        this.on("expand", this.onPickerExpand, this);
        if (this.expandPickerOnFocus) {
            this.on("focus", function () {
                this.expand()
            }, this, {delay: 1})
        }
    },
    createPicker: function () {
        var a = new Gnt.widget.AssignmentGrid(Ext.apply({
            frame: true,
            floating: true,
            height: 200,
            width: 300,
            resourceStore: this.task.getResourceStore(),
            assignmentStore: this.task.getAssignmentStore(),
            fbar: this.buildButtons()
        }, this.gridConfig || {}));
        return a
    },
    buildButtons: function () {
        return ["->", {
            text: this.L("closeText"), handler: function () {
                Ext.Function.defer(this.onSaveClick, Ext.isIE && !Ext.isIE9 ? 60 : 30, this)
            }, scope: this
        }, {
            text: this.L("cancelText"), handler: function () {
                this.collapse()
            }, scope: this
        }]
    },
    setTask: function (a) {
        this.task = a;
        this.setRawValue(this.getFieldDisplayValue(a))
    },
    onPickerExpand: function () {
        this.picker.loadTaskAssignments(this.task.getId())
    },
    onSaveClick: function () {
        var b = this.picker.getSelectionModel(), a = b.selected;
        this.collapse();
        this.fireEvent("select", this, a);
        this.picker.saveTaskAssignments()
    },
    isDirty: function (c) {
        c = c || this.task;
        if (!c) {
            return false
        }
        var e = this.picker && this.picker.assignmentStore || c.getAssignmentStore(), b = c.getAssignments();
        for (var d = 0, a = b.length; d < a; d++) {
            if (b[d].dirty || b[d].phantom) {
                return true
            }
        }
        if (e) {
            b = e.getRemovedRecords();
            for (d = 0, a = b.length; d < a; d++) {
                if (b[d].getTaskId() == c.getId()) {
                    return true
                }
            }
        }
        return false
    },
    getFieldDisplayValue: function (c) {
        c = c || this.task;
        var e = [], b = c.getAssignments();
        for (var d = 0, a = b.length; d < a; d++) {
            var f = b[d];
            if (f.getUnits() > 0) {
                e.push(Ext.String.format(this.formatString, f.getResourceName(), f.getUnits()))
            }
        }
        return e.join(", ")
    }
});
Ext.define("Gnt.field.Note", {
    extend: "Ext.form.field.Picker",
    alias: ["widget.notefield", "widget.noteeditor"],
    alternateClassName: "Gnt.widget.NoteField",
    requires: ["Ext.form.field.HtmlEditor"],
    mixins: ["Gnt.field.mixin.TaskField", "Gnt.mixin.Localizable"],
    matchFieldWidth: false,
    editable: false,
    pickerConfig: null,
    previewFn: null,
    previewFnScope: null,
    taskField: "noteField",
    getTaskValueMethod: "getNote",
    setTaskValueMethod: "setNote",
    afterRender: function () {
        this.callParent(arguments);
        this.on("collapse", this.onPickerCollapse, this)
    },
    valueToVisible: function (a) {
        if (this.previewFn) {
            return this.previewFn.call(this.previewFnScope || this, a)
        } else {
            return Ext.util.Format.stripTags(a)
        }
    },
    createPicker: function () {
        var a = new Ext.form.field.HtmlEditor(Ext.apply({
            frame: true,
            shadow: false,
            floating: true,
            height: 200,
            width: 300,
            listeners: {change: this.onPickerChange, initialize: this.onPickerInit, scope: this}
        }, this.pickerConfig || {}));
        return a
    },
    onPickerInit: function (a) {
        a.win.focus = Ext.emptyFn
    },
    onPickerChange: function (a, b) {
        this.setRawValue(this.valueToVisible(b))
    },
    getValue: function () {
        return this.getPicker().getValue()
    },
    setValue: function (a) {
        this.callParent([this.valueToVisible(a)]);
        this.getPicker().setValue(a);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges()
        }
    },
    onPickerCollapse: function () {
        this.setValue(this.getPicker().getValue())
    },
    onTriggerClick: function () {
        var a = this;
        if (!a.readOnly && !a.disabled) {
            if (a.isExpanded) {
                a.collapse()
            } else {
                a.expand()
            }
        }
    }
});
Ext.define("Gnt.column.ResourceAssignment", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.resourceassignmentcolumn", "widget.ganttcolumn.resourceassignment"],
    requires: ["Gnt.field.Assignment"],
    mixins: ["Gnt.mixin.Localizable"],
    tdCls: "sch-assignment-cell",
    showUnits: true,
    field: null,
    dirtyCls: null,
    constructor: function (b) {
        b = b || {};
        this.text = b.text || this.L("text");
        var c = b.editor;
        var a = b.showUnits || this.showUnits;
        delete b.editor;
        b.editor = c || {};
        if (!(b.editor instanceof Ext.form.Field)) {
            b.editor = Ext.ComponentManager.create(Ext.applyIf(b.editor, {
                expandPickerOnFocus: true,
                formatString: "{0}" + (a ? " [{1}%]" : "")
            }), "assignmentfield")
        }
        b.field = b.editor;
        this.callParent([b]);
        this.scope = this;
        if (this.field) {
            this.field.on("collapse", function () {
                this.up("ganttpanel").ganttEditingPlugin.completeEdit()
            }, this)
        }
    },
    afterRender: function () {
        var a = this.up("treepanel").getView();
        if (a.markDirty) {
            this.dirtyCls = a.dirtyCls
        }
        this.callParent(arguments)
    },
    renderer: function (b, c, a) {
        if (this.dirtyCls && this.field.isDirty(a)) {
            c.tdCls = this.dirtyCls
        }
        return this.field.getFieldDisplayValue(a)
    }
});
Ext.define("Gnt.column.mixin.TaskFieldColumn", {
    extend: "Ext.Mixin",
    requires: ["Gnt.patches.TreeColumn"],
    mixins: ["Gnt.mixin.Localizable"],
    instantUpdate: false,
    field: null,
    fieldProperty: "",
    fieldConfigs: "instantUpdate",
    defaultEditorXType: "",
    mixinConfig: {after: {initComponent: "afterInitComponent"}, afterIf: {applyColumnCls: "applyColumnCls"}},
    initTaskFieldColumn: function (a) {
        this.text = this.config.text || this.L("text");
        if (this.defaultEditorXType) {
            this.initColumnEditor(a)
        }
        this.scope = this.scope || this;
        this.renderer = this.renderer || this.taskFieldRenderer;
        this.mon(this, "render", this.onColumnRender, this)
    },
    applyColumnCls: function (b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
    },
    afterInitComponent: function () {
        this.hasCustomRenderer = true
    },
    initColumnEditor: function (a) {
        a = Ext.copyTo(a || {}, this, this.fieldConfigs, true);
        if (!(this.editor instanceof Ext.ClassManager.getByAlias("widget." + this.defaultEditorXType))) {
            this.editor = Ext.ComponentManager.create(Ext.applyIf(this.editor || {}, a), this.defaultEditorXType)
        }
        this.field = this.editor
    },
    onColumnRender: function () {
        var a = this.up("treepanel");
        var b = a.store;
        if (!this.dataIndex) {
            this.dataIndex = b.model.prototype[this.fieldProperty]
        }
    },
    getValueToRender: function (b, d, a) {
        var c = this.field;
        return c && c.valueToVisible(b, a) || b
    },
    taskFieldRenderer: function (c, d, b) {
        var a = Ext.util.Format.htmlEncode(this.getValueToRender.apply(this, arguments));
        this.applyColumnCls(c, d, b);
        return a
    },
    afterClassMixedIn: function (b) {
        var c = this.prototype, a = c.mixinConfig, e = a && a.beforeIf, d = a && a.afterIf;
        e && Ext.Object.each(e, function (f, g) {
            if (f in b.prototype) {
                b.addMember(f, function () {
                    if (c[g].apply(this, arguments) !== false) {
                        return this.callParent(arguments)
                    }
                })
            } else {
                b.addMember(f, function () {
                    c[g].apply(this, arguments)
                })
            }
        });
        d && Ext.Object.each(d, function (f, g) {
            if (f in b.prototype) {
                b.addMember(f, function () {
                    this.callParent(arguments);
                    c[g].apply(this, arguments)
                })
            } else {
                b.addMember(f, function () {
                    c[g].apply(this, arguments)
                })
            }
        })
    }
});
Ext.define("Gnt.column.Name", {
    extend: "Ext.tree.Column",
    alias: ["widget.namecolumn", "widget.ganttcolumn.name"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    draggable: true,
    fieldProperty: "nameField",
    defaultEditorXType: "textfield",
    initComponent: function () {
        this.initTaskFieldColumn({allowBlank: false});
        this.callParent(arguments)
    },
    applyColumnCls: function (b, c, a) {
        c.tdCls = (c.tdCls || "");
        if (a.isProject) {
            c.tdCls += " sch-gantt-project-name"
        }
        if (!a.isLeaf()) {
            c.tdCls += " sch-gantt-parent-cell"
        }
    },
    getValueToRender: function (a) {
        return a
    }
});
Ext.define("Gnt.column.Note", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.Note"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    alias: ["widget.notecolumn", "widget.ganttcolumn.note"],
    defaultEditorXType: "notefield",
    fieldProperty: "noteField",
    previewFn: null,
    previewFnScope: null,
    fieldConfigs: ["instantUpdate", "previewFn", "previewFnScope"],
    initComponent: function () {
        this.initTaskFieldColumn();
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.EndDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.enddatecolumn", "widget.ganttcolumn.enddate"],
    requires: ["Ext.grid.CellEditor", "Gnt.field.EndDate"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 100,
    align: "left",
    editorFormat: null,
    adjustMilestones: true,
    validateStartDate: true,
    keepDuration: false,
    fieldProperty: "endDateField",
    fieldConfigs: ["instantUpdate", "adjustMilestones", "keepDuration", "validateStartDate"],
    defaultEditorXType: "enddatefield",
    initComponent: function () {
        this.initTaskFieldColumn({format: this.editorFormat || this.format || Ext.Date.defaultFormat});
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return b && Ext.Date.format(this.field.valueToVisible(b, a), this.format) || ""
    }
});
Ext.define("Gnt.column.PercentDone", {
    extend: "Ext.grid.column.Number",
    alias: ["widget.percentdonecolumn", "widget.ganttcolumn.percentdone"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 50,
    format: "0",
    align: "center",
    editor: {xtype: "percentfield", decimalPrecision: 0, minValue: 0, maxValue: 100},
    fieldProperty: "percentDoneField",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.scope = this
    },
    afterRender: function () {
        var a = this.up("treepanel");
        if (!this.dataIndex) {
            this.dataIndex = a.store.model.prototype[this.fieldProperty]
        }
        this.callParent(arguments)
    },
    renderer: function (b, c, a) {
        if (!a.isEditable(this.dataIndex)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        }
        return this.defaultRenderer(b, c, a)
    }
});
Ext.define("Gnt.column.StartDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.startdatecolumn", "widget.ganttcolumn.startdate"],
    requires: ["Gnt.field.StartDate"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 100,
    align: "left",
    editorFormat: null,
    adjustMilestones: true,
    keepDuration: true,
    fieldProperty: "startDateField",
    fieldConfigs: ["instantUpdate", "adjustMilestones", "keepDuration"],
    defaultEditorXType: "startdatefield",
    initComponent: function () {
        this.initTaskFieldColumn({format: this.editorFormat || this.format || Ext.Date.defaultFormat});
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return b && Ext.Date.format(this.field.valueToVisible(b, a), this.format) || ""
    }
});
Ext.define("Gnt.column.WBS", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.wbscolumn", "widget.ganttcolumn.wbs"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 40,
    align: "left",
    sortable: false,
    dataIndex: "index",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    },
    renderer: function (b, c, a) {
        return a.getWBSCode()
    }
});
Ext.define("Gnt.column.Sequence", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.sequencecolumn", "widget.ganttcolumn.sequence"],
    mixins: ["Gnt.mixin.Localizable"],
    width: 40,
    align: "right",
    sortable: false,
    dataIndex: "index",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    },
    renderer: function (b, c, a) {
        return a.getSequenceNumber()
    }
});
Ext.define("Gnt.column.ManuallyScheduled", {
    extend: "Ext.grid.Column",
    alias: ["widget.manuallyscheduledcolumn", "widget.ganttcolumn.manuallyscheduledcolumn"],
    requires: ["Gnt.field.ManuallyScheduled"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 50,
    align: "center",
    instantUpdate: false,
    defaultEditorXType: "manuallyscheduledfield",
    initComponent: function () {
        this.initTaskFieldColumn();
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return this.field.valueToVisible(a.isManuallyScheduled())
    }
});
Ext.define("Gnt.column.SchedulingMode", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.SchedulingMode"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    alias: ["widget.schedulingmodecolumn", "widget.ganttcolumn.schedulingmode"],
    width: 100,
    align: "left",
    data: null,
    instantUpdate: false,
    fieldProperty: "schedulingModeField",
    defaultEditorXType: "schedulingmodefield",
    initComponent: function () {
        this.initTaskFieldColumn({store: this.data});
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.AddNew", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.addnewcolumn", "widget.ganttcolumn.addnew"],
    requires: ["Ext.form.field.ComboBox", "Ext.Editor"],
    mixins: ["Gnt.mixin.Localizable"],
    text: "",
    width: 100,
    resizable: false,
    sortable: false,
    draggable: false,
    colEditor: null,
    colEditorStore: null,
    columnList: null,
    initComponent: function () {
        if (!this.text) {
            this.text = this.L("text")
        }
        this.addCls("gnt-addnewcolumn");
        this.on({headerclick: this.myOnHeaderClick, headertriggerclick: this.myOnHeaderClick, scope: this});
        this.callParent(arguments)
    },
    getGantt: function () {
        if (!this.gantt) {
            this.gantt = this.up("ganttpanel")
        }
        return this.gantt
    },
    getColEditor: function () {
        var b = this, a;
        if (!b.colEditor) {
            a = b.colEditor = new Ext.Editor({
                shadow: false,
                updateEl: false,
                itemId: "addNewEditor",
                renderTo: b.el,
                offsets: [20, 0],
                field: new Ext.form.field.ComboBox({
                    displayField: "text",
                    valueField: "clsName",
                    hideTrigger: true,
                    queryMode: "local",
                    forceSelection: true,
                    multiSelect: false,
                    listConfig: {itemId: "addNewEditorComboList", minWidth: 150},
                    store: b.getColEditorStore(),
                    listeners: {
                        render: function () {
                            this.on("blur", function () {
                                a.cancelEdit()
                            })
                        }, select: b.onSelect, scope: b
                    }
                })
            })
        }
        return b.colEditor
    },
    getColEditorStore: function () {
        var a = this;
        if (!a.colEditorStore) {
            a.columnList = a.columnList || Gnt.column.AddNew.buildDefaultColumnList();
            a.colEditorStore = new Ext.data.Store({
                fields: ["text", "clsName", "config"],
                data: a.columnList,
                sorters: [{property: "text", direction: "ASC"}]
            })
        }
        return a.colEditorStore
    },
    myOnHeaderClick: function () {
        var c = this, b, a;
        a = c.el.down("." + Ext.baseCSSPrefix + "column-header-text");
        b = c.getColEditor();
        b.startEdit(a, "");
        b.field.reset();
        b.field.setWidth(this.getWidth() - 20);
        b.field.expand();
        return false
    },
    onSelect: function (c, a) {
        var b = this;
        b.colEditor.cancelEdit();
        b.addColumn(Ext.isArray(a) ? a[0] : a)
    },
    addColumn: function (b) {
        var e = this;
        var g = b;
        var a = e.ownerCt;
        var f = g.get("text");
        var c = g.get("config") || {};
        var d = g.get("clsName") || c.xclass || "Ext.grid.column.Column";
        Ext.require(d, function () {
            var h = Ext.ClassManager.get(d);
            var i = Ext.create(Ext.applyIf(c, {
                xclass: d,
                dataIndex: e.getGantt().taskStore.model.prototype[h.prototype.fieldProperty],
                text: f
            }));
            a.insert(a.items.indexOf(e), i)
        })
    },
    statics: {
        buildDefaultColumnList: function () {
            var a = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression("widget.ganttcolumn.*"), function (c) {
                var b = Ext.ClassManager.get(c);
                if (b !== Gnt.column.AddNew && !Gnt.column.AddNew.prototype.isPrototypeOf(b.prototype)) {
                    a.push({clsName: c, text: b.prototype.localize ? b.prototype.localize("text") : b.prototype.text})
                }
            });
            return Ext.Array.sort(a, function (d, c) {
                return d.text > c.text ? 1 : -1
            })
        }
    }
});
Ext.define("Gnt.column.EarlyStartDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.earlystartdatecolumn", "widget.ganttcolumn.earlystartdate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function (b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayStartDate(this.format, this.adjustMilestones, a.getEarlyStartDate())
    }
});
Ext.define("Gnt.column.EarlyEndDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.earlyenddatecolumn", "widget.ganttcolumn.earlyenddate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function (b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayEndDate(this.format, this.adjustMilestones, a.getEarlyEndDate())
    }
});
Ext.define("Gnt.column.LateStartDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.latestartdatecolumn", "widget.ganttcolumn.latestartdate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function (b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayStartDate(this.format, this.adjustMilestones, a.getLateStartDate())
    }
});
Ext.define("Gnt.column.LateEndDate", {
    extend: "Ext.grid.column.Date",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.lateenddatecolumn", "widget.ganttcolumn.lateenddate"],
    width: 100,
    align: "left",
    adjustMilestones: true,
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function (b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        return a.getDisplayEndDate(this.format, this.adjustMilestones, a.getLateEndDate())
    }
});
Ext.define("Gnt.column.Slack", {
    extend: "Ext.grid.column.Column",
    requires: ["Ext.Number", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.slackcolumn", "widget.ganttcolumn.slack"],
    decimalPrecision: 2,
    useAbbreviation: false,
    slackUnit: "d",
    width: 100,
    align: "left",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments);
        this.renderer = a.renderer || this.rendererFunc;
        this.scope = a.scope || this;
        this.hasCustomRenderer = true
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    rendererFunc: function (b, c, a) {
        c.tdCls = (c.tdCls || "") + " sch-column-readonly";
        b = a.getSlack();
        if (Ext.isNumber(b)) {
            return parseFloat(Ext.Number.toFixed(b, this.decimalPrecision)) + " " + Sch.util.Date[this.useAbbreviation ? "getShortNameOfUnit" : "getReadableNameOfUnit"](this.slackUnit, b !== 1)
        }
        return ""
    }
});
Ext.define("Gnt.column.BaselineStartDate", {
    extend: "Gnt.column.StartDate",
    requires: ["Gnt.field.BaselineStartDate"],
    alias: ["widget.baselinestartdatecolumn", "widget.ganttcolumn.baselinestartdate"],
    width: 100,
    fieldProperty: "baselineStartDateField",
    fieldConfigs: ["instantUpdate", "adjustMilestones"],
    defaultEditorXType: "baselinestartdatefield"
});
Ext.define("Gnt.column.BaselineEndDate", {
    extend: "Gnt.column.EndDate",
    requires: ["Gnt.field.BaselineEndDate"],
    alias: ["widget.baselineenddatecolumn", "widget.ganttcolumn.baselineenddate"],
    width: 100,
    fieldProperty: "baselineEndDateField",
    fieldConfigs: ["instantUpdate", "adjustMilestones", "keepDuration", "validateStartDate"],
    defaultEditorXType: "baselineenddatefield"
});
Ext.define("Gnt.column.Milestone", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.milestonecolumn", "widget.ganttcolumn.milestone"],
    requires: ["Gnt.field.Milestone"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 50,
    align: "center",
    defaultEditorXType: "milestonefield",
    initComponent: function () {
        this.initTaskFieldColumn();
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return this.field.valueToVisible(a.isMilestone())
    }
});
Ext.define("Gnt.column.Rollup", {
    extend: "Ext.grid.Column",
    alias: ["widget.rollupcolumn", "widget.ganttcolumn.rollup"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    fieldProperty: "rollupField",
    defaultEditorXType: "combobox",
    initComponent: function () {
        this.initTaskFieldColumn({store: [[false, this.L("no")], [true, this.L("yes")]]});
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return this.L(b ? "yes" : "no")
    }
});
Ext.define("Gnt.column.Calendar", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.calendarcolumn", "widget.ganttcolumn.calendar"],
    requires: ["Gnt.model.Calendar", "Gnt.field.Calendar"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 100,
    align: "left",
    instantUpdate: true,
    store: null,
    fieldProperty: "calendarIdField",
    fieldConfigs: ["instantUpdate", "store"],
    defaultEditorXType: "calendarfield",
    initComponent: function () {
        this.initTaskFieldColumn({format: this.editorFormat || this.format || Ext.Date.defaultFormat});
        this.callParent(arguments)
    },
    applyColumnCls: function (e, f, b, d, c, a) {
        if (!e) {
            f.tdCls = (f.tdCls || "") + " gnt-default"
        }
    },
    getValueToRender: function (e, f, b, d, c, a) {
        e = e || (a.calendar ? a.calendar.calendarId : "");
        return this.field.valueToVisible(e, b) || e
    }
});
Ext.define("Gnt.widget.AssignmentEditGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.assignmenteditgrid",
    requires: ["Ext.data.JsonStore", "Ext.window.MessageBox", "Ext.form.field.ComboBox", "Ext.grid.plugin.CellEditing", "Gnt.util.Data", "Gnt.data.AssignmentStore", "Gnt.data.ResourceStore", "Gnt.column.ResourceName", "Gnt.column.AssignmentUnits"],
    mixins: ["Gnt.mixin.Localizable"],
    assignmentStore: null,
    resourceStore: null,
    readOnly: false,
    cls: "gnt-assignmentgrid",
    defaultAssignedUnits: 100,
    confirmAddResource: true,
    addResources: true,
    taskId: null,
    refreshTimeout: 100,
    resourceDupStore: null,
    resourceComboStore: null,
    assignmentUnitsEditor: null,
    constructor: function (b) {
        Ext.apply(this, b);
        var d = b.assignmentStore;
        var a = b.taskStore || d.getTaskStore();
        this.store = b.store || new d.self({model: d.model, taskStore: a});
        var c = a.getResourceStore();
        this.resourceDupStore = b.resourceDupStore || new c.self({model: c.model, taskStore: a});
        this.resourceComboStore = new Ext.data.JsonStore({model: this.resourceDupStore.model});
        if (b.addResources !== undefined) {
            this.addResources = b.addResources
        }
        this.columns = this.buildColumns();
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        this.callParent(arguments)
    },
    initComponent: function () {
        this.loadResources();
        var a = Ext.Function.createBuffered(this.loadResources, this.refreshTimeout, this, []);
        this.mon(this.resourceStore, {add: a, remove: a, load: a, clear: a});
        this.loadTaskAssignments();
        var b = Ext.Function.createBuffered(this.loadTaskAssignments, this.refreshTimeout, this, []);
        this.mon(this.assignmentStore, {add: b, remove: b, load: b, clear: b});
        this.callParent(arguments)
    },
    loadResources: function (b) {
        if (!this.resourceStore) {
            return false
        }
        var a = Gnt.util.Data.cloneModelSet(this.resourceStore, function (c, d) {
            if (!c.getId()) {
                c.setId(d.getId())
            }
        });
        this.resourceDupStore.loadData(a);
        this.resourceComboStore.loadData(a);
        if (!b) {
            this.loadTaskAssignments()
        }
        return true
    },
    getUnitsEditor: function () {
        if (!this.readOnly) {
            if (!this.assignmentUnitsEditor) {
                this.assignmentUnitsEditor = this.down("assignmentunitscolumn").getEditor()
            }
        }
        return this.assignmentUnitsEditor
    },
    setEditableFields: function (a) {
        var b = this.getUnitsEditor();
        if (b) {
            switch (a.getSchedulingMode()) {
                case"DynamicAssignment":
                    b.setReadOnly(true);
                    break;
                default:
                    b.setReadOnly(false)
            }
        }
    },
    loadTaskAssignments: function (d) {
        d = d || this.taskId;
        if (!d) {
            return false
        }
        var c = this.taskStore || this.assignmentStore.getTaskStore(), b = c && c.getModelById(d), g;
        if (b) {
            g = b.getAssignments()
        } else {
            if (!this.assignmentStore) {
                return false
            }
            g = this.assignmentStore.queryBy(function (h) {
                return h.getTaskId() == d
            })
        }
        this.taskId = d;
        var a = this.store, e = this.resourceDupStore, f = Gnt.util.Data.cloneModelSet(g, function (i, h) {
            var k = h.getResourceId();
            var j = e.queryBy(function (m) {
                var l = m.originalRecord;
                return (l.getId() || l.internalId) == k
            });
            if (j.getCount()) {
                j = j.first();
                i.setResourceId(j.getId() || j.internalId)
            }
        });
        a.loadData(f);
        if (b && this.rendered) {
            this.setEditableFields(b)
        }
        return true
    },
    insertAssignment: function (b, g) {
        if (!this.store) {
            return
        }
        var d = this.store.model.prototype, c = {};
        if (b) {
            c = b
        } else {
            c[d.unitsField] = this.defaultAssignedUnits
        }
        c[d.taskIdField] = this.taskId;
        var e = this.store.insert(0, c);
        var f = this, a = e[0].isValid;
        e[0].isValid = function () {
            return a.apply(this, arguments) && f.isValidAssignment(this)
        };
        if (!g && this.cellEditing) {
            this.cellEditing.startEditByPosition({row: 0, column: 0})
        }
        return e
    },
    isValid: function () {
        var a = true;
        this.store.each(function (b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    },
    getAssignmentErrors: function (a) {
        var b = a.getResourceId();
        if (!b) {
            return [this.L("noValueText")]
        }
        if (!this.resourceDupStore.getModelById(b)) {
            return [Ext.String.format(this.L("noResourceText"), b)]
        }
    },
    isValidAssignment: function (a) {
        return !this.getAssignmentErrors(a)
    },
    buildPlugins: function () {
        var a = this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {clicksToEdit: 1});
        var b = a.startEdit;
        a.startEdit = function () {
            this.completeEdit();
            return b.apply(this, arguments)
        };
        a.on({beforeedit: this.onEditingStart, scope: this});
        return [a]
    },
    hide: function () {
        this.cellEditing.cancelEdit();
        return this.callParent(arguments)
    },
    onEditingStart: function (a, c) {
        var b = this.store.model.prototype;
        if (c.field == b.resourceIdField) {
            this.assignment = c.record;
            this.resourceId = c.record.getResourceId();
            this.resourceComboStore.loadData(this.resourceDupStore.getRange());
            this.resourceComboStore.filter(this.resourcesFilter)
        }
    },
    resourceRender: function (b, c, d) {
        var e = this.getAssignmentErrors(d);
        if (e && e.length) {
            c.tdCls = Ext.baseCSSPrefix + "form-invalid";
            c.tdAttr = 'data-errorqtip="' + e.join("<br>") + '"'
        } else {
            c.tdCls = "";
            c.tdAttr = 'data-errorqtip=""'
        }
        var a = this.resourceDupStore.getModelById(b);
        return Ext.String.htmlEncode((a && a.getName()) || b)
    },
    filterResources: function (c) {
        var d = c.getId(), b = this.store.model.prototype.resourceIdField, a = true;
        if (d !== this.resourceId) {
            this.store.each(function (e) {
                if (d == e.get(b)) {
                    a = false;
                    return false
                }
            })
        }
        return a
    },
    onResourceComboAssert: function (f) {
        var e = f.getRawValue();
        if (e) {
            var a = this.resourceDupStore.findExact(f.displayField, e);
            var b = a !== -1 ? this.resourceDupStore.getAt(a) : false;
            if (!b) {
                var h = this.assignment;
                var d = this;
                var c = function (j) {
                    var k = d.resourceStore.model, i = {};
                    i[k.prototype.nameField] = f.rawValue;
                    i = new k(i);
                    i.setId(i.internalId);
                    var l = d.resourceDupStore.add(i);
                    if (l && l.length) {
                        if (!j) {
                            f.getStore().add(i);
                            f.setValue(l[0].getId())
                        } else {
                            h.setResourceId(l[0].getId())
                        }
                    }
                };
                if (this.confirmAddResource) {
                    var g = Ext.String.format(this.L("confirmAddResourceText"), Ext.String.htmlEncode(e));
                    Ext.Msg.confirm(this.L("confirmAddResourceTitle"), g, function (i) {
                        if (i == "yes") {
                            c(true)
                        }
                    })
                } else {
                    c()
                }
            } else {
                f.select(b, true)
            }
        }
    },
    buildColumns: function () {
        var c = this;
        this.resourceCombo = new Ext.form.field.ComboBox({
            queryMode: "local",
            store: this.resourceComboStore,
            allowBlank: false,
            editing: this.addResources,
            validateOnChange: false,
            autoSelect: false,
            forceSelection: !this.addResources,
            valueField: this.resourceComboStore.model.prototype.idProperty,
            displayField: this.resourceComboStore.model.prototype.nameField,
            queryCaching: false,
            listConfig: {
                getInnerTpl: function () {
                    return "{" + this.displayField + ":htmlEncode}"
                }
            }
        });
        this.resourcesFilter = Ext.create("Ext.util.Filter", {filterFn: this.filterResources, scope: this});
        if (this.addResources) {
            Ext.Function.interceptBefore(this.resourceCombo, "assertValue", function () {
                c.onResourceComboAssert(this)
            })
        }
        var a;
        if (this.taskId) {
            var b = this.taskStore || this.assignmentStore.getTaskStore();
            a = b && b.getModelById(this.taskId)
        }
        return [{
            xtype: "resourcenamecolumn",
            editor: this.resourceCombo,
            dataIndex: this.assignmentStore.model.prototype.resourceIdField,
            renderer: this.resourceRender,
            scope: this
        }, {
            xtype: "assignmentunitscolumn",
            assignmentStore: this.assignmentStore,
            dataIndex: this.assignmentStore.model.prototype.unitsField,
            editor: {xtype: "percentfield", step: 10, readOnly: a && a.getSchedulingMode() == "DynamicAssignment"}
        }]
    },
    saveResources: function () {
        Gnt.util.Data.applyCloneChanges(this.resourceDupStore, this.resourceStore)
    },
    saveTaskAssignments: function () {
        this.resourceStore.suspendEvents(true);
        this.assignmentStore.suspendEvents(true);
        this.saveResources();
        var b = this.store.model, c = this.resourceDupStore, a = true;
        Gnt.util.Data.applyCloneChanges(this.store, this.assignmentStore, function (f) {
            var e = c.getById(this.getResourceId());
            if (!e || !e.originalRecord) {
                a = false;
                return
            }
            var d = e.originalRecord;
            f[b.prototype.resourceIdField] = d.getId() || d.internalId
        });
        this.resourceStore.resumeEvents();
        this.assignmentStore.resumeEvents();
        return a
    },
    isDataChanged: function () {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function () {
        var a = true;
        this.store.each(function (b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    }
});
Ext.define("Gnt.widget.DependencyGrid", {
    extend: "Ext.grid.Panel",
    alias: "widget.dependencygrid",
    requires: ["Ext.data.JsonStore", "Ext.grid.plugin.CellEditing", "Ext.form.field.ComboBox", "Ext.util.Filter", "Gnt.model.Dependency", "Gnt.util.Data", "Gnt.field.Duration"],
    mixins: ["Gnt.mixin.Localizable"],
    readOnly: false,
    showCls: false,
    cls: "gnt-dependencygrid",
    task: null,
    dependencyStore: null,
    taskModel: null,
    direction: "predecessors",
    oppositeStore: null,
    taskStoreListeners: null,
    refreshTimeout: 100,
    allowParentTaskDependencies: false,
    useSequenceNumber: false,
    lagEditor: null,
    typesCombo: null,
    constructor: function (b) {
        b = b || {};
        Ext.Array.each(["idText", "taskText", "blankTaskText", "invalidDependencyText", "parentChildDependencyText", "duplicatingDependencyText", "transitiveDependencyText", "cyclicDependencyText", "typeText", "lagText", "clsText", "endToStartText", "startToStartText", "endToEndText", "startToEndText"], function (c) {
            if (c in b) {
                this[c] = b[c]
            }
        }, this);
        this.store = b.store || new Ext.data.JsonStore({model: b.dependencyStore ? b.dependencyStore.model : "Gnt.model.Dependency"});
        if (!this.readOnly) {
            this.plugins = this.buildPlugins()
        }
        this.direction = b.direction || this.direction;
        if (!b.taskModel) {
            b.taskModel = Ext.ClassManager.get("Gnt.model.Task");
            if (b.dependencyStore) {
                var a = b.dependencyStore.getTaskStore();
                if (a) {
                    b.taskModel = a.model
                }
            }
        }
        if (b.oppositeStore) {
            this.setOppositeStore(b.oppositeStore)
        }
        this.callParent([b])
    },
    initComponent: function () {
        if (this.task) {
            this.setTask(this.task);
            this.loadDependencies(this.task)
        }
        this.columns = this.buildColumns();
        this.callParent(arguments)
    },
    destroy: function () {
        if (this.deferredStoreBind) {
            this.tasksCombo.un("render", this.bindTaskStore, this)
        }
        this.tasksCombo.destroy();
        this.typesCombo.destroy();
        this.lagEditor.destroy();
        this.callParent(arguments);
        this.cellEditing.destroy()
    },
    setTask: function (a) {
        if (!a) {
            return
        }
        this.task = a;
        var b = a.dependencyStore || a.getTaskStore().dependencyStore;
        if (b && b !== this.dependencyStore) {
            if (this.dependencyStore) {
                this.mun(this.dependencyStore, this.onDependencyStoreDataChanged, this)
            }
            this.dependencyStore = b;
            if (this.typesCombo) {
                this.typesCombo.store.filter(this.typesFilter)
            }
            this.mon(this.dependencyStore, this.onDependencyStoreDataChanged, this)
        }
    },
    onDependencyStoreDataChanged: function () {
        this.loadDependencies()
    },
    buildPlugins: function () {
        var a = this.cellEditing = new Ext.grid.plugin.CellEditing({clicksToEdit: 1});
        a.on({beforeedit: this.onEditingStart, edit: this.onEditingDone, scope: this});
        return [a]
    },
    hide: function () {
        this.cellEditing.cancelEdit();
        this.callParent(arguments)
    },
    onEditingStart: function (a, c) {
        var b = this.store.model.prototype;
        switch (c.field) {
            case b.lagField:
                this.lagEditor.durationUnit = c.record.getLagUnit();
                break;
            case b.typeField:
                this.typesCombo.store.filter(this.typesFilter);
                if (this.typesCombo.store.count() < 2) {
                    return false
                }
                break
        }
    },
    onEditingDone: function (a, c) {
        var b = this.store.model.prototype;
        if (c.field == b.lagField) {
            c.record.setLagUnit(this.lagEditor.durationUnit)
        }
        this.getView().refresh()
    },
    dependencyTypeRender: function (b) {
        var a = this.store.model.Type;
        switch (b) {
            case a.EndToStart:
                return this.L("endToStartText");
            case a.StartToStart:
                return this.L("startToStartText");
            case a.EndToEnd:
                return this.L("endToEndText");
            case a.StartToEnd:
                return this.L("startToEndText")
        }
        return b
    },
    taskValidate: function (b, a) {
        if (!b) {
            return [this.L("blankTaskText")]
        }
        if (!a.isValid()) {
            var c = this.getDependencyErrors(a);
            if (c && c.length) {
                return c
            }
            return [this.L("invalidDependencyText")]
        }
    },
    taskRender: function (d, e, b) {
        var f = this.taskValidate(d, b), a;
        if (f && f.length) {
            e.tdCls = Ext.baseCSSPrefix + "form-invalid";
            e.tdAttr = 'data-errorqtip="' + f.join("<br>") + '"'
        } else {
            e.tdCls = "";
            e.tdAttr = 'data-errorqtip=""'
        }
        var c = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (c) {
            a = c.getModelById(d);
            return (a && Ext.String.htmlEncode(a.getName())) || ""
        }
        return ""
    },
    filterTasks: function (a) {
        var c = this, b = a.getId(), d;
        if (this.direction === "predecessors") {
            d = "getSourceId"
        } else {
            d = "getTargetId"
        }
        return b != this.task.getId() && !this.task.contains(a) && !a.contains(this.task) && (this.allowParentTaskDependencies || a.isLeaf())
    },
    bindTaskStore: function () {
        var c = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (c) {
            if (!this.taskStoreListeners) {
                var d = Ext.Function.createBuffered(this.bindTaskStore, this.refreshTimeout, this, []);
                this.taskStoreListeners = this.mon(c, {
                    nodeappend: d,
                    nodeinsert: d,
                    noderemove: d,
                    update: d,
                    refresh: d,
                    clear: d,
                    "nodestore-datachange-end": d,
                    scope: this,
                    destroyable: true
                })
            }
            var b = new Ext.data.JsonStore({model: c.model, sorters: c.model.prototype.nameField});
            var a = c.getRootNode();
            b.loadData(Gnt.util.Data.cloneModelSet(c.toArray(), function (f, e) {
                if (e === a || e.hidden) {
                    return false
                }
                if (!e.getId()) {
                    f.setId(e.getId())
                }
            }));
            this.tasksFilter = new Ext.util.Filter({filterFn: this.filterTasks, scope: this});
            b.filter(this.tasksFilter);
            this.tasksCombo.bindStore(b)
        }
    },
    buildTasksCombo: function () {
        var a = this;
        return new Ext.form.field.ComboBox({
            queryMode: "local",
            allowBlank: false,
            editing: false,
            forceSelection: true,
            valueField: this.taskModel.prototype.idProperty,
            displayField: this.taskModel.prototype.nameField,
            queryCaching: false,
            listConfig: {
                getInnerTpl: function () {
                    return "{" + this.displayField + ":htmlEncode}"
                }
            },
            validator: function (b) {
                if (!b) {
                    return a.L("blankTaskText")
                }
                return true
            }
        })
    },
    filterAllowedTypes: function (b) {
        if (!this.dependencyStore || !this.dependencyStore.allowedDependencyTypes) {
            return true
        }
        var e = this.dependencyStore.allowedDependencyTypes;
        var f = this.store.model.Type;
        for (var c = 0, a = e.length; c < a; c++) {
            var d = f[e[c]];
            if (b.getId() == d) {
                return true
            }
        }
        return false
    },
    buildTypesCombo: function () {
        var b = this.store.model.Type;
        this.typesFilter = new Ext.util.Filter({id: "typesfilter", filterFn: this.filterAllowedTypes, scope: this});
        var a = new Ext.data.ArrayStore({
            fields: [{name: "id", type: "int"}, "text"],
            data: [[b.EndToStart, this.L("endToStartText")], [b.StartToStart, this.L("startToStartText")], [b.EndToEnd, this.L("endToEndText")], [b.StartToEnd, this.L("startToEndText")]]
        });
        a.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            triggerAction: "all",
            queryMode: "local",
            editable: false,
            valueField: "id",
            displayField: "text",
            store: a
        })
    },
    buildLagEditor: function () {
        return new Gnt.field.Duration({minValue: Number.NEGATIVE_INFINITY})
    },
    buildColumns: function () {
        var d = this, b = this.store.model.prototype, f = this.store.model.Type, e = [], a = this.dependencyStore && this.dependencyStore.getTaskStore();
        this.tasksCombo = this.buildTasksCombo();
        if (!a) {
            this.deferredStoreBind = true;
            this.tasksCombo.on("render", this.bindTaskStore, this)
        } else {
            this.bindTaskStore()
        }
        var c = {};
        if (this.useSequenceNumber) {
            c = {
                text: this.L("snText"), dataIndex: b.fromField, renderer: function (j, k, g) {
                    var h = d.dependencyStore && d.dependencyStore.getTaskStore(), i = h && h.getModelById(g.get("From"));
                    return i ? i.getSequenceNumber() : ""
                }, width: 50
            }
        } else {
            c = {text: this.L("idText"), dataIndex: b.fromField, width: 50}
        }
        e.push(c, {
            text: this.L("taskText"),
            dataIndex: b[this.direction === "predecessors" ? "fromField" : "toField"],
            flex: 1,
            editor: this.tasksCombo,
            renderer: function (h, i, g) {
                return d.taskRender(h, i, g)
            }
        });
        this.lagEditor = this.buildLagEditor();
        this.typesCombo = this.buildTypesCombo();
        e.push({
            text: this.L("typeText"), dataIndex: b.typeField, width: 120, renderer: function (g) {
                return d.dependencyTypeRender(g)
            }, editor: this.typesCombo
        }, {
            text: this.L("lagText"),
            dataIndex: b.lagField,
            width: 100,
            editor: this.lagEditor,
            renderer: function (h, i, g) {
                return d.lagEditor.valueToVisible(h, g.get(b.lagUnitField), 2)
            }
        }, {text: this.L("clsText"), dataIndex: b.clsField, hidden: !this.showCls, width: 100});
        return e
    },
    insertDependency: function (b, h) {
        if (!this.dependencyStore) {
            return
        }
        var e = this.task.getId(), d = this.store.model.prototype, c = {}, g = this;
        if (b) {
            c = b
        } else {
            c[d.typeField] = this.typesCombo.store.getAt(0).getId();
            c[d.lagField] = 0;
            c[d.lagUnitField] = "d"
        }
        if (this.direction === "predecessors") {
            c[d.toField] = e
        } else {
            c[d.fromField] = e
        }
        var f = this.store.insert(0, c);
        if (f.length) {
            var a = f[0].isValid;
            f[0].isValid = function () {
                return a.call(this, false) && g.isValidDependency(this)
            }
        }
        if (!h) {
            this.cellEditing.startEditByPosition({row: 0, column: 1})
        }
        return f
    },
    onOppositeStoreChange: function () {
        this.getView().refresh()
    },
    setOppositeStore: function (a) {
        var b = {update: this.onOppositeStoreChange, datachanged: this.onOppositeStoreChange, scope: this};
        if (this.oppositeStore) {
            this.mun(this.oppositeStore, b)
        }
        this.oppositeStore = a;
        this.mon(this.oppositeStore, b)
    },
    loadDependencies: function (b) {
        var c = this;
        b = b || this.task;
        if (!b) {
            return
        }
        if (this.task !== b) {
            this.setTask(b)
        }
        var d;
        if (this.direction === "predecessors") {
            d = b.getIncomingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = b.getOutgoingDependencies(true)
            }
        } else {
            d = b.getOutgoingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = b.getIncomingDependencies(true)
            }
        }
        var a = Gnt.util.Data.cloneModelSet(d, function (f) {
            var e = f.isValid;
            f.isValid = function () {
                return e.call(this, false) && c.isValidDependency(this)
            }
        });
        this.store.loadData(a);
        this.fireEvent("loaddependencies", this, this.store, a, b)
    },
    getDependencyErrors: function (c) {
        var h = this, j = h.dependencyStore, d = h.task.getId(), b = d, i = [];
        if (h.direction === "predecessors") {
            d = c.getSourceId()
        } else {
            b = c.getTargetId()
        }
        var f = j.getSourceTask(d);
        var e = j.getTargetTask(b);
        h.store.each(function (n) {
            var m = n.getSourceId(), l = n.getTargetId();
            if ((d == m) && (b == l) && (n !== c)) {
                i.push(h.L("duplicatingDependencyText"));
                return false
            }
        });
        if (i.length) {
            return i
        }
        var k = h.store.getRange();
        k.splice(Ext.Array.indexOf(k, c), 1);
        var a = h.task[h.direction];
        var g = j.getDependencyError(c, k, a);
        if (g) {
            switch (g) {
                case-3:
                case-8:
                case-5:
                case-6:
                    return [h.L("transitiveDependencyText")];
                case-4:
                case-7:
                    return [h.L("cyclicDependencyText")];
                case-9:
                    return [h.L("parentChildDependencyText")]
            }
            return [this.L("invalidDependencyText")]
        }
        return i
    },
    isValidDependency: function (a) {
        var b = this.getDependencyErrors(a);
        return !b || !b.length
    },
    isValid: function () {
        var a = true;
        this.store.each(function (b) {
            if (!b.isValid()) {
                a = false;
                return false
            }
        });
        return a
    },
    saveDependencies: function () {
        if (!this.dependencyStore || !this.isValid()) {
            return
        }
        Gnt.util.Data.applyCloneChanges(this.store, this.dependencyStore)
    },
    isDataChanged: function () {
        var a = this;
        return a.store && a.store.getUpdatedRecords().length > 0 || a.store.getNewRecords().length > 0 || a.store.getRemovedRecords().length > 0
    },
    isDataValid: function () {
        return this.isValid()
    }
});
Ext.define("Gnt.widget.taskeditor.BaseForm", {
    extend: "Ext.form.Panel",
    highlightTaskUpdates: true,
    task: null,
    taskBuffer: null,
    taskStore: null,
    taskListeners: null,
    autoScroll: true,
    defaults: {labelWidth: 110},
    bodyPadding: 5,
    border: false,
    layout: "anchor",
    defaultType: "textfield",
    initComponent: function () {
        if (this.task) {
            this.fieldNames = this.getFieldNames(this.task)
        }
        if (!this.items) {
            this.buildFields()
        }
        this.callParent(arguments);
        if (this.task) {
            this.loadRecord(this.task, this.taskBuffer)
        }
    },
    getFieldNames: function (b) {
        if (!b) {
            return
        }
        var a = {};
        for (var c in this.fieldNames) {
            a[c] = b[c]
        }
        return a
    },
    renameFields: function (b) {
        var a = this.getFieldNames(b);
        if (!a) {
            return
        }
        var d = this.getForm(), f = false, e;
        for (var c in this.fieldNames) {
            e = d.findField(this.fieldNames[c]);
            if (e && a[c] && a[c] != e.name) {
                f = true;
                e.name = a[c]
            }
        }
        if (f) {
            this.fieldNames = a
        }
    },
    setSuppressTaskUpdate: function (b) {
        var a = this.getForm().getFields();
        a.each(function (c) {
            c.setSuppressTaskUpdate && c.setSuppressTaskUpdate(b)
        })
    },
    isDataChanged: function () {
        return this.isDirty()
    },
    buildTaskBuffer: function (a) {
        var b = this;
        b.taskBuffer = a.copy();
        b.taskBuffer.taskStore = a.taskStore
    },
    loadRecord: function (b, a) {
        var d = this;
        if (b && b !== d.task) {
            d.renameFields(b)
        }
        d.task = b;
        d.taskBuffer = a;
        if (!d.taskBuffer) {
            d.buildTaskBuffer(b)
        }
        d.taskListeners && d.taskListeners.destroy();
        d.taskListeners = d.mon(d.taskBuffer, {taskupdated: d.onTaskUpdated, destroyable: true, scope: d});
        var c = d.getForm();
        c._record = b;
        this.suspendLayouts();
        var e = b.getData();
        c.getFields().each(function (f) {
            if (f.getName()in e) {
                if (f.setTask) {
                    f.setTask(d.taskBuffer)
                } else {
                    f.setValue(e[f.getName()]);
                    d.updateFieldReadOnly(f)
                }
                if (c.trackResetOnLoad) {
                    f.resetOriginalValue()
                }
            }
        });
        this.resumeLayouts(true);
        this.fireEvent("afterloadrecord", this, b)
    },
    updateFieldReadOnly: function (b) {
        var a = this;
        if (!b.disabled) {
            if (b.editable === false) {
                if (!a.taskBuffer.isEditable(b.name)) {
                    b.setReadOnly(true)
                } else {
                    if (b.inputEl) {
                        b.setReadOnly(false);
                        b.inputEl.dom.readOnly = true
                    }
                }
            } else {
                b.setReadOnly(!a.taskBuffer.isEditable(b.name))
            }
        }
    },
    updateReadOnly: function () {
        var b = this, a = b.getForm(), c = b.taskBuffer.getData();
        a.getFields().each(function (d) {
            if (d.getName()in c && !d.isTaskField) {
                b.updateFieldReadOnly(d)
            }
        })
    },
    updateRecord: function (a) {
        var b = this;
        a = a || b.task;
        if (a && b.fireEvent("beforeupdaterecord", b, a, b.updateRecordFn) !== false) {
            b.setSuppressTaskUpdate(true);
            b.updateRecordFn.call(b, a);
            b.setSuppressTaskUpdate(false);
            b.fireEvent("afterupdaterecord", b, a);
            return true
        }
        return false
    },
    updateRecordWithFieldValue: function (a, c) {
        var b = a.getField(c.name);
        if (c.applyChanges) {
            c.applyChanges(a)
        } else {
            if (b && c.name in this.getForm().getFieldValues()) {
                a.set(c.name, c.getValue())
            }
        }
    },
    updateRecordFn: function (a) {
        var b = this;
        a.beginEdit();
        b.getForm().getFields().each(function (c) {
            b.updateRecordWithFieldValue(a, c)
        });
        a.endEdit()
    },
    initFieldDefinition: function (d, a) {
        var c = this;
        var b = {taskStore: c.taskStore, task: c.task, highlightTaskUpdates: c.highlightTaskUpdates};
        if (!d.readOnly && c.task) {
            b.readOnly = !c.task.isEditable(d.name)
        }
        return Ext.apply(d, b, a)
    },
    getTaskFieldValue: function (c) {
        var b = this, a = this.task;
        return a ? a.get(b.fieldNames[c]) : ""
    },
    onTaskUpdated: function (a, b) {
        this.updateReadOnly()
    }
});
Ext.define("Gnt.widget.taskeditor.TaskForm", {
    extend: "Gnt.widget.taskeditor.BaseForm",
    alias: "widget.taskform",
    requires: ["Gnt.model.Task", "Ext.form.FieldSet", "Ext.form.FieldContainer", "Ext.form.field.Text", "Ext.form.field.Date", "Gnt.field.Percent", "Gnt.field.StartDate", "Gnt.field.EndDate", "Gnt.field.Duration", "Gnt.field.SchedulingMode", "Gnt.field.ManuallyScheduled", "Gnt.field.Effort", "Gnt.field.ConstraintType", "Gnt.field.BaselineStartDate", "Gnt.field.BaselineEndDate"],
    mixins: ["Gnt.mixin.Localizable"],
    alternateClassName: ["Gnt.widget.TaskForm"],
    showGeneral: true,
    showBaseline: true,
    editBaseline: false,
    showCalendar: false,
    showManuallyScheduled: false,
    showSchedulingMode: false,
    showWbsCode: false,
    showRollup: false,
    showConstraint: false,
    taskNameConfig: null,
    durationConfig: null,
    startConfig: null,
    finishConfig: null,
    percentDoneConfig: null,
    baselineStartConfig: null,
    baselineFinishConfig: null,
    baselinePercentDoneConfig: null,
    effortConfig: null,
    calendarConfig: null,
    manuallyScheduledConfig: null,
    schedulingModeConfig: null,
    wbsCodeConfig: null,
    rollupConfig: null,
    constraintTypeConfig: null,
    constraintDateConfig: null,
    constructor: function (b) {
        b = b || {};
        this.showBaseline = b.showBaseline;
        this.editBaseline = b.editBaseline;
        var a = b.taskStore ? b.taskStore.model.prototype : Gnt.model.Task.prototype;
        this.fieldNames = {
            baselineEndDateField: a.baselineEndDateField,
            baselinePercentDoneField: a.baselinePercentDoneField,
            baselineStartDateField: a.baselineStartDateField,
            calendarIdField: a.calendarIdField,
            clsField: a.clsField,
            draggableField: a.draggableField,
            durationField: a.durationField,
            durationUnitField: a.durationUnitField,
            effortField: a.effortField,
            effortUnitField: a.effortUnitField,
            endDateField: a.endDateField,
            manuallyScheduledField: a.manuallyScheduledField,
            nameField: a.nameField,
            percentDoneField: a.percentDoneField,
            resizableField: a.resizableField,
            rollupField: a.rollupField,
            schedulingModeField: a.schedulingModeField,
            startDateField: a.startDateField,
            noteField: a.noteField,
            constraintTypeField: a.constraintTypeField,
            constraintDateField: a.constraintDateField
        };
        this.callParent(arguments);
        this.addBodyCls("gnt-taskeditor-taskform")
    },
    buildFields: function () {
        var a = this, b = a.fieldNames;
        a.items = a.items || [];
        if (a.showGeneral) {
            a.items.push({
                xtype: "fieldcontainer",
                layout: "hbox",
                items: [a.initFieldDefinition({
                    xtype: "textfield",
                    fieldLabel: a.L("taskNameText"),
                    name: b.nameField,
                    labelWidth: 110,
                    allowBlank: false,
                    flex: 1,
                    value: a.getTaskFieldValue(b.nameField)
                }, a.nameConfig)]
            }, {
                xtype: "fieldcontainer",
                layout: "hbox",
                defaults: {labelWidth: 110, allowBlank: false},
                items: [a.initFieldDefinition({
                    xtype: "percentfield",
                    fieldLabel: a.L("percentDoneText"),
                    name: b.percentDoneField,
                    margin: "0 0 0 8",
                    flex: 1,
                    value: a.getTaskFieldValue(b.percentDoneField)
                }, a.percentDoneConfig), a.initFieldDefinition({
                    xtype: "durationfield",
                    fieldLabel: a.L("durationText"),
                    name: b.durationField,
                    flex: 1,
                    value: a.getTaskFieldValue(b.durationField)
                }, a.durationConfig)]
            }, {
                xtype: "fieldset",
                title: a.L("datesText"),
                layout: "hbox",
                defaults: {labelWidth: 110, allowBlank: false},
                items: [a.initFieldDefinition({
                    xtype: "startdatefield",
                    fieldLabel: a.L("startText"),
                    flex: 1,
                    name: b.startDateField,
                    value: a.getTaskFieldValue(b.startDateField)
                }, a.startConfig), a.initFieldDefinition({
                    xtype: "enddatefield",
                    fieldLabel: a.L("finishText"),
                    flex: 1,
                    name: b.endDateField,
                    value: a.getTaskFieldValue(b.endDateField)
                }, a.finishConfig)]
            }, a.initFieldDefinition({
                xtype: "effortfield",
                fieldLabel: a.L("effortText"),
                name: b.effortField,
                invalidText: a.L("invalidEffortText"),
                width: 200,
                allowBlank: true,
                value: a.getTaskFieldValue(b.effortField)
            }, a.effortConfig))
        }
        if (a.showBaseline) {
            a.items.push({
                xtype: "fieldset",
                title: a.L("baselineText"),
                layout: "hbox",
                defaults: {labelWidth: 110, width: 260, cls: "gnt-baselinefield"},
                items: [a.initFieldDefinition({
                    xtype: "baselinestartdatefield",
                    fieldLabel: a.L("baselineStartText"),
                    name: b.baselineStartDateField,
                    value: a.getTaskFieldValue(b.baselineStartDateField),
                    readOnly: !a.editBaseline,
                    forceReadOnly: !this.editBaseline
                }, a.baselineStartConfig), a.initFieldDefinition({
                    xtype: "baselineenddatefield",
                    fieldLabel: a.L("baselineFinishText"),
                    name: b.baselineEndDateField,
                    flex: 1,
                    value: a.getTaskFieldValue(b.baselineEndDateField),
                    readOnly: !a.editBaseline,
                    forceReadOnly: !this.editBaseline
                }, a.baselineFinishConfig)]
            }, a.initFieldDefinition({
                xtype: "percentfield",
                fieldLabel: a.L("baselinePercentDoneText"),
                name: b.baselinePercentDoneField,
                labelWidth: 110,
                width: 200,
                cls: "gnt-baselinefield",
                value: a.getTaskFieldValue(b.baselinePercentDoneField),
                readOnly: !a.editBaseline
            }, a.baselinePercentDoneConfig))
        }
        if (a.showCalendar) {
            a.items.push(a.initFieldDefinition({
                xtype: "calendarfield",
                fieldLabel: this.L("calendarText"),
                width: 260,
                name: b.calendarIdField,
                value: a.getTaskFieldValue(b.calendarIdField)
            }, a.calendarConfig))
        }
        if (a.showManuallyScheduled) {
            a.items.push(a.initFieldDefinition({
                xtype: "manuallyscheduledfield",
                fieldLabel: a.L("manuallyScheduledText"),
                name: b.manuallyScheduledField,
                value: a.getTaskFieldValue(b.manuallyScheduledField)
            }, a.manuallyScheduledConfig))
        }
        if (a.showSchedulingMode) {
            a.items.push(a.initFieldDefinition({
                xtype: "schedulingmodefield",
                fieldLabel: a.L("schedulingModeText"),
                width: 260,
                name: b.schedulingModeField,
                value: a.getTaskFieldValue(b.schedulingModeField),
                allowBlank: false
            }, a.schedulingModeConfig))
        }
        if (a.showWbsCode) {
            a.items.push(a.initFieldDefinition({
                xtype: "textfield",
                fieldLabel: a.L("wbsCodeText"),
                name: "wbsCode",
                width: 260,
                readOnly: true,
                value: a.task && a.task.getWBSCode()
            }, a.wbsCodeConfig))
        }
        if (a.showRollup) {
            this.items.push(a.initFieldDefinition({
                xtype: "checkboxfield",
                fieldLabel: this.L("rollupText"),
                name: b.rollupField,
                value: a.getTaskFieldValue(b.rollupField)
            }, a.rollupConfig))
        }
        if (a.showConstraint) {
            a.items.push(a.initFieldDefinition({
                xtype: "constrainttypefield",
                fieldLabel: a.L("Constraint Type"),
                name: b.constraintTypeField,
                width: 260,
                value: a.getTaskFieldValue(b.constraintTypeField)
            }, a.constraintTypeConfig), a.initFieldDefinition({
                xtype: "constraintdatefield",
                fieldLabel: a.L("Constraint Date"),
                name: b.constraintDateField,
                width: 260,
                value: a.getTaskFieldValue(b.constraintDateField)
            }, a.constraintDateConfig))
        }
    },
    updateRecordWithFieldValue: function (a, c) {
        var b = this;
        if (c.name != b.fieldNames.constraintTypeField && c.name != b.fieldNames.constraintDateField) {
            return this.callParent(arguments)
        }
    },
    updateRecordFn: function (b) {
        var e = this, f = e.fieldNames, d = e.getForm(), c = d.findField(f.constraintTypeField), a = d.findField(f.constraintDateField);
        b.beginEdit();
        this.callParent(arguments);
        if (c && a && b.setConstraint) {
            b.setConstraint(c.getValue(), a.getValue())
        }
        b.endEdit()
    },
    buildTaskBuffer: function (a) {
        this.callParent(arguments);
        this.taskBuffer.getProject = function () {
            return a.getProject()
        }
    }
});
Ext.define("Gnt.widget.taskeditor.BaseEditor", {
    extend: "Ext.tab.Panel",
    requires: ["Gnt.util.Data"],
    mixins: ["Gnt.mixin.Localizable"],
    margin: "5 0 0 0",
    height: 340,
    width: 600,
    layout: "fit",
    border: false,
    plain: true,
    defaults: {margin: 5, border: false},
    eventIndicator: "task",
    task: null,
    taskBuffer: null,
    taskStore: null,
    assignmentStore: null,
    resourceStore: null,
    clonedStores: null,
    constructor: function (b) {
        var d = this;
        b = b || {};
        Ext.apply(d, b);
        if (!d.clonedStores) {
            d.clonedStores = (d.task || d.taskStore) ? d.cloneStores() : {}
        }
        var a = d.buildItems(b);
        var c = d.items;
        if (c) {
            a.push.apply(a, Ext.isArray(c) ? c : [c]);
            delete b.items
        }
        d.items = a;
        if (d.items.length <= 1) {
            b.tabBar = b.tabBar || {};
            Ext.applyIf(b.tabBar, {hidden: true})
        }
        this.callParent([b])
    },
    buildItems: function (a) {
        return []
    },
    cloneTaskBranch: function (d, h) {
        d = d || this.task;
        var g = this, e = g.getTaskStore(), b = e && e.getRoot(), f = g.clonedStores, a, c;
        d.bubble(function (i) {
            if (i !== b) {
                var j = h[i.getId()];
                if (j) {
                    if (c) {
                        j.appendChild(c)
                    }
                    c = null;
                    return false
                } else {
                    j = g.cloneTask(i);
                    h[i.getId()] = j;
                    j.taskStore = f.taskStore
                }
                if (c) {
                    j.appendChild(c)
                } else {
                    a = j
                }
                c = j
            }
        });
        return {branch: c, task: a}
    },
    cloneRelevantTasks: function (c) {
        c = c || this.task;
        var d = this, e = {};
        var a = d.cloneTaskBranch(c, e), b = a.task, f = [a.branch];
        Ext.Array.each(c.predecessors, function (h) {
            var g = d.cloneTaskBranch(h.getSourceTask(), e);
            if (g.branch) {
                f.push(g.branch)
            }
        });
        Ext.Array.each(c.successors, function (h) {
            var g = d.cloneTaskBranch(h.getTargetTask(), e);
            if (g.branch) {
                f.push(g.branch)
            }
        });
        return {task: b, tasks: f}
    },
    loadTask: function (a) {
        if (!a) {
            return
        }
        this.clonedStores = this.cloneStores({task: a});
        this.loadClonedStores(this.clonedStores, a)
    },
    cloneTaskStore: function (b, c) {
        var a = this.getTaskStore();
        if (!a) {
            return null
        }
        var d = new (Ext.getClass(a))(Ext.apply({
            isCloned: true,
            storeId: null,
            calendar: a.getCalendar(),
            model: a.model,
            weekendsAreWorkdays: a.weekendsAreWorkdays,
            cascadeChanges: a.cascadeChanges,
            batchSync: false,
            recalculateParents: false,
            skipWeekendsDuringDragDrop: a.skipWeekendsDuringDragDrop,
            moveParentAsGroup: a.moveParentAsGroup,
            enableDependenciesForParentTasks: a.enableDependenciesForParentTasks,
            availabilitySearchLimit: a.availabilitySearchLimit,
            dependenciesCalendar: "project",
            proxy: {type: "memory", reader: {type: "json"}}
        }, c));
        this.mon(a, {
            calendarset: function (e, f) {
                d.setCalendar(f)
            }
        });
        return d
    },
    cloneDependencyStore: function (b, d) {
        var c = this.getTaskStore();
        var a = this.dependencyStore || c && c.getDependencyStore();
        if (!a) {
            return null
        }
        return new (Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            strictDependencyValidation: a.strictDependencyValidation,
            allowedDependencyTypes: a.allowedDependencyTypes,
            proxy: {type: "memory", reader: {type: "json"}}
        }, d))
    },
    cloneAssignmentStore: function (b, d) {
        var c = this.getTaskStore();
        var a = this.assignmentStore || c && c.getAssignmentStore();
        if (!a) {
            return null
        }
        return new (Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            proxy: {type: "memory", reader: {type: "json"}}
        }, d))
    },
    cloneResourceStore: function (b, d) {
        var c = this.getTaskStore();
        var a = this.resourceStore || c && c.getResourceStore();
        if (!a) {
            return null
        }
        return new (Ext.getClass(a))(Ext.apply({
            isCloned: true,
            model: a.model,
            proxy: {type: "memory", reader: {type: "json"}}
        }, d))
    },
    cloneStores: function (d) {
        d = d || {};
        var a = d.task || this.task, e = this.clonedStores || {}, f = e.resourceStore || this.cloneResourceStore(a, d && d.resourceStore), g = e.assignmentStore || this.cloneAssignmentStore(a, d && d.assignmentStore), c = e.dependencyStore || this.cloneDependencyStore(a, d && d.dependencyStore);
        var b = e.taskStore || this.cloneTaskStore(a, Ext.apply({
                assignmentStore: g,
                resourceStore: f,
                dependencyStore: c
            }, d && d.taskStore));
        f.taskStore = b;
        Ext.apply(e, {resourceStore: f, assignmentStore: g, dependencyStore: c, taskStore: b});
        return e
    },
    getTaskStore: function (a) {
        a = a || this.task;
        return this.taskStore || a && a.getTaskStore()
    },
    loadClonedStores: function (c, b) {
        var d = this, e = d.cloneRelevantTasks(b), f = e.tasks, a = e.task;
        a.taskStore.on({
            update: function (i, g, h) {
                if (g === a && h == Ext.data.Model.EDIT) {
                    g.fireEvent(d.eventIndicator + "updated", g)
                }
            }
        });
        c.taskStore.setRootNode({expanded: true, children: f});
        d.loadClonedDependencyStore(c, b);
        d.loadClonedResourceStore(c, b);
        d.loadClonedAssignmentStore(c, b);
        d.taskBuffer = a
    },
    loadClonedDependencyStore: function (b, a) {
        b = b || this.clonedStores;
        b.dependencyStore && b.dependencyStore.loadData(Gnt.util.Data.cloneModelSet(a.getAllDependencies(), function (d, c) {
            d.setId(c.getId())
        }))
    },
    loadClonedResourceStore: function (b, a) {
        b = b || this.clonedStores;
        b.resourceStore && b.resourceStore.loadData(Gnt.util.Data.cloneModelSet(this.resourceStore || this.getTaskStore().getResourceStore(), function (d, c) {
            d.setId(c.getId())
        }))
    },
    loadClonedAssignmentStore: function (b, a) {
        b = b || this.clonedStores;
        b.assignmentStore && b.assignmentStore.loadData(Gnt.util.Data.cloneModelSet(a.getAssignments(), function (d, c) {
            d.setId(c.getId())
        }))
    },
    cloneTask: function (b) {
        var a = b.copy(b.getId(), false), c = a.getSegments();
        if (c) {
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                c[d] = e.copy(e.getId(), false)
            }
        }
        return a
    },
    getTabByComponent: function (b) {
        var a;
        this.items.each(function (c) {
            if (b === c || b.isDescendantOf(c)) {
                a = c;
                return false
            }
        }, this);
        return a
    },
    validate: function () {
        var b, a = this.getActiveTab(), c = [], d;
        b = this.doValidate(function (e) {
            c.push(e)
        });
        if (!b && a && !Ext.Array.contains(c, a)) {
            d = c[0];
            this.setActiveTab(d)
        } else {
            if (!b && a) {
                d = a
            } else {
                if (!b) {
                    d = c[0]
                }
            }
        }
        return (this.fireEvent("validate", this, d) !== false) && b
    },
    updateTask: function () {
        var b = this, a = false;
        if (b.fireEvent("beforeupdate" + b.eventIndicator, b, function () {
                b.doUpdateTask()
            }) !== false) {
            b.doUpdateTask();
            b.fireEvent("afterupdate" + b.eventIndicator, b);
            a = true
        }
        return a
    },
    onDestroy: function () {
        if (this.clonedStores.taskStore) {
            this.clonedStores.taskStore.destroy()
        }
        this.callParent(arguments)
    },
    doValidate: function () {
        return true
    },
    isDataValid: function () {
        return this.doValidate()
    },
    isDataChanged: function () {
        return false
    },
    doUpdateTask: Ext.emptyFn
});
Ext.define("Gnt.widget.taskeditor.TaskEditor", {
    extend: "Gnt.widget.taskeditor.BaseEditor",
    alias: "widget.taskeditor",
    requires: ["Gnt.widget.taskeditor.TaskForm", "Gnt.widget.AssignmentEditGrid", "Gnt.widget.DependencyGrid", "Ext.form.field.HtmlEditor"],
    alternateClassName: ["Gnt.widget.TaskEditor"],
    taskFormClass: "Gnt.widget.taskeditor.TaskForm",
    advancedFormClass: "Gnt.widget.taskeditor.TaskForm",
    showAssignmentGrid: true,
    showDependencyGrid: true,
    allowParentTaskDependencies: true,
    showNotes: true,
    showAdvancedForm: true,
    showRollup: false,
    showBaseline: true,
    taskFormConfig: null,
    dependencyGridClass: "Gnt.widget.DependencyGrid",
    dependencyGridConfig: null,
    assignmentGridClass: "Gnt.widget.AssignmentEditGrid",
    assignmentGridConfig: null,
    advancedFormConfig: null,
    notesConfig: null,
    notesPanel: null,
    notesEditor: null,
    taskForm: null,
    assignmentGrid: null,
    dependencyGrid: null,
    advancedForm: null,
    buildItems: function () {
        var c = this, a = [];
        var b = c.clonedStores || {};
        c.taskFormConfig = c.taskFormConfig || {};
        Ext.applyIf(c.taskFormConfig, {showBaseline: c.showBaseline, showRollup: false});
        c.taskForm = Ext.create(c.taskFormClass, Ext.apply({task: c.task, taskStore: c.taskStore}, c.taskFormConfig));
        a.push(c.taskForm);
        if (c.showDependencyGrid) {
            c.dependencyGrid = Ext.create(c.dependencyGridClass, Ext.apply({
                allowParentTaskDependencies: c.allowParentTaskDependencies,
                taskModel: c.taskStore.model,
                task: c.task,
                margin: 5,
                tbar: {
                    layout: "auto",
                    items: [{
                        xtype: "button",
                        iconCls: "gnt-action-add",
                        text: c.L("addDependencyText"),
                        itemId: "add-dependency-btn",
                        handler: function () {
                            c.dependencyGrid.insertDependency()
                        }
                    }, {
                        xtype: "button",
                        iconCls: "gnt-action-remove",
                        text: c.L("dropDependencyText"),
                        itemId: "drop-dependency-btn",
                        disabled: true,
                        handler: function () {
                            var d = c.dependencyGrid.getSelectionModel().getSelection();
                            if (d && d.length) {
                                c.dependencyGrid.store.remove(d)
                            }
                        }
                    }]
                },
                listeners: {
                    selectionchange: function (f, e) {
                        var d = c.dependencyGrid;
                        if (!d.dropDepBtn) {
                            d.dropDepBtn = d.down("#drop-dependency-btn")
                        }
                        d.dropDepBtn && d.dropDepBtn.setDisabled(!e.length)
                    }
                }
            }, c.dependencyGridConfig));
            a.push(c.dependencyGrid)
        }
        if (c.showAssignmentGrid && c.assignmentStore && c.resourceStore) {
            if (!b.assignmentStore) {
                b.assignmentStore = c.cloneAssignmentStore(c.task)
            }
            if (!b.resourceStore) {
                b.resourceStore = c.cloneResourceStore(c.task)
            }
            c.assignmentGrid = Ext.create(c.assignmentGridClass, Ext.apply({
                assignmentStore: c.assignmentStore,
                resourceStore: c.resourceStore,
                store: b.assignmentStore,
                resourceDupStore: b.resourceStore,
                tbar: {
                    layout: "auto",
                    items: [{
                        xtype: "button",
                        iconCls: "gnt-action-add",
                        text: c.L("addAssignmentText"),
                        itemId: "add-assignment-btn",
                        handler: function () {
                            c.assignmentGrid.insertAssignment()
                        }
                    }, {
                        xtype: "button",
                        iconCls: "gnt-action-remove",
                        text: c.L("dropAssignmentText"),
                        itemId: "drop-assignment-btn",
                        disabled: true,
                        handler: function () {
                            var d = c.assignmentGrid.getSelectionModel().getSelection();
                            if (d && d.length) {
                                c.assignmentGrid.store.remove(d)
                            }
                        }
                    }]
                },
                listeners: {
                    afterrender: {
                        fn: function (d) {
                            d.loadTaskAssignments(c.task.get(c.task.idProperty))
                        }, single: true
                    }, selectionchange: function (f, e) {
                        var d = c.assignmentGrid;
                        if (!d.dropBtn) {
                            d.dropBtn = d.down("#drop-assignment-btn")
                        }
                        d.dropBtn && d.dropBtn.setDisabled(!e.length)
                    }
                }
            }, c.assignmentGridConfig));
            a.push(c.assignmentGrid)
        }
        if (c.showAdvancedForm) {
            c.advancedFormConfig = c.advancedFormConfig || {};
            c.advancedForm = Ext.create(c.advancedFormClass, Ext.applyIf(c.advancedFormConfig, {
                showGeneral: false,
                showBaseline: false,
                showCalendar: true,
                showManuallyScheduled: true,
                showSchedulingMode: true,
                showWbsCode: true,
                showConstraint: true,
                showRollup: c.showRollup,
                task: c.task,
                taskStore: c.taskStore
            }));
            a.push(c.advancedForm)
        }
        if (c.showNotes) {
            c.notesEditor = Ext.create("Ext.form.field.HtmlEditor", Ext.apply({
                listeners: {
                    afterrender: function (d) {
                        c.notesEditor.setValue(c.task.get(c.task.noteField))
                    }
                }, readOnly: c.task && !c.task.isEditable(c.task.noteField), isDataChanged: function () {
                    return this.isDirty()
                }
            }, c.notesConfig));
            c.notesPanel = Ext.create("Ext.panel.Panel", {border: false, layout: "fit", items: c.notesEditor});
            a.push(c.notesPanel)
        }
        if (!c.taskForm.title) {
            c.taskForm.title = c.L("generalText")
        }
        if (c.dependencyGrid && !c.dependencyGrid.title) {
            c.dependencyGrid.title = c.L("dependencyText")
        }
        if (c.assignmentGrid && !c.assignmentGrid.title) {
            c.assignmentGrid.title = c.L("resourcesText")
        }
        if (c.advancedForm && !c.advancedForm.title) {
            c.advancedForm.title = c.L("advancedText")
        }
        if (c.notesPanel && !c.notesPanel.title) {
            c.notesPanel.title = c.L("notesText")
        }
        return a
    },
    bindDependencyGrid: function () {
        var a = this.clonedStores.dependencyStore;
        var b = this.dependencyGrid;
        b.store.taskStore = this.clonedStores.taskStore;
        if (a) {
            this.mon(b, {
                loaddependencies: function (d, c) {
                    a.loadData(c.getRange().concat(Gnt.util.Data.cloneModelSet(d.oppositeData)))
                }
            });
            this.mon(b.store, {
                add: function (d, c) {
                    a.add(c)
                }, remove: function (d, c) {
                    a.remove(c)
                }
            });
            this.dependencyGridBound = true
        }
    },
    loadTask: function (c) {
        if (!c) {
            return
        }
        this.task = c;
        var f = this, b = f.taskForm, i = f.dependencyGrid, d = f.assignmentGrid;
        b.setSuppressTaskUpdate(true);
        b.getForm().reset();
        f.callParent([c, !i, !d]);
        var h = f.clonedStores, e = f.taskBuffer;
        if (i) {
            if (!f.dependencyGridBound) {
                f.bindDependencyGrid()
            }
            i.loadDependencies(c);
            if (f.allowParentTaskDependencies || c.isLeaf()) {
                i.tab.show()
            } else {
                i.tab.hide()
            }
        }
        if (d) {
            if (h.assignmentStore !== d.getStore()) {
                d.reconfigure(h.assignmentStore)
            }
            if (d.resourceDupStore !== h.resourceStore) {
                d.resourceDupStore = h.resourceStore
            }
            d.loadResources(true);
            d.loadTaskAssignments(c.getId() || c.getPhantomId());
            d.task = e
        }
        b.loadRecord(c, e);
        if (f.advancedForm) {
            f.advancedForm.setSuppressTaskUpdate(true);
            var a = f.advancedForm.getForm();
            a.reset();
            f.advancedForm.loadRecord(c, b.taskBuffer);
            var g = a.findField("wbsCode");
            if (g) {
                g.setValue(c.getWBSCode())
            }
            f.advancedForm.setSuppressTaskUpdate(false)
        }
        b.setSuppressTaskUpdate(false);
        if (f.notesEditor) {
            f.notesEditor.setValue(c.getNote());
            f.notesEditor.setReadOnly(!c.isEditable(c.noteField))
        }
        f.fireEvent("loadtask", f, c)
    },
    doValidate: function (b) {
        var a = this.callParent(arguments);
        if (this.taskForm && !this.taskForm.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.taskForm), this.taskForm)
        }
        if (this.dependencyGrid && !this.dependencyGrid.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.dependencyGrid), this.dependencyGrid)
        }
        if (this.assignmentGrid && !this.assignmentGrid.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.assignmentGrid), this.assignmentGrid)
        }
        if (this.advancedForm && !this.advancedForm.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.advancedForm), this.advancedForm)
        }
        return a
    },
    doUpdateTask: function () {
        this.callParent(arguments);
        this.taskForm && this.taskForm.updateRecord();
        this.advancedForm && this.advancedForm.updateRecord();
        this.notesEditor && this.task.set(this.task.noteField, this.notesEditor.getValue());
        this.assignmentGrid && this.assignmentGrid.saveTaskAssignments();
        this.dependencyGrid && this.dependencyGrid.saveDependencies()
    },
    isDataChanged: function (b) {
        var a = this.callParent(arguments);
        if (this.taskForm && this.taskForm.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.taskForm))
        }
        if (this.dependencyGrid && this.dependencyGrid.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.dependencyGrid))
        }
        if (this.assignmentGrid && this.assignmentGrid.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.assignmentGrid))
        }
        if (this.advancedForm && this.advancedForm.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.advancedForm))
        }
        if (this.notesEditor && this.notesEditor.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.notesEditor))
        }
        return a
    }
});
Ext.define("Gnt.widget.taskeditor.ProjectForm", {
    extend: "Gnt.widget.taskeditor.BaseForm",
    alias: "widget.projectform",
    requires: ["Gnt.model.Project", "Ext.form.FieldSet", "Ext.form.FieldContainer", "Ext.form.field.Text", "Gnt.field.StartDate", "Gnt.field.EndDate", "Ext.form.field.Checkbox"],
    mixins: ["Gnt.mixin.Localizable"],
    alternateClassName: ["Gnt.widget.ProjectForm"],
    showCalendar: false,
    nameConfig: null,
    readOnlyConfig: null,
    allowDependenciesConfig: null,
    startConfig: null,
    finishConfig: null,
    calendarConfig: null,
    constructor: function (b) {
        b = b || {};
        var a = b.taskStore && b.taskStore.projectModel && b.taskStore.projectModel.prototype || Gnt.model.Project.prototype;
        this.fieldNames = {
            calendarIdField: a.calendarIdField,
            allowDependenciesField: a.allowDependenciesField,
            startDateField: a.startDateField,
            endDateField: a.endDateField,
            nameField: a.nameField,
            descriptionField: a.descriptionField
        };
        this.callParent(arguments);
        this.addBodyCls("gnt-projecteditor-projectform")
    },
    buildFields: function () {
        var a = this, b = a.fieldNames;
        a.items = a.items || [];
        a.items.push({
            xtype: "fieldset",
            title: a.L("projectText"),
            layout: "vbox",
            defaults: {allowBlank: false},
            items: [a.initFieldDefinition({
                xtype: "textfield",
                fieldLabel: a.L("nameText"),
                name: b.nameField,
                labelWidth: 110,
                flex: 1,
                value: a.getTaskFieldValue(b.nameField)
            }, a.nameConfig), a.initFieldDefinition({
                xtype: "checkboxfield",
                fieldLabel: a.L("allowDependenciesText"),
                name: b.allowDependenciesField,
                labelWidth: 110,
                flex: 1,
                value: a.getTaskFieldValue(b.allowDependenciesField)
            }, a.allowDependenciesConfig)]
        }, a.initFieldDefinition({
            xtype: "fieldset",
            title: a.L("datesText"),
            layout: "hbox",
            defaults: {labelWidth: 110, allowBlank: false, margin: "5 5 5 0"},
            items: [a.initFieldDefinition({
                xtype: "startdatefield",
                fieldLabel: a.L("startText"),
                width: 260,
                name: b.startDateField,
                value: a.getTaskFieldValue(b.startDateField)
            }, a.startConfig), a.initFieldDefinition({
                xtype: "enddatefield",
                fieldLabel: a.L("finishText"),
                flex: 1,
                labelWidth: 110,
                name: b.endDateField,
                value: a.getTaskFieldValue(b.endDateField)
            }, a.finishConfig)]
        }));
        if (a.showCalendar) {
            a.items.push({
                xtype: "fieldset",
                layout: "hbox",
                defaults: {labelWidth: 110, allowBlank: false, margin: "5 0 5 0"},
                items: [a.initFieldDefinition({
                    xtype: "calendarfield",
                    fieldLabel: this.L("calendarText"),
                    width: 260,
                    name: b.calendarIdField,
                    value: a.getTaskFieldValue(b.calendarIdField)
                }, a.calendarConfig)]
            })
        }
    }
});
Ext.define("Gnt.widget.taskeditor.ProjectEditor", {
    extend: "Gnt.widget.taskeditor.BaseEditor",
    alias: "widget.projecteditor",
    requires: ["Gnt.widget.taskeditor.ProjectForm", "Ext.form.field.HtmlEditor"],
    alternateClassName: ["Gnt.widget.ProjectEditor"],
    eventIndicator: "project",
    projectFormClass: "Gnt.widget.taskeditor.ProjectForm",
    showDescription: true,
    projectFormConfig: null,
    descriptionConfig: null,
    descriptionPanel: null,
    descriptionEditor: null,
    projectForm: null,
    buildItems: function () {
        var b = this, a = [], c = this.task;
        b.projectForm = Ext.create(b.projectFormClass, Ext.applyIf(b.projectFormConfig || {}, {
            task: c,
            taskStore: b.taskStore
        }));
        a.push(b.projectForm);
        if (b.showDescription) {
            b.descriptionEditor = Ext.create("Ext.form.field.HtmlEditor", Ext.apply({
                listeners: {
                    afterrender: function (d) {
                        b.descriptionEditor.setValue(b.task.get(b.task.descriptionField))
                    }
                }, readOnly: c && !c.isEditable(c.descriptionField), isDataChanged: function () {
                    return this.isDirty()
                }
            }, b.descriptionConfig));
            b.descriptionPanel = Ext.create("Ext.panel.Panel", {
                border: false,
                layout: "fit",
                items: b.descriptionEditor
            });
            a.push(b.descriptionPanel)
        }
        if (!b.projectForm.title) {
            b.projectForm.title = b.L("generalText")
        }
        if (b.descriptionPanel && !b.descriptionPanel.title) {
            b.descriptionPanel.title = this.L("descriptionText")
        }
        return a
    },
    loadProject: function (a) {
        this.loadTask.apply(this, arguments)
    },
    loadTask: function (b) {
        if (!b) {
            return
        }
        this.task = b;
        var a = this.projectForm;
        a.setSuppressTaskUpdate(true);
        a.getForm().reset();
        this.callParent(arguments);
        a.loadRecord(b, this.taskBuffer);
        if (this.descriptionEditor) {
            this.descriptionEditor.setValue(b.getDescription());
            this.descriptionEditor.setReadOnly(!b.isEditable(b.descriptionField))
        }
        a.setSuppressTaskUpdate(false);
        this.fireEvent("loadproject", this, b)
    },
    updateProject: function () {
        this.updateTask()
    },
    loadClonedDependencyStore: Ext.emptyFn,
    loadClonedResourceStore: Ext.emptyFn,
    loadClonedAssignmentStore: Ext.emptyFn,
    doValidate: function (b) {
        var a = this.callParent(arguments);
        if (this.projectForm && !this.projectForm.isValid()) {
            a = false;
            b && b(this.getTabByComponent(this.projectForm))
        }
        return a
    },
    doUpdateTask: function () {
        var a = this.task;
        this.callParent(arguments);
        this.projectForm && this.projectForm.updateRecord();
        this.descriptionEditor && a.set(a.descriptionField, this.descriptionEditor.getValue())
    },
    isDataChanged: function (b) {
        var a = this.callParent(arguments);
        if (this.projectForm && this.projectForm.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.projectForm))
        }
        if (this.descriptionEditor && this.descriptionEditor.isDataChanged()) {
            a = true;
            b && b(this.getTabByComponent(this.descriptionEditor))
        }
        return a
    }
});
Ext.define("Gnt.plugin.taskeditor.BaseEditor", {
    extend: "Ext.window.Window",
    requires: ["Ext.window.MessageBox"],
    mixins: ["Ext.AbstractPlugin", "Gnt.mixin.Localizable"],
    lockableScope: "top",
    taskEditorCls: "Gnt.widget.taskeditor.TaskEditor",
    isTaskEditor: true,
    taskEditor: null,
    panelConfig: null,
    height: 340,
    width: 600,
    layout: "card",
    constrain: true,
    triggerEvent: "taskdblclick",
    closeAction: "hide",
    modal: true,
    gantt: null,
    assignmentStore: null,
    resourceStore: null,
    taskStore: null,
    monitorDataUpdates: false,
    monitorDataUpdatesInterval: 500,
    taskEditorConfigs: "l10n,task,taskStore,assignmentStore,resourceStore",
    taskFilters: null,
    constructor: function (a) {
        a = a || {};
        this.taskFilters = [];
        Ext.apply(this, a);
        this.title = this.L("title");
        if (!a.buttons) {
            this.buttons = ["->", {
                itemId: "teOkBtn", text: this.L("okText"), handler: function () {
                    this.completeEditing() || Ext.Msg.alert(this.L("alertCaption"), this.L("alertText"))
                }, scope: this
            }, {text: this.L("cancelText"), handler: this.close, scope: this}]
        }
        this.callParent([a]);
        this.addCls("gnt-taskeditor-window")
    },
    getState: function () {
        if (this.rendered) {
            return this.callParent(arguments)
        }
    },
    init: function (b) {
        this.assignmentStore = this.assignmentStore || b.getAssignmentStore();
        this.resourceStore = this.resourceStore || b.getResourceStore();
        this.taskStore = this.taskStore || b.getTaskStore();
        var a = {width: null, height: null, border: false};
        Ext.copyTo(a, this, this.taskEditorConfigs);
        a.showBaseline = b.enableBaseline;
        a.showRollup = b.showRollupTasks;
        a.allowParentTaskDependencies = b.allowParentTaskDependencies;
        this.buildTaskEditor(Ext.apply(a, this.panelConfig));
        this.add(this.taskEditor);
        this.mon(b, this.triggerEvent, this.onTriggerEvent, this);
        this.gantt = b
    },
    buildTaskEditor: function (a) {
        this.taskEditor = Ext.create(this.taskEditorCls, a);
        this.relayEvents(this.taskEditor, ["loadtask", "validate", "beforeupdatetask", "afterupdatetask"])
    },
    onTriggerEvent: function (b, a) {
        this.showTask(a)
    },
    showTask: function (a) {
        if (this.taskEditor && a && this.matchFilters(a)) {
            this.taskEditor.loadTask(a);
            this.show()
        }
    },
    matchFilters: function (a) {
        if (!a) {
            return
        }
        for (var b = 0; b < this.taskFilters.length; b++) {
            var c = this.taskFilters[b];
            if (!c.fn.call(c.scope, a)) {
                return false
            }
        }
        return true
    },
    addFilter: function (b, a) {
        this.taskFilters.push({fn: b, scope: a || this})
    },
    validate: function () {
        if (this.taskEditor) {
            return this.taskEditor.validate()
        }
    },
    completeEditing: function () {
        if (this.taskEditor) {
            var a = this.taskEditor.getActiveTab();
            if (a.editingPlugin && a.editingPlugin.completeEdit) {
                a.editingPlugin.completeEdit()
            }
            if (!this.taskEditor.validate()) {
                return false
            }
            if (this.taskEditor.updateTask()) {
                this.hide();
                return true
            }
            return false
        }
    },
    updateTask: function () {
        if (this.taskEditor) {
            return this.taskEditor.updateTask()
        }
    },
    afterRender: function () {
        var a = this;
        a.callParent(arguments);
        a.startDataUpdatesMonitoring()
    },
    startDataUpdatesMonitoring: function () {
        var e = this, d = e.down("#teOkBtn"), c = true;

        function b() {
            if (c && d && e.taskEditor) {
                d.setDisabled(!e.taskEditor.isDataChanged() || !e.taskEditor.isDataValid());
                c = Ext.Function.defer(b, e.monitorDataUpdatesInterval)
            }
        }

        function a() {
            c !== true && clearTimeout(c);
            c = true
        }

        if (e.monitorDataUpdates && d) {
            e.on({show: b, hide: a, destroy: a})
        }
    }
});
Ext.define("Gnt.plugin.taskeditor.TaskEditor", {
    extend: "Gnt.plugin.taskeditor.BaseEditor",
    alternateClassName: ["Gnt.plugin.TaskEditor"],
    requires: ["Gnt.widget.taskeditor.TaskEditor"],
    alias: "plugin.gantt_taskeditor",
    ptype: "gantt_taskeditor",
    taskEditorCls: "Gnt.widget.taskeditor.TaskEditor",
    height: 420,
    width: 650,
    taskEditorConfigs: "l10n,task,taskStore,assignmentStore,resourceStore,generalText,resourcesText,dependencyText,addDependencyText,dropDependencyText,notesText,advancedText,wbsCodeText,addAssignmentText,dropAssignmentText,showAssignmentGrid,showDependencyGrid,allowParentTaskDependencies,showNotes,showStyle,showAdvancedForm,taskFormClass,advancedFormClass,taskFormConfig,dependencyGridConfig,assignmentGridConfig,advancedFormConfig,styleFormConfig,dependencyGridClass,assignmentGridClass",
    constructor: function (a) {
        this.callParent(arguments);
        this.addFilter(this.isTask)
    },
    init: function (a) {
        this.callParent(arguments);
        a.taskEditor = this
    },
    isTask: function (a) {
        return a && !a.isProject
    }
});
Ext.define("Gnt.plugin.taskeditor.ProjectEditor", {
    extend: "Gnt.plugin.taskeditor.BaseEditor",
    alternateClassName: ["Gnt.plugin.ProjectEditor"],
    requires: ["Gnt.widget.taskeditor.ProjectEditor"],
    alias: "plugin.gantt_projecteditor",
    ptype: "gantt_projecteditor",
    taskEditorCls: "Gnt.widget.taskeditor.ProjectEditor",
    taskEditorConfigs: "l10n,task,taskStore,assignmentStore,resourceStore,projectFormClass,showDescription,projectFormConfig,descriptionConfig",
    constructor: function (a) {
        this.callParent(arguments);
        this.addCls("gnt-projecteditor-window");
        this.addFilter(this.isProject)
    },
    init: function (a) {
        this.callParent(arguments);
        a.projectEditor = this
    },
    isProject: function (a) {
        return a && a.isProject
    }
});
Ext.define("Gnt.column.Dependency", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.Dependency"],
    separator: ";",
    type: "predecessors",
    field: null,
    useSequenceNumber: false,
    constructor: function (a) {
        a = a || {};
        var b = a.editor;
        delete a.editor;
        Ext.apply(this, a);
        a.editor = b || Ext.create("Gnt.field.Dependency", {
                type: this.type,
                separator: this.separator,
                useSequenceNumber: this.useSequenceNumber
            });
        if (!(a.editor instanceof Gnt.widget.DependencyField)) {
            a.editor = Ext.ComponentManager.create(a.editor, "dependencyfield")
        }
        a.field = a.editor;
        this.scope = this;
        this.callParent([a])
    },
    afterRender: function () {
        var a = this.up("ganttpanel");
        a.registerLockedDependencyListeners();
        this.callParent(arguments)
    },
    getContainingPanel: function () {
        if (!this.panel) {
            this.panel = this.up("tablepanel")
        }
        return this.panel
    },
    setDirtyClass: function (c, b) {
        var a = this.getContainingPanel().getView();
        if (a.markDirty && this.field.isDirty(b)) {
            c.tdCls = a.dirtyCls
        }
    },
    isEditable: function (b) {
        var a = this.gantt || this.up("ganttpanel");
        if (b.isProject) {
            return false
        }
        return !b.isProject && (a && a.allowParentTaskDependencies || b.isLeaf())
    },
    renderer: function (b, c, a) {
        if (!a.isEditable(this.dataIndex) || !this.isEditable(a)) {
            c.tdCls = (c.tdCls || "") + " sch-column-readonly"
        } else {
            this.setDirtyClass(c, a)
        }
        return this.field.getFieldDisplayValue(a)
    }
});
Ext.define("Gnt.column.Successor", {
    extend: "Gnt.column.Dependency",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.successorcolumn", "widget.ganttcolumn.successor"],
    type: "successors",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.Predecessor", {
    extend: "Gnt.column.Dependency",
    mixins: ["Gnt.mixin.Localizable"],
    alias: ["widget.predecessorcolumn", "widget.ganttcolumn.predecessor"],
    type: "predecessors",
    constructor: function (a) {
        a = a || {};
        this.text = a.text || this.L("text");
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.Duration", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.durationcolumn", "widget.ganttcolumn.duration"],
    requires: ["Gnt.field.Duration"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 80,
    align: "left",
    decimalPrecision: 2,
    useAbbreviation: false,
    instantUpdate: true,
    fieldProperty: "durationField",
    fieldConfigs: ["instantUpdate", "useAbbreviation", "decimalPrecision"],
    defaultEditorXType: "durationfield",
    initComponent: function () {
        this.initTaskFieldColumn();
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        if (!Ext.isNumber(b)) {
            return ""
        }
        return this.field.valueToVisible(b, a.getDurationUnit())
    }
});
Ext.define("Gnt.column.Effort", {
    extend: "Gnt.column.Duration",
    alias: ["widget.effortcolumn", "widget.ganttcolumn.effort"],
    requires: ["Gnt.field.Effort"],
    fieldProperty: "effortField",
    defaultEditorXType: "effortfield",
    getValueToRender: function (b, c, a) {
        if (!Ext.isNumber(b)) {
            return ""
        }
        return this.field.valueToVisible(b, a.getEffortUnit())
    }
});
Ext.define("Gnt.column.ConstraintType", {
    extend: "Ext.grid.column.Column",
    requires: ["Gnt.field.ConstraintType"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    alias: ["widget.constrainttypecolumn", "widget.ganttcolumn.constrainttype"],
    width: 100,
    align: "left",
    data: null,
    fieldProperty: "constraintTypeField",
    defaultEditorXType: "constrainttypefield",
    initComponent: function () {
        this.initTaskFieldColumn({store: this.data, taskField: this.fieldProperty});
        this.callParent(arguments)
    }
});
Ext.define("Gnt.column.ConstraintDate", {
    extend: "Ext.grid.column.Date",
    alias: ["widget.constraintdatecolumn", "widget.ganttcolumn.constraintdate"],
    requires: ["Gnt.field.ConstraintDate"],
    mixins: ["Gnt.column.mixin.TaskFieldColumn"],
    width: 100,
    align: "left",
    fieldProperty: "constraintDateField",
    defaultEditorXType: "constraintdatefield",
    initComponent: function () {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat,
            taskField: this.fieldProperty
        });
        this.callParent(arguments)
    },
    getValueToRender: function (b, c, a) {
        return b && Ext.Date.format(this.field.valueToVisible(b, a), this.format) || ""
    }
});
Ext.define("Gnt.widget.Calendar", {
    extend: "Ext.picker.Date",
    alias: "widget.ganttcalendar",
    requires: ["Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    calendar: null,
    startDate: null,
    endDate: null,
    initComponent: function () {
        if (!this.calendar) {
            Ext.Error.raise('Required attribute "calendar" missing during initialization of `Gnt.widget.Calendar`')
        }
        if (!this.startDate) {
            Ext.Error.raise('Required attribute "startDate" missing during initialization of `Gnt.widget.Calendar`')
        }
        if (!this.endDate) {
            this.endDate = Sch.util.Date.add(this.startDate, Sch.util.Date.MONTH, 1)
        }
        this.setCalendar(this.calendar);
        this.minDate = this.value = this.startDate;
        this.callParent(arguments);
        this.injectDates()
    },
    injectDates: function () {
        var a = this;
        var b = a.disabledDates = [];
        Ext.Array.forEach(a.calendar.getHolidaysRanges(a.startDate, a.endDate), function (c) {
            c.forEachDate(function (d) {
                b.push(Ext.Date.format(d, a.format))
            })
        });
        a.setDisabledDates(b)
    },
    setCalendar: function (b) {
        var a = {
            update: this.injectDates,
            remove: this.injectDates,
            add: this.injectDates,
            load: this.injectDates,
            clear: this.injectDates,
            scope: this
        };
        if (this.calendar) {
            this.mun(b, a)
        }
        this.calendar = b;
        if (b) {
            this.mon(b, a)
        }
    }
});
Ext.define("Gnt.widget.calendar.ResourceCalendarGrid", {
    extend: "Ext.grid.Panel",
    requires: ["Ext.data.Store", "Ext.grid.plugin.CellEditing", "Sch.util.Date", "Gnt.model.Calendar", "Gnt.data.Calendar"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.resourcecalendargrid",
    resourceStore: null,
    calendarStore: null,
    cellEditingConfig: null,
    initComponent: function () {
        var b = this;
        this.calendarStore = this.calendarStore || {xclass: "Ext.data.Store", model: "Gnt.model.Calendar"};
        if (!(this.calendarStore instanceof Ext.data.Store)) {
            this.calendarStore = Ext.create(this.calendarStore)
        }
        var a = Ext.create("Ext.grid.plugin.CellEditing", Ext.apply({clicksToEdit: 2}, this.cellEditingConfig));
        this.mon(a, {
            edit: function (c, d) {
                this.onCalendarChange(d.record, d.value)
            }, scope: this
        });
        Ext.apply(b, {
            store: b.resourceStore,
            columns: [{header: this.L("name"), dataIndex: "Name", flex: 1}, {
                header: this.L("calendar"),
                flex: 1,
                renderer: function (e, g, c) {
                    var f = c.getCalendar();
                    var d = b.calendarStore.getModelById ? "getModelById" : "getById";
                    var h = b.calendarStore[d](f && f.calendarId);
                    return h && h.getName() || e
                },
                editor: {
                    xtype: "combobox",
                    store: b.calendarStore,
                    queryMode: "local",
                    displayField: "Name",
                    valueField: "Id",
                    editable: false,
                    allowBlank: false
                }
            }],
            border: true,
            height: 180,
            plugins: a
        });
        this.calendarStore.loadData(this.getCalendarData());
        this.callParent(arguments)
    },
    getCalendarData: function () {
        var a = [];
        Ext.Array.each(Gnt.data.Calendar.getAllCalendars(), function (b) {
            a.push({Id: b.calendarId, Name: b.name || b.calendarId})
        });
        return a
    },
    onCalendarChange: function (a, b) {
        a.setCalendarId(b)
    }
});
Ext.define("Gnt.widget.calendar.AvailabilityGrid", {
    extend: "Ext.grid.Panel",
    requires: ["Ext.Button", "Ext.data.Store", "Ext.grid.plugin.CellEditing", "Ext.window.MessageBox", "Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendaravailabilitygrid",
    calendarDay: null,
    height: 160,
    addButton: null,
    removeButton: null,
    maxIntervalsNum: 5,
    initComponent: function () {
        if (!this.tbar) {
            this.tbar = this.buildToolbar()
        }
        Ext.applyIf(this, {
            store: new Ext.data.Store({
                fields: ["startTime", "endTime"],
                data: this.calendarDay.getAvailability()
            }),
            plugins: [new Ext.grid.plugin.CellEditing({clicksToEdit: 2})],
            columns: [{
                xtype: "datecolumn",
                header: this.L("startText"),
                format: "g:i a",
                dataIndex: "startTime",
                flex: 1,
                editor: {xtype: "timefield", allowBlank: false, initDate: "31/12/1899"}
            }, {
                xtype: "datecolumn",
                header: this.L("endText"),
                format: "g:i a",
                dataIndex: "endTime",
                flex: 1,
                editor: {xtype: "timefield", allowBlank: false, initDate: "31/12/1899"}
            }],
            listeners: {selectionchange: this.onAvailabilityGridSelectionChange, scope: this}
        });
        this.callParent(arguments)
    },
    buildToolbar: function () {
        this.addButton = new Ext.Button({
            text: this.L("addText"),
            iconCls: "gnt-action-add",
            handler: this.addAvailability,
            scope: this
        });
        this.removeButton = new Ext.Button({
            text: this.L("removeText"),
            iconCls: "gnt-action-remove",
            handler: this.removeAvailability,
            scope: this,
            disabled: true
        });
        return [this.addButton, this.removeButton]
    },
    onAvailabilityGridSelectionChange: function (a) {
        this.removeButton.setDisabled(!a || a.getSelection().length === 0)
    },
    setAvailability: function (a) {
        this.store.loadData(a);
        this.addButton.setDisabled(this.store.getCount() >= this.maxIntervalsNum)
    },
    addAvailability: function () {
        var a = this.getStore(), b = a.count();
        if (b >= this.maxIntervalsNum) {
            return
        }
        a.add({startTime: new Date(0, 0, 0, 12, 0), endTime: new Date(0, 0, 0, 13, 0)});
        if (b + 1 >= this.maxIntervalsNum && this.addButton) {
            this.addButton.disable()
        }
    },
    removeAvailability: function () {
        var a = this.getStore(), c = a.getCount(), b = this.getSelectionModel().getSelection();
        if (b.length === 0) {
            return
        }
        a.remove(b[0]);
        if (c < this.maxIntervalsNum && this.addButton) {
            this.addButton.enable()
        }
    },
    isValid: function (b) {
        try {
            this.calendarDay.verifyAvailability(this.getIntervals())
        } catch (a) {
            if (!b) {
                Ext.MessageBox.show({
                    title: this.L("error"),
                    msg: a,
                    modal: true,
                    icon: Ext.MessageBox.ERROR,
                    buttons: Ext.MessageBox.OK
                })
            }
            return false
        }
        return true
    },
    extractTimeFromDate: function (a) {
        return new Date(0, 0, 0, a.getHours(), a.getMinutes(), a.getSeconds())
    },
    getIntervals: function () {
        var a = [];
        var b = this;
        this.getStore().each(function (d) {
            var c = b.extractTimeFromDate(d.get("endTime"));
            if (c - new Date(0, 0, 0, 0, 0, 0) === 0) {
                c = new Date(0, 0, 1, 0, 0)
            }
            a.push({startTime: b.extractTimeFromDate(d.get("startTime")), endTime: c})
        });
        return a
    }
});
Ext.define("Gnt.widget.calendar.DayEditor", {
    extend: "Gnt.widget.calendar.AvailabilityGrid",
    requires: ["Ext.grid.plugin.CellEditing", "Gnt.data.Calendar", "Sch.util.Date"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendardayeditor",
    height: 160,
    initComponent: function () {
        var a = this.calendarDay.getIsWorkingDay();
        this.dockedItems = this.dockedItems || [{
                xtype: "radiogroup",
                dock: "top",
                name: "dayType",
                padding: "0 5px",
                margin: 0,
                items: [{
                    boxLabel: this.L("workingTimeText"),
                    name: "IsWorkingDay",
                    inputValue: true,
                    checked: a
                }, {boxLabel: this.L("nonworkingTimeText"), name: "IsWorkingDay", inputValue: false, checked: !a}],
                listeners: {change: this.onDayTypeChanged, scope: this}
            }];
        this.on("afterrender", this.myApplyState, this);
        this.callParent(arguments)
    },
    getDayTypeRadioGroup: function () {
        return this.down('radiogroup[name="dayType"]')
    },
    myApplyState: function () {
        if (!this.isWorkingDay()) {
            this.viewSetDisabled(true);
            this.addButton.disable()
        }
    },
    viewSetDisabled: function (a) {
        if (a) {
            this.getView().getEl().mask();
            this.headerCt.getEl().mask()
        } else {
            this.getView().getEl().unmask();
            this.headerCt.getEl().unmask()
        }
    },
    onDayTypeChanged: function (a) {
        var b = a.getValue();
        if (Ext.isArray(b.IsWorkingDay)) {
            return
        }
        this.viewSetDisabled(!b.IsWorkingDay);
        this.addButton.setDisabled(!b.IsWorkingDay || this.getStore().getCount() >= this.maxIntervalsNum)
    },
    isWorkingDay: function () {
        return this.getDayTypeRadioGroup().getValue().IsWorkingDay
    },
    isValid: function () {
        if (this.isWorkingDay()) {
            return this.callParent()
        }
        return true
    },
    getIntervals: function () {
        if (!this.isWorkingDay()) {
            return []
        }
        return this.callParent()
    }
});
Ext.define("Gnt.widget.calendar.WeekEditor", {
    extend: "Ext.form.Panel",
    requires: ["Ext.grid.Panel", "Gnt.data.Calendar", "Sch.util.Date", "Gnt.widget.calendar.AvailabilityGrid"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarweekeditor",
    weekName: null,
    startDate: null,
    endDate: null,
    weekAvailability: null,
    calendarWeekAvailability: null,
    defaultWeekAvailability: null,
    backupWeekAvailability: null,
    layout: "anchor",
    defaults: {border: false, anchor: "100%"},
    calendarDayModel: null,
    currentDayIndex: null,
    _weekDaysGrid: null,
    _availabilityGrid: null,
    initComponent: function () {
        this.backupWeekAvailability = [];
        this.items = [{
            xtype: "radiogroup",
            padding: "0 5px",
            name: "dayType",
            items: [{
                boxLabel: this.L("defaultTimeText"),
                name: "IsWorkingDay",
                inputValue: 0
            }, {
                boxLabel: this.L("workingTimeText"),
                name: "IsWorkingDay",
                inputValue: 1
            }, {boxLabel: this.L("nonworkingTimeText"), name: "IsWorkingDay", inputValue: 2}],
            listeners: {change: this.onDayTypeChanged, scope: this}
        }, {
            layout: "column",
            padding: "0 0 5px 0",
            defaults: {border: false},
            items: [{margin: "0 10px 0 5px", columnWidth: 0.5, items: this.getWeekDaysGrid()}, {
                columnWidth: 0.5,
                margin: "0 5px 0 0",
                items: this.getAvailabilityGrid()
            }]
        }];
        this.callParent(arguments)
    },
    getWeekDaysGrid: function () {
        if (this._weekDaysGrid != null) {
            return this._weekDaysGrid
        }
        var a = Ext.Date.dayNames;
        return this._weekDaysGrid = new Ext.grid.Panel({
            hideHeaders: true,
            height: 160,
            columns: [{header: "", dataIndex: "name", flex: 1}],
            store: new Ext.data.Store({
                fields: ["id", "name"],
                idProperty: "id",
                data: [{id: 1, name: a[1]}, {id: 2, name: a[2]}, {id: 3, name: a[3]}, {id: 4, name: a[4]}, {
                    id: 5,
                    name: a[5]
                }, {id: 6, name: a[6]}, {id: 0, name: a[0]}]
            }),
            listeners: {
                viewready: this.onWeekDaysListViewReady,
                selectionchange: this.onWeekDaysListSelectionChange,
                beforeselect: this.onWeekDaysListBeforeSelect,
                scope: this
            }
        })
    },
    getAvailabilityGrid: function () {
        if (!this._availabilityGrid) {
            this._availabilityGrid = new Gnt.widget.calendar.AvailabilityGrid({calendarDay: new this.calendarDayModel()})
        }
        return this._availabilityGrid
    },
    getDayTypeRadioGroup: function () {
        if (!this.dayTypeRadioGroup) {
            this.dayTypeRadioGroup = this.down('radiogroup[name="dayType"]')
        }
        return this.dayTypeRadioGroup
    },
    getWeekAvailability: function () {
        return this.weekAvailability
    },
    onWeekDaysListViewReady: function () {
        var b = this.getWeekDaysGrid(), a = b.getStore().getAt(0);
        this.currentDayIndex = a.getId();
        this.readFromData();
        b.getSelectionModel().select(a, false, true)
    },
    onWeekDaysListBeforeSelect: function () {
        if (!this.saveToData()) {
            return false
        }
    },
    applyChanges: function (e) {
        if (!this.saveToData()) {
            return false
        }
        var b = this.weekAvailability;
        var d = false;
        for (var c = 0; c < 7; c++) {
            var a = b[c];
            if (a) {
                d = true
            }
            if (!a) {
                e[c] = null
            }
            if (a && !e[c]) {
                e[c] = a
            }
            if (a && e[c]) {
                e[c].setIsWorkingDay(a.getIsWorkingDay());
                e[c].setAvailability(a.getAvailability())
            }
        }
        if (!d) {
            Ext.MessageBox.show({
                title: this.L("error"),
                msg: this.L("noOverrideError"),
                modal: true,
                icon: Ext.MessageBox.ERROR,
                buttons: Ext.MessageBox.OK
            });
            return false
        }
        return true
    },
    onWeekDaysListSelectionChange: function (a, b) {
        this.currentDayIndex = b[0].getId();
        this.readFromData()
    },
    getCurrentTypeOfWeekDay: function (a) {
        return this.weekAvailability[a] ? (this.weekAvailability[a].getIsWorkingDay() ? 1 : 2) : 0
    },
    getCurrentWeekDay: function (a) {
        return this.weekAvailability[a] || this.calendarWeekAvailability[a] || this.defaultWeekAvailability[a]
    },
    saveToData: function () {
        var c = this.currentDayIndex;
        var d = this.getDayTypeRadioGroup().getValue().IsWorkingDay;
        var a = this.weekAvailability;
        if (d === 0) {
            a[c] = null;
            return true
        }
        var b = this.getAvailabilityGrid();
        if (d == 1) {
            if (!b.isValid()) {
                return false
            }
            if (!a[c]) {
                a[c] = this.copyDefaultWeekDay(c)
            }
            a[c].setIsWorkingDay(true);
            a[c].setAvailability(b.getIntervals());
            this.backupWeekAvailability[c] = null;
            return true
        }
        if (!a[c]) {
            a[c] = this.copyDefaultWeekDay(c)
        }
        a[c].setIsWorkingDay(false);
        a[c].setAvailability([]);
        return true
    },
    copyDefaultWeekDay: function (a) {
        var b = (this.calendarWeekAvailability[a] || this.defaultWeekAvailability[a]).copy();
        b.setType("WEEKDAYOVERRIDE");
        b.setOverrideStartDate(this.startDate);
        b.setOverrideEndDate(this.endDate);
        b.setName(this.weekName);
        return b
    },
    readFromData: function (b) {
        var a = this.getCurrentWeekDay(this.currentDayIndex);
        var d = this.getCurrentTypeOfWeekDay(this.currentDayIndex);
        var c = this.getAvailabilityGrid();
        c.setAvailability(b || a.getAvailability());
        var e = this.getDayTypeRadioGroup();
        e.suspendEvents();
        e.setValue({IsWorkingDay: [d]});
        e.resumeEvents();
        c.setDisabled(d != 1)
    },
    onDayTypeChanged: function (d, b, a) {
        var g = d.getValue();
        if (g.IsWorkingDay == null || Ext.isArray(g.IsWorkingDay)) {
            return
        }
        var e = this.weekAvailability;
        var f = this.backupWeekAvailability;
        var h = this.currentDayIndex;
        var c = this.getAvailabilityGrid();
        var i;
        if (a.IsWorkingDay == 1) {
            f[h] = c.getIntervals()
        }
        switch (g.IsWorkingDay) {
            case 0:
                e[h] = null;
                break;
            case 1:
                if (!e[h]) {
                    e[h] = this.copyDefaultWeekDay(h)
                }
                i = f[h];
                e[h].setIsWorkingDay(true);
                break;
            case 2:
                if (!e[h]) {
                    e[h] = this.copyDefaultWeekDay(h)
                }
                e[h].setAvailability([]);
                e[h].setIsWorkingDay(false);
                break;
            default:
                throw"Unrecognized day type"
        }
        this.readFromData(i)
    }
});
Ext.define("Gnt.widget.calendar.DatePicker", {
    extend: "Ext.picker.Date",
    alias: "widget.gntdatepicker",
    workingDayCls: "gnt-datepicker-workingday",
    nonWorkingDayCls: "gnt-datepicker-nonworkingday",
    overriddenDayCls: "gnt-datepicker-overriddenday",
    overriddenWeekDayCls: "gnt-datepicker-overriddenweekday",
    weekOverridesStore: null,
    dayOverridesCalendar: null,
    update: function () {
        this.callParent(arguments);
        this.refreshCssClasses()
    },
    refreshCssClasses: function () {
        var d = this, b = d.cells.elements;
        this.removeCustomCls();
        for (var c = 0; c < d.numDays; c++) {
            var a = b[c].firstChild.dateValue;
            b[c].className += " " + this.getDateCls(new Date(a))
        }
    },
    getDateCls: function (e) {
        var b = "";
        if (e.getMonth() !== this.getActive().getMonth()) {
            return
        }
        var c = this.dayOverridesCalendar;
        if (c.getOwnCalendarDay(e)) {
            b += " " + this.overriddenDayCls;
            if (!c.isWorkingDay(e)) {
                b += " " + this.nonWorkingDayCls
            }
        } else {
            var f = null;
            this.weekOverridesStore.each(function (g) {
                if (Ext.Date.between(e, g.get("startDate"), g.get("endDate"))) {
                    f = g;
                    return false
                }
            });
            if (f) {
                b += " " + this.overriddenWeekDayCls;
                var d = e.getDay(), a = f.get("weekAvailability");
                if (a && a[d] && !a[d].getIsWorkingDay()) {
                    b += " " + this.nonWorkingDayCls
                }
            } else {
                if (!c.isWorkingDay(e)) {
                    b += " " + this.nonWorkingDayCls
                }
            }
        }
        return b || this.workingDayCls
    },
    removeCustomCls: function () {
        this.cells.removeCls([this.overriddenDayCls, this.nonWorkingDayCls, this.workingDayCls, this.overriddenWeekDayCls])
    }
});
Ext.define("Gnt.widget.calendar.Calendar", {
    extend: "Ext.form.Panel",
    requires: ["Ext.XTemplate", "Ext.data.Store", "Ext.grid.Panel", "Ext.grid.plugin.CellEditing", "Ext.layout.container.HBox", "Ext.layout.container.Column", "Ext.layout.container.Fit", "Gnt.data.Calendar", "Gnt.model.Week", "Gnt.widget.calendar.DayEditor", "Gnt.widget.calendar.WeekEditor", "Gnt.widget.calendar.DatePicker"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendar",
    defaults: {padding: 10, border: false},
    workingDayCls: "gnt-datepicker-workingday",
    nonWorkingDayCls: "gnt-datepicker-nonworkingday",
    overriddenDayCls: "gnt-datepicker-overriddenday",
    overriddenWeekDayCls: "gnt-datepicker-overriddenweekday",
    calendar: null,
    calendarManager: null,
    dayGridConfig: null,
    weekGridConfig: null,
    datePickerConfig: null,
    dayGrid: null,
    weekGrid: null,
    datePicker: null,
    legendTpl: '<ul class="gnt-calendar-legend"><li class="gnt-calendar-legend-item"><div class="gnt-calendar-legend-itemstyle {workingDayCls}"></div><span class="gnt-calendar-legend-itemname">{workingDayText}</span><div style="clear: both"></div></li><li><div class="gnt-calendar-legend-itemstyle {nonWorkingDayCls}"></div><span class="gnt-calendar-legend-itemname">{weekendsText}</span><div style="clear: both"></div></li><li class="gnt-calendar-legend-override"><div class="gnt-calendar-legend-itemstyle {overriddenDayCls}">31</div><span class="gnt-calendar-legend-itemname">{overriddenDayText}</span><div style="clear: both"></div></li><li class="gnt-calendar-legend-override"><div class="gnt-calendar-legend-itemstyle {overriddenWeekDayCls}">31</div><span class="gnt-calendar-legend-itemname">{overriddenWeekText}</span><div style="clear: both"></div></li></ul>',
    dateInfoTpl: null,
    dayOverridesCalendar: null,
    weekOverridesStore: null,
    copiesIndexByOriginalId: null,
    currentDayOverrideEditor: null,
    calendarDayModel: null,
    layout: {type: "vbox", align: "stretch"},
    initComponent: function () {
        var a = this;
        a.copiesIndexByOriginalId = {};
        a.setupTemplates();
        var b = a.calendar;
        if (!b && a.calendarManager) {
            b = a.calendarManager.getProjectCalendar() || a.calendarManager.getRoot().firstChild
        }
        if (!a.calendarDayModel) {
            a.calendarDayModel = b && b.getModel && b.getModel() || b.model
        }
        a.buildItems();
        a.bindListeners();
        a.callParent(arguments);
        a.calendar && a.setCalendar(a.calendar)
    },
    bindListeners: function () {
        var a = this;
        a.on("calendarset", a.onCalendarSet);
        a.on("afterrender", a.onCalendarSet);
        a.dayGrid.on({
            selectionchange: a.onDayGridSelectionChange,
            validateedit: a.onDayGridValidateEdit,
            edit: a.onDayGridEdit,
            scope: a
        });
        a.dayGrid.store.on({update: a.refreshView, remove: a.refreshView, add: a.refreshView, scope: a});
        a.weekGrid.on({
            selectionchange: a.onWeekGridSelectionChange,
            validateedit: a.onWeekGridValidateEdit,
            edit: a.onWeekGridEdit,
            scope: a
        });
        a.weekGrid.store.on({update: a.refreshView, remove: a.refreshView, add: a.refreshView, scope: a});
        a.datePicker.on({select: a.onDateSelect, scope: a})
    },
    buildItems: function () {
        this.dateInfoPanel = new Ext.Panel({
            cls: "gnt-calendar-dateinfo",
            padding: "10 10 10 10",
            columnWidth: 0.33,
            border: false,
            height: 200
        });
        this.cmbParentCalendar = new Ext.form.field.ComboBox({
            name: "cmb_parentCalendar",
            fieldLabel: this.L("parentCalendarText"),
            store: new Ext.data.Store({fields: ["Id", "Name"]}),
            queryMode: "local",
            displayField: "Name",
            valueField: "Id",
            editable: false,
            emptyText: this.L("selectParentText"),
            flex: 1
        });
        this.buildWeekGrid();
        this.buildDayGrid();
        this.buildDatePicker();
        this.items = [{
            xtype: "container",
            layout: "hbox",
            pack: "start",
            align: "stretch",
            items: [{
                xtype: "textfield",
                itemId: "calendarName",
                fieldLabel: this.L("calendarNameText"),
                margin: "0 10 0 0",
                flex: 1
            }, this.cmbParentCalendar]
        }, {
            layout: "column",
            padding: "10 10 0 10",
            defaults: {border: false},
            items: [{
                columnWidth: 0.3,
                html: this.legendTpl.apply({
                    workingDayText: this.L("workingDayText"),
                    weekendsText: this.L("weekendsText"),
                    overriddenDayText: this.L("overriddenDayText"),
                    overriddenWeekText: this.L("overriddenWeekText"),
                    workingDayCls: this.workingDayCls,
                    nonWorkingDayCls: this.nonWorkingDayCls,
                    overriddenDayCls: this.overriddenDayCls,
                    overriddenWeekDayCls: this.overriddenWeekDayCls
                })
            }, {
                columnWidth: 0.37,
                layout: {type: "hbox", pack: "center"},
                items: [this.datePicker]
            }, this.dateInfoPanel]
        }, {xtype: "tabpanel", padding: "10 10 10 10", flex: 1, items: [this.dayGrid, this.weekGrid]}]
    },
    buildDayGrid: function () {
        var a = this.calendarDayModel.prototype;
        this.dayGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L("dayOverridesText"),
            itemId: "dayGrid",
            tbar: [{
                text: this.L("addText"),
                itemId: "btnAdd",
                action: "add",
                iconCls: "gnt-action-add",
                handler: this.addDay,
                scope: this
            }, {
                text: this.L("editText"),
                itemId: "btnEdit",
                action: "edit",
                iconCls: "gnt-action-edit",
                handler: this.editDay,
                scope: this
            }, {
                text: this.L("removeText"),
                itemId: "btnRemove",
                action: "remove",
                iconCls: "gnt-action-remove",
                handler: this.removeDay,
                scope: this
            }],
            store: new Gnt.data.Calendar(),
            plugins: [new Ext.grid.plugin.CellEditing({clicksToEdit: 2})],
            columns: [{
                header: this.L("dayOverrideNameHeaderText"),
                dataIndex: a.nameField,
                flex: 1,
                editor: {allowBlank: false}
            }, {
                header: this.L("dateText"),
                dataIndex: a.dateField,
                width: 100,
                xtype: "datecolumn",
                editor: {xtype: "datefield"}
            }]
        }, this.dayGridConfig || {}));
        this.dayOverridesCalendar = this.dayGrid.store
    },
    updateGrids: function () {
        this.dayGrid && this.fillDaysStore();
        this.weekGrid && this.fillWeeksStore()
    },
    buildWeekGrid: function () {
        this.weekGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L("weekOverridesText"),
            border: true,
            itemId: "weekGrid",
            plugins: [new Ext.grid.plugin.CellEditing({clicksToEdit: 2})],
            store: new Ext.data.Store({model: "Gnt.model.Week"}),
            tbar: [{
                text: this.L("addText"),
                itemId: "btnAdd",
                action: "add",
                iconCls: "gnt-action-add",
                handler: this.addWeek,
                scope: this
            }, {
                text: this.L("editText"),
                itemId: "btnEdit",
                action: "edit",
                iconCls: "gnt-action-edit",
                handler: this.editWeek,
                scope: this
            }, {
                text: this.L("removeText"),
                itemId: "btnRemove",
                action: "remove",
                iconCls: "gnt-action-remove",
                handler: this.removeWeek,
                scope: this
            }],
            columns: [{
                header: this.L("overrideName"),
                dataIndex: "name",
                flex: 1,
                editor: {allowBlank: false}
            }, {
                xtype: "datecolumn",
                header: this.L("startDate"),
                dataIndex: "startDate",
                width: 100,
                editor: {xtype: "datefield"}
            }, {
                xtype: "datecolumn",
                header: this.L("endDate"),
                dataIndex: "endDate",
                width: 100,
                editor: {xtype: "datefield"}
            }]
        }, this.weekGridConfig || {}));
        this.weekOverridesStore = this.weekGrid.store
    },
    buildDatePicker: function () {
        this.datePicker = new Gnt.widget.calendar.DatePicker(Ext.apply({
            dayOverridesCalendar: this.dayGrid.store,
            weekOverridesStore: this.weekGrid.store
        }, this.datePickerConfig))
    },
    onCalendarSet: function (a) {
        this.weekOverridesStore.commitChanges()
    },
    setCalendar: function (a) {
        if (this.calendar) {
            this.mun(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            })
        }
        this.calendar = a;
        if (a) {
            this.mon(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            })
        }
        this.onCalendarChange();
        this.fireEvent("calendarset", a)
    },
    onParentChange: function () {
        this.updateComboBox()
    },
    updateComboBox: function () {
        var c = this, f = [];
        if (c.calendarManager) {
            var a = c.calendarManager.getRoot();
            var d = c.calendarManager.getNodeByCalendar(c.calendar);
            a.cascadeBy(function (g) {
                var h = g.getCalendar();
                if (g !== a && g !== d && !d.contains(g)) {
                    f.push({Id: h.calendarId, Name: g.getName() || h.calendarId})
                }
            })
        } else {
            f = c.calendar.getParentableCalendars()
        }
        this.cmbParentCalendar.store.loadData([{Id: -1, Name: this.L("noParentText")}].concat(f));
        var b = this.calendar && this.calendar.parent, e = b && b.calendarId;
        this.cmbParentCalendar.setValue(e || -1);
        Ext.isIE10p && this.cmbParentCalendar.doQueryTask.cancel()
    },
    onCalendarChange: function () {
        this.updateComboBox();
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView()
    },
    setupTemplates: function () {
        var a = this.L("tplTexts");
        if (!this.dateInfoTpl) {
            this.dateInfoTpl = Ext.String.format('<div class="gnt-calendar-overridedate"><tpl if="isWorkingDay">' + a.tplWorkingHours + " {date}:<tpl else>{date} " + a.tplIsNonWorking + '</tpl></div><ul class="gnt-calendar-availabilities"><tpl for="availability"><li>{.}</li></tpl></ul><span class="gnt-calendar-overridesource">' + a.tplBasedOn + ': <tpl if="override">' + a.tplOverride + ' "{name}" ' + a.tplInCalendar + ' "{calendarName}"<tpl else>' + a.tplDayInCalendar + ' "{calendarName}"</tpl></span>')
        }
        if (!(this.dateInfoTpl instanceof Ext.Template)) {
            this.dateInfoTpl = new Ext.XTemplate(this.dateInfoTpl)
        }
        if (!(this.legendTpl instanceof Ext.Template)) {
            this.legendTpl = new Ext.XTemplate(this.legendTpl)
        }
    },
    afterRender: function () {
        this.callParent(arguments);
        this.onDateSelect(this.datePicker, new Date())
    },
    fillDaysStore: function () {
        var a = Gnt.util.Data.cloneModelSet(this.calendar, function (b) {
            return (b.getType() == "DAY" && b.getDate())
        });
        this.dayOverridesCalendar.loadData(a)
    },
    copyCalendarDay: function (a) {
        var b = a.copy(null);
        b.__COPYOF__ = a.getId();
        this.copiesIndexByOriginalId[a.getId()] = b.getId();
        return b
    },
    fillWeeksStore: function () {
        var a = this;
        var b = [];
        this.calendar.forEachNonStandardWeek(function (c) {
            var d = Ext.apply({}, c);
            d.weekAvailability = Ext.Array.map(d.weekAvailability, function (e) {
                return e && a.copyCalendarDay(e) || null
            });
            d.mainDay = a.copyCalendarDay(d.mainDay);
            b.push(d)
        });
        this.weekOverridesStore.loadData(b)
    },
    addDay: function () {
        var a = this.datePicker.getValue();
        if (this.dayOverridesCalendar.getOwnCalendarDay(a)) {
            this.alert({msg: this.L("overrideErrorText")});
            return
        }
        var b = new this.calendar.model({Name: this.L("newDayName"), Type: "DAY", Date: a, IsWorkingDay: false});
        this.dayGrid.getStore().insert(0, b);
        this.dayGrid.getSelectionModel().select([b], false, false)
    },
    editDay: function () {
        var e = this, c = this.dayGrid.getSelectionModel().getSelection();
        if (c.length === 0) {
            return
        }
        var a = c[0];
        var b = this.currentDayOverrideEditor = new Gnt.widget.calendar.DayEditor({
            addText: this.L("addText"),
            removeText: this.L("removeText"),
            workingTimeText: this.L("workingTimeText"),
            nonworkingTimeText: this.L("nonworkingTimeText"),
            calendarDay: a
        });
        var d = Ext.create("Ext.window.Window", {
            title: this.L("dayOverridesText"),
            modal: true,
            width: 280,
            height: 260,
            layout: "fit",
            items: b,
            buttons: [{
                text: this.L("okText"), handler: function () {
                    if (b.isValid()) {
                        var f = b.calendarDay;
                        f.setIsWorkingDay(b.isWorkingDay());
                        f.setAvailability(b.getIntervals());
                        e.applyCalendarDay(f, a);
                        e.refreshView();
                        d.close()
                    }
                }
            }, {
                text: this.L("cancelText"), handler: function () {
                    d.close()
                }
            }]
        });
        d.show()
    },
    removeDay: function () {
        var a = this.dayGrid, b = a.getSelectionModel().getSelection();
        if (!b.length) {
            return
        }
        a.getStore().remove(b[0]);
        this.refreshView()
    },
    refreshView: function () {
        var f = this.datePicker.getValue(), b = this.getCalendarDay(f), e = this.weekGrid, a = this.dayGrid, d = this.dayOverridesCalendar.getOwnCalendarDay(f), h;
        var c;
        if (d) {
            a.getSelectionModel().select([d], false, true);
            c = d.getName()
        } else {
            h = this.getWeekOverrideByDate(f);
            if (h) {
                e.getSelectionModel().select([h], false, true);
                c = h.get("name")
            }
        }
        var g = {
            name: c || b.getName(),
            date: Ext.Date.format(f, "M j, Y"),
            calendarName: this.calendar.name || this.calendar.calendarId,
            availability: b.getAvailability(true),
            override: Boolean(d || h),
            isWorkingDay: b.getIsWorkingDay()
        };
        this.dateInfoPanel.update(this.dateInfoTpl.apply(g));
        this.down("#calendarName").setValue(this.calendar.name);
        this.datePicker.rendered && this.datePicker.refreshCssClasses()
    },
    onDayGridSelectionChange: function (b) {
        if (b.getSelection().length === 0) {
            return
        }
        var a = b.getSelection()[0];
        this.datePicker.setValue(a.getDate());
        this.refreshView()
    },
    onDayGridEdit: function (b, a) {
        if (a.field === "Date") {
            a.grid.getStore().clearCache();
            this.datePicker.setValue(a.value)
        }
        this.refreshView()
    },
    onDayGridValidateEdit: function (b, a) {
        var c = this.dayGrid.store;
        if (a.field === c.model.prototype.dateField && c.getOwnCalendarDay(a.value) && a.value !== a.originalValue) {
            this.alert({msg: this.L("overrideErrorText")});
            return false
        }
    },
    onDateSelect: function (b, a) {
        this.refreshView()
    },
    getCalendarDay: function (b) {
        var a = this.dayOverridesCalendar.getOwnCalendarDay(b);
        if (a) {
            return a
        }
        a = this.getWeekOverrideDay(b);
        if (a) {
            return a
        }
        return this.calendar.weekAvailability[b.getDay()] || this.calendar.defaultWeekAvailability[b.getDay()]
    },
    getWeekOverrideDay: function (d) {
        var e = new Date(d), b = this.getWeekOverrideByDate(d), c = e.getDay();
        if (b == null) {
            return null
        }
        var a = b.get("weekAvailability");
        if (!a) {
            return null
        }
        return a[c]
    },
    getWeekOverrideByDate: function (a) {
        var b = null;
        this.weekOverridesStore.each(function (c) {
            if (Ext.Date.between(a, c.get("startDate"), c.get("endDate"))) {
                b = c;
                return false
            }
        });
        return b
    },
    intersectsWithCurrentWeeks: function (b, d, c) {
        var a = false;
        this.weekOverridesStore.each(function (f) {
            if (f == c) {
                return
            }
            var e = f.get("startDate");
            var g = f.get("endDate");
            if (e <= b && b < g || e < d && d <= g) {
                a = true;
                return false
            }
        });
        return a
    },
    addWeek: function () {
        var c = this.weekOverridesStore;
        var a = this.datePicker.getValue();
        var f;
        for (var e = 7; e > 0; e--) {
            f = Sch.util.Date.add(a, Sch.util.Date.DAY, e);
            if (!this.intersectsWithCurrentWeeks(a, f)) {
                break
            }
        }
        if (!e) {
            this.alert({msg: Ext.String.format(this.L("overrideDateError"), Ext.Date.format(a, "Y/m/d"))});
            return
        }
        var d = new this.calendar.model();
        d.setType("WEEKDAYOVERRIDE");
        d.setName(this.L("newDayName"));
        d.setOverrideStartDate(a);
        d.setOverrideEndDate(f);
        d.setWeekday(-1);
        var b = c.insert(0, {
            name: this.L("newDayName"),
            startDate: a,
            endDate: f,
            weekAvailability: [],
            mainDay: d
        })[0];
        this.weekGrid.getSelectionModel().select([b], false, false)
    },
    editWeek: function () {
        var c = this.weekGrid.getSelectionModel().getSelection(), e = this;
        if (c.length === 0) {
            return
        }
        var b = c[0];
        var a = new Gnt.widget.calendar.WeekEditor({
            startDate: b.get("startDate"),
            endDate: b.get("endDate"),
            weekName: b.get("name"),
            calendarDayModel: this.calendar.model,
            weekAvailability: b.get("weekAvailability"),
            calendarWeekAvailability: this.calendar.weekAvailability,
            defaultWeekAvailability: this.calendar.defaultWeekAvailability
        });
        var d = Ext.create("Ext.window.Window", {
            title: this.L("weekOverridesText"),
            modal: true,
            width: 370,
            defaults: {border: false},
            layout: "fit",
            items: a,
            buttons: [{
                action: "ok", text: this.L("okText"), handler: function () {
                    if (a.applyChanges(b.get("weekAvailability"))) {
                        e.refreshView();
                        d.close()
                    }
                }
            }, {
                text: this.L("cancelText"), handler: function () {
                    d.close()
                }
            }]
        });
        d.show()
    },
    removeWeek: function () {
        var a = this.weekGrid.getSelectionModel().getSelection();
        if (a.length === 0) {
            return
        }
        this.weekOverridesStore.remove(a[0]);
        this.refreshView()
    },
    onWeekGridSelectionChange: function (a) {
        var b = a.getSelection();
        if (b.length === 0) {
            return
        }
        this.datePicker.setValue(b[0].get("startDate"))
    },
    onWeekGridEdit: function (d, b) {
        var c = b.record, a = c.get("startDate"), e = c.get("endDate");
        if (b.field == "startDate" || b.field == "endDate") {
            Ext.Array.each(c.get("weekAvailability").concat(c.get("mainDay")), function (f) {
                if (f) {
                    f.setOverrideStartDate(a);
                    f.setOverrideEndDate(e)
                }
            });
            this.datePicker.setValue(a)
        }
        this.refreshView()
    },
    alert: function (a) {
        a = a || {};
        Ext.MessageBox.show(Ext.applyIf(a, {
            title: this.L("error"),
            icon: Ext.MessageBox.WARNING,
            buttons: Ext.MessageBox.OK
        }))
    },
    onWeekGridValidateEdit: function (d, b) {
        var c = b.record, a = b.field == "startDate" ? b.value : c.get("startDate"), e = b.field == "endDate" ? b.value : c.get("endDate");
        if (a > e) {
            this.alert({msg: this.L("startAfterEndError")});
            return false
        }
        if (this.intersectsWithCurrentWeeks(a, e, c)) {
            this.alert({msg: this.L("weeksIntersectError")});
            return false
        }
    },
    applyCalendarDay: function (d, c) {
        c.beginEdit();
        c.setName(d.getName());
        c.setIsWorkingDay(d.getIsWorkingDay());
        c.setDate(d.getDate());
        c.setOverrideStartDate(d.getOverrideStartDate());
        c.setOverrideEndDate(d.getOverrideEndDate());
        var b = d.getAvailability(true);
        var a = c.getAvailability(true);
        if (b + "" != a + "") {
            c.setAvailability(d.getAvailability())
        }
        c.endEdit()
    },
    applySingleDay: function (b, a) {
        if (b.__COPYOF__) {
            this.applyCalendarDay(b, this.calendar.getModelByInternalId(b.__COPYOF__))
        } else {
            if (b.joined) {
                b.unjoin(b.joined[0])
            }
            a.push(b)
        }
    },
    applyChanges: function () {
        var g = this;
        var h = this.calendar;
        var e = this.down('combobox[name="cmb_parentCalendar"]').getValue(), a = this.down("#calendarName").getValue();
        if (this.calendarManager) {
            var f = this.calendarManager.getModelById(h.calendarId);
            if (f) {
                f.setName(a)
            }
        }
        h.suspendEvents(true);
        h.suspendCacheUpdate++;
        h.name = a;
        h.setParent(e ? Gnt.data.Calendar.getCalendar(e) : null);
        if (h.proxy.extraParams) {
            h.proxy.extraParams.calendarId = h.calendarId
        }
        Gnt.util.Data.applyCloneChanges(this.dayOverridesCalendar, h);
        var c = [];
        var b = [];
        var d = {};
        this.weekOverridesStore.each(function (i) {
            Ext.Array.each(i.get("weekAvailability").concat(i.get("mainDay")), function (j) {
                if (j) {
                    if (j.__COPYOF__) {
                        d[j.__COPYOF__] = true
                    }
                    g.applySingleDay(j, c)
                }
            })
        });
        h.forEachNonStandardWeek(function (i) {
            Ext.Array.each(i.weekAvailability.concat(i.mainDay), function (j) {
                if (j && !d[j.getId()]) {
                    b.push(j)
                }
            })
        });
        h.add(c);
        h.remove(b);
        h.suspendCacheUpdate--;
        h.clearCache();
        h.resumeEvents();
        this.fireEvent("calendarset", h)
    },
    hasChanges: function () {
        if (!this.calendar) {
            return false
        }
        var a = this.dayOverridesCalendar.getModifiedRecords().length || this.dayOverridesCalendar.getRemovedRecords().length, d = this.weekOverridesStore.getModifiedRecords().length || this.weekOverridesStore.getRemovedRecords().length, c = this.down("#calendarName").getValue() != this.calendar.name, e = this.calendar.parent && this.calendar.parent.calendarId || -1, b = this.cmbParentCalendar.getValue() != e;
        return a || d || c || b
    }
});
Ext.define("Gnt.widget.calendar.CalendarWindow", {
    extend: "Ext.window.Window",
    requires: ["Gnt.widget.calendar.Calendar"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarwindow",
    calendarConfig: null,
    calendar: null,
    calendarWidget: null,
    initComponent: function () {
        Ext.apply(this, {
            width: 600,
            layout: "fit",
            items: this.calendarWidget = new Gnt.widget.calendar.Calendar(Ext.apply({calendar: this.calendar}, this.calendarConfig)),
            buttons: [{
                text: this.L("ok"), handler: function () {
                    this.applyChanges();
                    this.close()
                }, scope: this
            }, {text: this.L("cancel"), handler: this.close, scope: this}]
        });
        this.callParent(arguments)
    },
    applyChanges: function () {
        this.calendarWidget.applyChanges()
    },
    setCalendar: function (a) {
        this.calendarWidget.setCalendar(a)
    }
});
Ext.define("Gnt.widget.calendar.CalendarManager", {
    extend: "Ext.panel.Panel",
    requires: ["Ext.tree.Panel", "Ext.menu.Menu", "Gnt.widget.calendar.Calendar", "Gnt.data.calendar.BusinessTime"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarmanager",
    treePanelConfig: null,
    treePanel: null,
    calendarPanelConfig: null,
    calendarManager: null,
    calendarPanel: null,
    layout: "border",
    width: 800,
    height: 600,
    initComponent: function () {
        var b = this;
        b.cls = b.cls + " gnt-calendarmanager";
        b.treePanel = b.buildTreePanel();
        b.calendarPanel = new Gnt.widget.calendar.Calendar(Ext.apply({
            region: "center",
            calendar: b.calendar,
            split: true,
            calendarManager: b.calendarManager
        }, this.calendarPanelConfig));
        b.items = [this.treePanel, this.calendarPanel];
        this.callParent(arguments);
        this.contextMenu = this.buildContextMenu();
        var a = b.calendarManager;
        this.setCalendar(b.calendar || a.getProjectCalendar() || a.getRoot().firstChild);
        this.counter = 1
    },
    buildTreePanel: function () {
        var a = this;
        return new Ext.tree.Panel(Ext.apply({
            split: true,
            region: "west",
            width: 200,
            store: a.calendarManager,
            displayField: a.calendarManager.model.prototype.nameField,
            rootVisible: false,
            tbar: [{
                itemId: "btnAdd",
                text: a.L("addText"),
                action: "add",
                iconCls: "gnt-action-add",
                handler: a.doAddRootNode,
                scope: a
            }, {
                itemId: "btnRemove",
                text: a.L("removeText"),
                action: "remove",
                iconCls: "gnt-action-remove",
                handler: a.doRemoveCalendar,
                scope: a
            }],
            viewConfig: {
                plugins: {
                    ptype: "treeviewdragdrop",
                    allowContainerDrops: true,
                    dropZone: {
                        onNodeDrop: function (b) {
                            this.valid = true;
                            this.currentPosition = "append";
                            this.overRecord = this.view.getRecord(b);
                            return this.self.prototype.onNodeDrop.apply(this, arguments)
                        }
                    }
                }, getRowClass: function (b) {
                    if (a.calendarManager.getProjectCalendar() == b.calendar) {
                        return "gnt-project-calendar-row"
                    }
                }, listeners: {drop: a.onDrop, scope: a}
            },
            listeners: {
                containercontextmenu: a.onContainerContextMenu,
                itemcontextmenu: a.onItemContextMenu,
                selectionchange: a.onSelectionChange,
                scope: a
            }
        }, a.treePanelConfig))
    },
    buildContextMenu: function () {
        return new Ext.menu.Menu({
            margin: "0 0 10 0",
            items: [{
                text: this.L("add_node"),
                handler: this.doAddRootNode,
                itemId: "add-node",
                scope: this
            }, {text: this.L("add_child"), handler: this.doAddChildNode, scope: this}, {
                text: this.L("add_sibling"),
                handler: this.doAddSiblingCalendar,
                scope: this
            }, {text: this.L("remove"), handler: this.doRemoveCalendar, scope: this}]
        })
    },
    showContextMenu: function (c, b) {
        var a = this.contextMenu.query("menuitem");
        if (b) {
            Ext.Array.each(a, function (d) {
                d.show()
            });
            this.contextMenu.down("#add-node").hide()
        } else {
            Ext.Array.each(a, function (d) {
                d.hide()
            });
            this.contextMenu.down("#add-node").show()
        }
        c.stopEvent();
        this.contextMenu.showAt(c.getXY())
    },
    onContainerContextMenu: function (a, b) {
        this.showContextMenu(b)
    },
    onItemContextMenu: function (a, f, c, b, d) {
        this.showContextMenu(d, f)
    },
    hasChanges: function () {
        return this.calendarPanel.hasChanges()
    },
    onSelectionChange: function (e, f, d) {
        var g = this, c = g.calendarManager, b = g.calendarPanel;
        if (f.length > 0) {
            var a = f[0];
            if (b.calendar && b.hasChanges()) {
                Ext.Msg.show({
                    title: g.L("confirm_action"),
                    msg: g.L("confirm_message"),
                    buttons: Ext.Msg.YESNOCANCEL,
                    icon: Ext.Msg.QUESTION,
                    fn: function (h) {
                        if (h == "yes") {
                            g.applyChanges();
                            b.setCalendar(a.getCalendar())
                        } else {
                            if (h == "no") {
                                b.setCalendar(a.getCalendar())
                            } else {
                                e.suspendEvents();
                                e.select(c.getNodeByCalendar(b.calendar));
                                e.resumeEvents()
                            }
                        }
                    }
                })
            } else {
                b.setCalendar(a.getCalendar())
            }
        }
    },
    onDrop: function (b, d, c, a) {
        c = c || this.calendarManager.getRootNode();
        c.expand()
    },
    onDestroy: function () {
        this.contextMenu.destroy();
        this.callParent(arguments)
    },
    applyChanges: function () {
        this.calendarPanel.applyChanges()
    },
    doAddRootNode: function () {
        this.addCalendar()
    },
    doAddChildNode: function () {
        var a = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(a[0])
    },
    doAddSiblingCalendar: function () {
        var a = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(a[0] && a[0].parentNode)
    },
    doRemoveCalendar: function () {
        var a = this.treePanel.getSelectionModel().getSelection();
        this.removeCalendar(a[0])
    },
    addCalendar: function (c) {
        var d = Ext.ClassManager.get(this.calendarManager.calendarClass).prototype;
        var a = this.calendarManager.model.prototype;
        var b = a.getModelConfig(d);
        b[a.nameField] = this.L("calendarName") + this.counter++;
        b.expanded = true;
        b.leaf = true;
        c = c || this.treePanel.getRootNode();
        c.data.expanded = true;
        c.appendChild(b)
    },
    removeCalendar: function (c) {
        var a = this.treePanel.getRootNode();
        if (c) {
            var b = c.nextSibling || c.previousSibling || (c.parentNode == a ? a.firstChild : c.parentNode);
            if (b) {
                this.treePanel.getSelectionModel().select(b)
            }
            c.remove()
        }
    },
    setCalendar: function (a) {
        if (a instanceof Gnt.model.Calendar) {
            this.treePanel.setSelection(a);
            this.calendarPanel.setCalendar(a.getCalendar())
        } else {
            this.treePanel.setSelection(this.calendarManager.getNodeByCalendar(a));
            this.calendarPanel.setCalendar(a)
        }
    }
});
Ext.define("Gnt.widget.calendar.CalendarManagerWindow", {
    extend: "Ext.window.Window",
    requires: ["Gnt.widget.calendar.CalendarManager"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.calendarmanagerwindow",
    width: 850,
    height: 600,
    layout: "fit",
    border: false,
    calendarConfig: null,
    calendarManager: null,
    panel: null,
    initComponent: function () {
        this.panel = new Gnt.widget.calendar.CalendarManager({
            calendarManager: this.calendarManager,
            calendarConfig: this.calendarConfig
        });
        Ext.apply(this, {
            title: this.title || this.L("title"),
            items: [this.panel],
            buttons: [{
                text: this.L("ok"), handler: function () {
                    this.applyChanges()
                }, scope: this
            }, {
                text: this.L("cancel"), handler: function () {
                    this.close()
                }, scope: this
            }],
            listeners: {beforeclose: this.onBeforeClose, close: this.onAfterClose}
        });
        this.callParent(arguments)
    },
    applyChanges: function () {
        this.panel.applyChanges()
    },
    onBeforeClose: function () {
        var b = this;
        var a = this.panel;
        if (!b.closing && a.hasChanges()) {
            Ext.Msg.show({
                title: b.L("confirm_action"),
                msg: b.L("confirm_message"),
                buttons: Ext.Msg.YESNOCANCEL,
                icon: Ext.Msg.QUESTION,
                fn: function (c) {
                    switch (c) {
                        case"yes":
                            a.applyChanges();
                            b.close();
                            break;
                        case"no":
                            b.closing = true;
                            b.close();
                            break
                    }
                }
            });
            return false
        }
    },
    onAfterClose: function () {
        this.closing = false
    }
});
Ext.define("Gnt.patches.IETreeStore", {
    extend: "Sch.util.Patch",
    requires: ["Gnt.data.TaskStore"],
    target: "Gnt.data.TaskStore",
    ieOnly: true,
    maxVersion: "5.1.0",
    overrides: {
        onNodeAdded: function (c, e) {
            var d = this, b = d.getProxy(), a = b.getReader(), f = e.raw || e[e.persistenceProperty], g;
            Ext.Array.remove(d.removed, e);
            e.join(d);
            if (!e.isLeaf()) {
                g = a.getRoot(f);
                if (g) {
                    d.fillNode(e, a.extractData(g));
                    if (f[a.root]) {
                        delete f[a.root]
                    }
                }
            }
            if (d.autoSync && !d.autoSyncSuspended && (e.phantom || e.dirty)) {
                d.sync()
            }
        }
    }
});
Ext.define("Gnt.patches.CellEditor", {
    extend: "Sch.util.Patch",
    requires: ["Ext.grid.CellEditor"],
    target: "Ext.grid.CellEditor",
    minVersion: "5.1.0",
    overrides: {
        onHide: function () {
            this.restoreCell();
            this.superclass.onHide.apply(this, arguments)
        }
    }
});
Ext.define("Gnt.patches.CellEditing", {
    extend: "Sch.util.Patch",
    requires: ["Ext.grid.plugin.CellEditing"],
    target: "Ext.grid.plugin.CellEditing",
    minVersion: "5.1.1",
    overrides: {
        showEditor: function (a, b, c) {
            if (a.context && a.context.record !== b.record && a.field instanceof Ext.form.field.ComboBox) {
                a.field.lastSelectedRecords = null
            }
            this.callParent(arguments)
        }
    }
});
Ext.define("Gnt.patches.Tooltip", {
    extend: "Sch.util.Patch",
    requires: ["Ext.tip.ToolTip"],
    target: "Ext.tip.ToolTip",
    minVersion: "5.1.0",
    overrides: {
        onDocMouseDown: function () {
            if (this.isDisabled()) {
                return
            }
            this.callParent(arguments)
        }
    }
});
Ext.define("Gnt.patches.RightClick", {
    extend: "Sch.util.Patch",
    requires: ["Gnt.view.Gantt"],
    target: "Gnt.view.Gantt",
    minVersion: "5.1.0",
    overrides: {
        handleScheduleBarEvent: function (a) {
            if (Ext.isGecko && a.type === "click" && a.button === 2) {
                return false
            }
            return this.callParent(arguments)
        }
    }
});
Ext.define("Gnt.panel.Gantt", {
    extend: "Sch.panel.TimelineTreePanel",
    alias: ["widget.ganttpanel"],
    alternateClassName: ["Sch.gantt.GanttPanel"],
    requires: ["Ext.layout.container.Border", "Ext.tree.plugin.TreeViewDragDrop", "Gnt.patches.CellEditor", "Gnt.patches.CellEditing", "Gnt.data.ResourceStore", "Gnt.data.AssignmentStore", "Gnt.feature.WorkingTime", "Gnt.data.Calendar", "Gnt.data.TaskStore", "Gnt.data.DependencyStore", "Gnt.view.Gantt", "Gnt.patches.RightClick", "Gnt.plugin.ConstraintResolutionGui", "Gnt.plugin.ProjectLines"],
    uses: ["Sch.plugin.CurrentTimeLine"],
    viewType: "ganttview",
    layout: "border",
    rowLines: true,
    syncRowHeight: false,
    useSpacer: false,
    rowHeight: 24,
    topLabelField: null,
    leftLabelField: null,
    bottomLabelField: null,
    rightLabelField: null,
    highlightWeekends: true,
    weekendsAreWorkdays: false,
    skipWeekendsDuringDragDrop: true,
    enableTaskDragDrop: true,
    enableDependencyDragDrop: true,
    enableProgressBarResize: false,
    toggleParentTasksOnClick: true,
    addRowOnTab: true,
    recalculateParents: true,
    cascadeChanges: false,
    showTodayLine: false,
    enableBaseline: false,
    baselineVisible: false,
    enableAnimations: false,
    animate: false,
    workingTimePlugin: null,
    todayLinePlugin: null,
    allowParentTaskMove: true,
    allowParentTaskDependencies: true,
    enableDragCreation: true,
    eventRenderer: Ext.emptyFn,
    eventRendererScope: null,
    eventTemplate: null,
    parentEventTemplate: null,
    rollupTemplate: null,
    milestoneTemplate: null,
    taskBodyTemplate: null,
    parentTaskBodyTemplate: null,
    milestoneBodyTemplate: null,
    autoHeight: null,
    calendar: null,
    crudManager: null,
    taskStore: null,
    dependencyStore: null,
    resourceStore: null,
    assignmentStore: null,
    columnLines: false,
    dndValidatorFn: Ext.emptyFn,
    createValidatorFn: Ext.emptyFn,
    resizeHandles: "both",
    resizeValidatorFn: Ext.emptyFn,
    resizeConfig: null,
    progressBarResizeConfig: null,
    dragDropConfig: null,
    createConfig: null,
    autoFitOnLoad: false,
    showRollupTasks: false,
    enableConstraintsResolutionGui: true,
    showProjectLines: true,
    projectLinesConfig: null,
    constraintResolutionGuiConfig: null,
    scrollTaskIntoViewOnClick: false,
    enableTaskReordering: true,
    refreshLockedTreeOnDependencyUpdate: false,
    _lockedDependencyListeners: null,
    earlyStartColumn: null,
    earlyEndColumn: null,
    lateStartColumn: null,
    lateEndColumn: null,
    earlyDatesListeners: null,
    lateDatesListeners: null,
    slackListeners: null,
    refreshTimeout: 100,
    lastFocusedRecord: null,
    lastFocusedRecordFrom: null,
    ganttEditingPlugin: null,
    simpleCascadeThreshold: 30,
    forceDefineTimeSpanByStore: true,
    setShowRollupTasks: function (b) {
        this.showRollupTasks = b;
        var a = this.getSchedulingView();
        a.setShowRollupTasks(b)
    },
    onCalendarSet: function (a, b) {
        if (this.needToTranslateOption("weekendsAreWorkdays")) {
            b.setWeekendsAreWorkDays(this.weekendsAreWorkdays)
        }
        if (this.workingTimePlugin) {
            this.workingTimePlugin.bindCalendar(b);
            this.workingTimePlugin.refresh()
        }
        this.calendar = b
    },
    initStores: function () {
        if (this.crudManager) {
            if (!this.taskStore) {
                this.taskStore = this.crudManager.getTaskStore()
            }
            if (!this.dependencyStore) {
                this.dependencyStore = this.crudManager.getDependencyStore()
            }
            if (!this.resourceStore) {
                this.resourceStore = this.crudManager.getResourceStore()
            }
            if (!this.assignmentStore) {
                this.assignmentStore = this.crudManager.getAssignmentStore()
            }
        }
        if (!this.taskStore) {
            Ext.Error.raise("You must specify a taskStore config.")
        }
        var a = Ext.StoreMgr.lookup(this.taskStore);
        if (!a) {
            Ext.Error.raise("You have provided an incorrect taskStore identifier")
        }
        if (!(a instanceof Gnt.data.TaskStore)) {
            Ext.Error.raise("A `taskStore` should be an instance of `Gnt.data.TaskStore` (or of a subclass)")
        }
        this.mon(a, {calendarset: this.onCalendarSet, scope: this});
        Ext.apply(this, {store: a, taskStore: a});
        var d = this.calendar = a.calendar;
        if (this.dependencyStore) {
            this.dependencyStore = Ext.StoreMgr.lookup(this.dependencyStore);
            a.setDependencyStore(this.dependencyStore)
        } else {
            this.dependencyStore = a.dependencyStore
        }
        this.dependencyStore.allowParentTaskDependencies = this.allowParentTaskDependencies;
        if (!(this.dependencyStore instanceof Gnt.data.DependencyStore)) {
            Ext.Error.raise("The Gantt dependency store should be a Gnt.data.DependencyStore, or a subclass thereof.")
        }
        var b = this.resourceStore ? Ext.StoreMgr.lookup(this.resourceStore) : a.getResourceStore();
        if (!(b instanceof Gnt.data.ResourceStore)) {
            Ext.Error.raise("A `ResourceStore` should be an instance of `Gnt.data.ResourceStore` (or of a subclass)")
        }
        var c = this.assignmentStore ? Ext.StoreMgr.lookup(this.assignmentStore) : a.getAssignmentStore();
        if (!(c instanceof Gnt.data.AssignmentStore)) {
            Ext.Error.raise("An `assignmentStore` should be an instance of `Gnt.data.AssignmentStore` (or of a subclass)")
        }
        this.bindAssignmentStore(c, true);
        this.bindResourceStore(b, true);
        if (this.needToTranslateOption("weekendsAreWorkdays")) {
            d.setWeekendsAreWorkDays(this.weekendsAreWorkdays)
        }
    },
    initComponent: function () {
        var d = this;
        if (Ext.isBoolean(this.showBaseline)) {
            this.enableBaseline = this.baselineVisible = this.showBaseline;
            this.showBaseline = Gnt.panel.Gantt.prototype.showBaseline
        }
        this.autoHeight = false;
        this.initStores();
        if (this.needToTranslateOption("cascadeChanges")) {
            this.setCascadeChanges(this.cascadeChanges)
        }
        if (this.needToTranslateOption("recalculateParents")) {
            this.setRecalculateParents(this.recalculateParents)
        }
        if (this.needToTranslateOption("skipWeekendsDuringDragDrop")) {
            this.setSkipWeekendsDuringDragDrop(this.skipWeekendsDuringDragDrop)
        }
        this.normalViewConfig = this.normalViewConfig || {};
        Ext.apply(this.normalViewConfig, {
            taskStore: this.taskStore,
            dependencyStore: this.dependencyStore,
            snapRelativeToEventStartDate: this.snapRelativeToEventStartDate,
            enableDependencyDragDrop: this.enableDependencyDragDrop,
            enableTaskDragDrop: this.enableTaskDragDrop,
            enableProgressBarResize: this.enableProgressBarResize,
            enableDragCreation: this.enableDragCreation,
            allowParentTaskMove: this.allowParentTaskMove,
            allowParentTaskDependencies: this.allowParentTaskDependencies,
            toggleParentTasksOnClick: this.toggleParentTasksOnClick,
            resizeHandles: this.resizeHandles,
            enableBaseline: this.baselineVisible || this.enableBaseline,
            leftLabelField: this.leftLabelField,
            rightLabelField: this.rightLabelField,
            topLabelField: this.topLabelField,
            bottomLabelField: this.bottomLabelField,
            eventTemplate: this.eventTemplate,
            parentEventTemplate: this.parentEventTemplate,
            milestoneTemplate: this.milestoneTemplate,
            rollupTemplate: this.rollupTemplate,
            taskBodyTemplate: this.taskBodyTemplate,
            parentTaskBodyTemplate: this.parentTaskBodyTemplate,
            milestoneBodyTemplate: this.milestoneBodyTemplate,
            resizeConfig: this.resizeConfig,
            dragDropConfig: this.dragDropConfig,
            showRollupTasks: this.showRollupTasks
        });
        if (this.topLabelField || this.bottomLabelField) {
            this.addCls("sch-gantt-topbottom-labels " + (this.topLabelField ? "sch-gantt-top-label" : ""));
            this.normalViewConfig.rowHeight = 52
        }
        this.configureFunctionality();
        this.mon(this.taskStore, {beforecascade: this.onBeforeCascade, cascade: this.onAfterCascade, scope: this});
        this.callParent(arguments);
        if (this.autoFitOnLoad) {
            if (this.store.getCount()) {
                this.zoomToFit()
            }
            this.mon(this.store, "load", function () {
                this.zoomToFit()
            }, this)
        }
        this.bodyCls = (this.bodyCls || "") + " sch-ganttpanel-container-body";
        var c = this.getSchedulingView();
        this.relayEvents(c, ["taskclick", "taskdblclick", "taskcontextmenu", "beforetaskresize", "taskresizestart", "partialtaskresize", "beforetaskresizefinalize", "aftertaskresize", "beforeprogressbarresize", "progressbarresizestart", "afterprogressbarresize", "beforetaskdrag", "taskdragstart", "beforetaskdropfinalize", "beforedragcreate", "dragcreatestart", "beforedragcreatefinalize", "dragcreateend", "afterdragcreate", "taskdrop", "aftertaskdrop", "labeledit_beforestartedit", "labeledit_beforecomplete", "labeledit_complete", "beforedependencydrag", "dependencydragstart", "dependencydrop", "afterdependencydragdrop", "dependencyclick", "dependencycontextmenu", "dependencydblclick", "scheduleclick", "scheduledblclick", "schedulecontextmenu"]);
        if (this.addRowOnTab) {
            var e = this.getSelectionModel();
            e.onEditorTab = Ext.Function.createInterceptor(e.onEditorTab, this.onEditorTabPress, this)
        }
        var b = this.getSchedulingView();
        this.registerRenderer(b.columnRenderer, b);
        var a = " sch-ganttpanel sch-horizontal ";
        if (this.highlightWeekends) {
            a += " sch-ganttpanel-highlightweekends "
        }
        if (!this.rtl) {
            a += " sch-ltr "
        }
        this.addCls(a);
        if (this.eventBorderWidth < 1) {
            this.addCls("sch-gantt-no-task-border")
        }
        if (this.baselineVisible) {
            this.showBaseline()
        }
        this.on("add", function (g, f) {
            if (f instanceof Ext.Editor) {
                g.lockedGrid.suspendLayouts();
                g.suspendLayouts();
                g.lockedGrid.add(f);
                g.resumeLayouts();
                g.lockedGrid.resumeLayouts()
            }
        });
        this.on("viewready", this.onMyViewReady, this);
        this.on({
            dragcreatestart: function () {
                var f = this.findPlugin("scheduler_pan");
                if (f) {
                    f.disable()
                }
            }, afterdragcreate: function () {
                var f = this.findPlugin("scheduler_pan");
                if (f) {
                    f.enable()
                }
            }, scope: this
        });
        if (this.scrollTaskIntoViewOnClick) {
            this.lockedGrid.on("itemclick", this.onRowClicked, this)
        }
    },
    getTimeSpanDefiningStore: function () {
        return this.taskStore
    },
    bindAutoTimeSpanListeners: function () {
        if (!this.autoFitOnLoad) {
            this.callParent(arguments)
        }
    },
    onBeforeCascade: function () {
        this.lockedGrid.view.onUpdate = this.normalGrid.view.onUpdate = Ext.emptyFn;
        this.suspendLayouts()
    },
    onAfterCascade: function (d, b) {
        var h = this;
        this.lockedGrid.view.onUpdate = this.lockedGrid.view.self.prototype.onUpdate;
        this.normalGrid.view.onUpdate = this.normalGrid.view.self.prototype.onUpdate;
        h.resumeLayouts();
        if (b.nbrAffected > 0) {
            var k = this.lockedGrid.getView();
            if (b.nbrAffected <= h.simpleCascadeThreshold) {
                var i = this.getView();
                var f = this.getSchedulingView();
                var j = {};
                f.suspendEvents(true);
                for (var a in b.affected) {
                    var c = b.affected[a];
                    var g = k.store.indexOf(c);
                    if (g >= 0) {
                        i.refreshNode(g)
                    }
                }
                f.resumeEvents();
                return
            }
            var e = this.normalGrid.getView();
            e.refreshKeepingScroll(true);
            h.suspendLayouts();
            k.refresh();
            h.resumeLayouts()
        }
    },
    bindFullRefreshListeners: function (a) {
        var c = this;
        var d;
        var b = function () {
            if (d) {
                return
            }
            d = setTimeout(function () {
                d = null;
                c.redrawColumns([a])
            }, c.refreshTimeout)
        };
        a.mon(this.taskStore, {nodeappend: b, nodeinsert: b, noderemove: b, scope: this})
    },
    bindSequentialDataListeners: function (b) {
        var c = this.lockedGrid.view;
        var a = this.taskStore;
        b.mon(a, {
            nodeappend: function (d, f, e) {
                if (!a.fillCount) {
                    this.updateAutoGeneratedCells(b, e)
                }
            }, nodeinsert: function (d, f, e) {
                this.updateAutoGeneratedCells(b, c.store.indexOf(e))
            }, move: function (g, e, f) {
                if (g.__recordBelow) {
                    var h = c.store;
                    var d = Math.min(h.indexOf(g), h.indexOf(g.__recordBelow));
                    this.updateAutoGeneratedCells(b, d)
                }
            }, _noderemove: function (f, d, e) {
                this.updateAutoGeneratedCells(b, this.lockedGrid.view.all.startIndex)
            }, scope: this
        });
        b.mon(this.lockedGrid.getView(), {
            itemremove: function (f, d, e) {
                this.updateAutoGeneratedCells(b, this.lockedGrid.view.all.startIndex)
            }, scope: this
        })
    },
    bindSlackListeners: function () {
        var a = Ext.Function.createBuffered(this.updateSlackColumns, this.refreshTimeout, this, []);
        this.slackListeners = this.mon(this.taskStore, {
            resetearlydates: a,
            resetlatedates: a,
            scope: this,
            destroyable: true
        })
    },
    bindEarlyDatesListeners: function () {
        var a = Ext.Function.createBuffered(this.updateEarlyDateColumns, this.refreshTimeout, this, []);
        this.earlyDatesListeners = this.mon(this.taskStore, {resetearlydates: a, scope: this, destroyable: true})
    },
    bindLateDatesListeners: function () {
        var a = Ext.Function.createBuffered(this.updateLateDateColumns, this.refreshTimeout, this, []);
        this.lateDatesListeners = this.mon(this.taskStore, {resetlatedates: a, scope: this, destroyable: true})
    },
    onEditorTabPress: function (b, f) {
        var g = this.lockedGrid.headerCt, a = b.getActiveRecord(), d = g.items.indexOf(b.getActiveColumn()), i = this.store.indexOf(a) === this.getStore().getCount() - 1, h = function (e) {
            return g.items.indexOf(e) > d && e.isVisible() && e.getEditor()
        };
        if (i && g.items.findIndexBy(h) < 0) {
            var c = a.addTaskBelow({leaf: true});
            !Sch.disableOverrides && b.on("beforeedit", function (e, m) {
                var l = m.column;
                var k = b.getEditor(c, l);
                var j = this.lockedGrid.view;
                k.on("startedit", function () {
                    j.scrollCellIntoView(j.getCell(c, l))
                }, null, {single: true, delay: 1})
            }, this, {single: true})
        }
    },
    needToTranslateOption: function (a) {
        return this.hasOwnProperty(a) || this.self.prototype.hasOwnProperty(a) && this.self != Gnt.panel.Gantt
    },
    getDependencyView: function () {
        return this.getSchedulingView().getDependencyView()
    },
    disableWeekendHighlighting: function (a) {
        this.workingTimePlugin.setDisabled(a)
    },
    resolveTaskRecord: function (a) {
        return this.getSchedulingView().resolveTaskRecord(a)
    },
    fitTimeColumns: function () {
        this.getSchedulingView().fitColumns()
    },
    getResourceStore: function () {
        return this.getTaskStore().getResourceStore()
    },
    getAssignmentStore: function () {
        return this.getTaskStore().getAssignmentStore()
    },
    getCrudManager: function () {
        return this.crudManager
    },
    getTaskStore: function () {
        return this.taskStore
    },
    getEventStore: function () {
        return this.taskStore
    },
    getDependencyStore: function () {
        return this.dependencyStore
    },
    onDragDropStart: function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable()
        }
    },
    onDragDropEnd: function () {
        if (this.tip) {
            this.tip.enable()
        }
    },
    configureFunctionality: function () {
        var a = this.plugins = [].concat(this.plugins || []);
        if (this.highlightWeekends) {
            this.workingTimePlugin = Ext.create("Gnt.feature.WorkingTime", {calendar: this.calendar});
            a.push(this.workingTimePlugin)
        }
        if (this.showTodayLine) {
            this.todayLinePlugin = new Sch.plugin.CurrentTimeLine();
            a.push(this.todayLinePlugin)
        }
        if (this.enableConstraintsResolutionGui && !Ext.Array.findBy(a, function (e) {
                return (e instanceof Gnt.plugin.ConstraintResolutionGui) || (e.ptype == "constraintresolutiongui")
            })) {
            a.push(Ext.apply(this.constraintResolutionGuiConfig || {}, {
                pluginId: "constraintresolutiongui",
                ptype: "constraintresolutiongui"
            }))
        }
        if (this.showProjectLines) {
            a.push(Ext.apply({pluginId: "gantt_projectlines", ptype: "gantt_projectlines"}, this.projectLinesConfig))
        }
        if (this.enableTaskReordering) {
            this.lockedViewConfig = this.lockedViewConfig || {};
            this.lockedViewConfig.plugins = [].concat(this.lockedViewConfig.plugins || []);
            var c = this.lockedViewConfig.plugins;
            var d;
            Ext.Array.forEach(c, function (e) {
                if (e === "treeviewdragdrop" || e.ptype === "treeviewdragdrop") {
                    d = true
                }
            });
            if (!d) {
                var b = typeof this.enableTaskReordering !== "boolean" ? this.enableTaskReordering : {
                    ptype: "treeviewdragdrop",
                    pluginId: "bryntum_treedragdrop",
                    containerScroll: true,
                    dragZone: {onBeforeDrag: Ext.Function.bind(this.onBeforeTaskReorder, this)}
                };
                c.push(b)
            }
        }
    },
    getWorkingTimePlugin: function () {
        return this.workingTimePlugin
    },
    registerLockedDependencyListeners: function () {
        var b = this;
        var a = this.getDependencyStore();
        this._lockedDependencyListeners = this._lockedDependencyListeners || {
                load: function () {
                    var c = b.getTaskStore();
                    c.resetEarlyDates();
                    c.resetLateDates();
                    b.lockedGrid.getView().refresh()
                }, clear: function () {
                    var c = b.getTaskStore();
                    c.resetEarlyDates();
                    c.resetLateDates();
                    b.lockedGrid.getView().refresh()
                }, add: function (d, c) {
                    for (var e = 0; e < c.length; e++) {
                        b.updateDependencyTasks(c[e])
                    }
                }, update: function (i, f, h) {
                    if (h != Ext.data.Model.COMMIT) {
                        var e = b.lockedGrid.view;
                        var g = e.store;
                        if (f.previous[f.fromField]) {
                            var d = b.taskStore.getModelById(f.previous[f.fromField]);
                            if (d) {
                                e.refreshNode(g.indexOf(d))
                            }
                        }
                        if (f.previous[f.toField]) {
                            var c = b.taskStore.getModelById(f.previous[f.toField]);
                            if (c) {
                                e.refreshNode(g.indexOf(c))
                            }
                        }
                        b.updateDependencyTasks(f)
                    }
                }, remove: function (d, c) {
                    Ext.Array.each(c, function (e) {
                        b.updateDependencyTasks(e)
                    })
                }
            };
        this.mun(a, this._lockedDependencyListeners);
        this.mon(a, this._lockedDependencyListeners)
    },
    updateDependencyTasks: function (c) {
        var b = c.getSourceTask(this.taskStore);
        var e = c.getTargetTask(this.taskStore);
        var f = this.lockedGrid.getView();
        var a = f.store.indexOf(b);
        var d = f.store.indexOf(e);
        if (b && b.getTreeStore() && a >= 0) {
            f.refreshNode(a)
        }
        if (e && e.getTreeStore() && d >= 0) {
            f.refreshNode(d)
        }
    },
    showBaseline: function () {
        this.addCls("sch-ganttpanel-showbaseline")
    },
    hideBaseline: function () {
        this.removeCls("sch-ganttpanel-showbaseline")
    },
    toggleBaseline: function () {
        this.toggleCls("sch-ganttpanel-showbaseline")
    },
    zoomToFit: function (c, a) {
        a = Ext.apply({adjustStart: 1, adjustEnd: 1}, a);
        if (!c && this.taskStore.isTreeFiltered()) {
            c = this.getSchedulingView().store.getRange()
        }
        var b = c ? this.taskStore.getTimeSpanForTasks(c) : this.taskStore.getTotalTimeSpan();
        if (this.zoomToSpan(b, a) === null) {
            if (!c) {
                this.fitTimeColumns()
            }
        }
    },
    getCascadeChanges: function () {
        return this.taskStore.cascadeChanges
    },
    setCascadeChanges: function (a) {
        this.taskStore.cascadeChanges = a
    },
    getRecalculateParents: function () {
        return this.taskStore.recalculateParents
    },
    setRecalculateParents: function (a) {
        this.taskStore.recalculateParents = a
    },
    setSkipWeekendsDuringDragDrop: function (a) {
        this.taskStore.skipWeekendsDuringDragDrop = this.skipWeekendsDuringDragDrop = a
    },
    getSkipWeekendsDuringDragDrop: function () {
        return this.taskStore.skipWeekendsDuringDragDrop
    },
    bindResourceStore: function (d, a) {
        var c = this;
        var b = {scope: c, update: c.onResourceStoreUpdate, datachanged: c.onResourceStoreDataChanged};
        if (!a && c.resourceStore) {
            if (d !== c.resourceStore && c.resourceStore.autoDestroy) {
                c.resourceStore.destroy()
            } else {
                c.mun(c.resourceStore, b)
            }
            if (!d) {
                c.resourceStore = null
            }
        }
        if (d) {
            d = Ext.data.StoreManager.lookup(d);
            c.mon(d, b);
            this.taskStore.setResourceStore(d)
        }
        c.resourceStore = d;
        if (d && !a) {
            c.refreshViews()
        }
    },
    refreshViews: function () {
        if (!this.rendered) {
            return
        }
        var b = this.lockedGrid.getView(), a = {left: b.getScrollX(), top: b.getScrollY()};
        b.refresh();
        this.getSchedulingView().refreshKeepingScroll();
        b.setScrollX(a.left);
        b.setScrollY(a.top)
    },
    bindAssignmentStore: function (d, a) {
        var c = this;
        var b = {
            scope: c,
            beforetaskassignmentschange: c.onBeforeSingleTaskAssignmentChange,
            taskassignmentschanged: c.onSingleTaskAssignmentChange,
            update: c.onAssignmentStoreUpdate,
            datachanged: c.onAssignmentStoreDataChanged
        };
        if (!a && c.assignmentStore) {
            if (d !== c.assignmentStore && c.assignmentStore.autoDestroy) {
                c.assignmentStore.destroy()
            } else {
                c.mun(c.assignmentStore, b)
            }
            if (!d) {
                c.assignmentStore = null
            }
        }
        if (d) {
            d = Ext.data.StoreManager.lookup(d);
            c.mon(d, b);
            this.taskStore.setAssignmentStore(d)
        }
        c.assignmentStore = d;
        if (d && !a) {
            c.refreshViews()
        }
    },
    onResourceStoreUpdate: function (a, b) {
        var c = b.getTasks();
        Ext.Array.each(c, function (d) {
            var e = this.lockedGrid.view.store.indexOf(d);
            if (e >= 0) {
                this.getView().refreshNode(e)
            }
        }, this)
    },
    onResourceStoreDataChanged: function () {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews()
        }
    },
    onAssignmentStoreDataChanged: function () {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews()
        }
    },
    onAssignmentStoreUpdate: function (b, d) {
        var a = d.getTask();
        if (a) {
            var c = this.lockedGrid.view.store.indexOf(a);
            if (c >= 0) {
                this.getView().refreshNode(c)
            }
        }
    },
    onBeforeSingleTaskAssignmentChange: function () {
        this.assignmentStore.un("datachanged", this.onAssignmentStoreDataChanged, this)
    },
    onSingleTaskAssignmentChange: function (e, d, c) {
        this.assignmentStore.on("datachanged", this.onAssignmentStoreDataChanged, this);
        if (this.rendered) {
            var a = this.taskStore.getModelById(d);
            if (a && a.parentNode) {
                var b = this.taskStore.indexOf(a);
                if (b >= 0) {
                    this.getView().refreshNode(b)
                }
            }
        }
    },
    updateAutoGeneratedCells: function (e, c) {
        var b = this.lockedGrid.view;
        var h = b.all.startIndex;
        var f = b.all.endIndex;
        if (c < 0 || c > f) {
            return
        }
        for (var d = Math.max(h, c); d <= f; d++) {
            var g = b.store.getAt(d);
            var a = this.getCellDom(b, g, e);
            if (a) {
                a.firstChild.innerHTML = e.renderer(null, null, g)
            }
        }
    },
    getCellDom: function (b, a, c) {
        var d = b.getNode(a, true);
        return d && Ext.fly(d).down(c.getCellSelector(), true)
    },
    redrawColumns: function (g) {
        if (g.length && !this.isDestroyed) {
            var b = this.lockedGrid.view;
            for (var e = b.all.startIndex; e <= b.all.endIndex; e++) {
                var h = b.store.getAt(e);
                for (var d = 0, f = g.length; d < f; d++) {
                    var a = this.getCellDom(b, h, g[d]);
                    if (a) {
                        var c = [];
                        b.renderCell(g[d], h, e, g[d].getIndex(), e, c);
                        a.innerHTML = c.join("")
                    }
                }
            }
        }
    },
    updateSlackColumns: function () {
        if (this.slackColumn) {
            this.redrawColumns([this.slackColumn])
        }
    },
    updateEarlyDateColumns: function () {
        var a = [];
        if (this.earlyStartColumn) {
            a.push(this.earlyStartColumn)
        }
        if (this.earlyEndColumn) {
            a.push(this.earlyEndColumn)
        }
        if (a.length) {
            this.redrawColumns(a)
        }
    },
    updateLateDateColumns: function () {
        var a = [];
        if (this.lateStartColumn) {
            a.push(this.lateStartColumn)
        }
        if (this.lateEndColumn) {
            a.push(this.lateEndColumn)
        }
        if (a.length) {
            this.redrawColumns(a)
        }
    },
    onMyViewReady: function () {
        this.on("beforeedit", function (e, f) {
            var d = f.column;
            return !this.isReadOnly() && f.record.isEditable(f.field) && (!d.isEditable || d.isEditable(f.record))
        }, this);
        this.setupColumnListeners();
        var b = this.getDependencyView();
        this.getView().on({expandbody: b.renderAllDependencies, collapsebody: b.renderAllDependencies, scope: b});
        var a = this.lockedGrid.plugins || [];
        Ext.Array.each(a, function (d) {
            if (Sch.plugin && Sch.plugin.TreeCellEditing && d instanceof Sch.plugin.TreeCellEditing) {
                this.ganttEditingPlugin = d;
                return false
            }
        }, this);
        this.mon(this.taskStore, {
            "nodestore-datachange-start": this.onFilterChange,
            "filter-clear": this.onFilterChange,
            scope: this
        });
        var c = this.down("splitter");
        if (c) {
            c.on("dragend", function () {
                this.saveState()
            }, this, {delay: 10})
        }
    },
    onFilterChange: function () {
        this.getSelectionModel().deselectAll()
    },
    setupColumnListeners: function () {
        var a = this;
        var b = this.lockedGrid.headerCt;
        b.on("add", this.onLockedColumnAdded, this);
        b.items.each(function (c) {
            a.onLockedColumnAdded(b, c)
        })
    },
    onLockedColumnAdded: function (b, a) {
        var c = Gnt.column;
        if (c) {
            if ((c.WBS && a instanceof c.WBS) || (c.Sequence && a instanceof c.Sequence)) {
                this.bindSequentialDataListeners(a)
            } else {
                if (c.Dependency && a instanceof c.Dependency && a.useSequenceNumber) {
                    this.bindFullRefreshListeners(a)
                } else {
                    if (c.EarlyStartDate && a instanceof c.EarlyStartDate) {
                        this.earlyStartColumn = a
                    } else {
                        if (c.EarlyEndDate && a instanceof c.EarlyEndDate) {
                            this.earlyEndColumn = a
                        } else {
                            if (c.LateStartDate && a instanceof c.LateStartDate) {
                                this.lateStartColumn = a
                            } else {
                                if (c.LateEndDate && a instanceof c.LateEndDate) {
                                    this.lateEndColumn = a
                                } else {
                                    if (c.Slack && a instanceof c.Slack) {
                                        this.slackColumn = a
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!this.slackListeners && this.slackColumn) {
            this.bindSlackListeners()
        }
        if (!this.earlyDatesListeners && (this.earlyStartColumn || this.earlyEndColumn)) {
            this.bindEarlyDatesListeners()
        }
        if (!this.lateDatesListeners && (this.lateStartColumn || this.lateEndColumn)) {
            this.bindLateDatesListeners()
        }
    },
    getState: function () {
        var a = this, b = a.callParent(arguments);
        b.lockedWidth = a.lockedGrid.getWidth();
        return b
    },
    applyState: function (b) {
        var a = this;
        a.callParent(arguments);
        if (b && b.lockedWidth) {
            a.lockedGrid.setWidth(b.lockedWidth)
        }
    },
    completeEdit: function () {
        this.ganttEditingPlugin && this.ganttEditingPlugin.completeEdit()
    },
    cancelEdit: function () {
        this.ganttEditingPlugin && this.ganttEditingPlugin.cancelEdit()
    },
    setRowHeight: function (a) {
        var b = "#" + this.getId() + " ." + Ext.baseCSSPrefix + "grid-cell";
        if (!Ext.util.CSS.getRule(b)) {
            Ext.util.CSS.createStyleSheet(b + "{ height:" + a + "px; }")
        } else {
            Ext.util.CSS.updateRule(b, "height", a + "px")
        }
        this.getSchedulingView().setRowHeight(a)
    },
    getTaskEditor: function (c) {
        var b = this.plugins;
        for (var d = 0, a = b.length; d < a; d++) {
            var e = b[d];
            if (e.isTaskEditor && (!c || e.matchFilters(c))) {
                return e
            }
        }
    },
    onRowClicked: function (a, b) {
        this.getSchedulingView().scrollEventIntoView(b, false, false)
    },
    onBeforeTaskReorder: function () {
        return !this.isReadOnly()
    }
});
Ext.define("Gnt.panel.ResourceHistogram", {
    extend: "Sch.panel.TimelineGridPanel",
    requires: ["Ext.XTemplate", "Sch.util.Date", "Gnt.feature.WorkingTime", "Gnt.column.Scale", "Gnt.view.ResourceHistogram"],
    mixins: ["Gnt.mixin.Localizable"],
    alias: "widget.resourcehistogram",
    viewType: "resourcehistogramview",
    layout: "border",
    preserveScrollOnRefresh: true,
    showScaleLines: false,
    showLimitLines: true,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    cacheLimitDurationMS: 0,
    cacheLimitDuration: 6,
    cacheLimitDurationUnit: "mo",
    calendarResources: null,
    calendarListenersHash: null,
    calendar: null,
    taskStore: null,
    resourceStore: null,
    assignmentStore: null,
    startDate: null,
    endDate: null,
    highlightWeekends: true,
    allocationData: null,
    scaleUnit: "HOUR",
    scaleMin: 0,
    scaleMax: 24,
    scaleLabelStep: 4,
    scaleStep: 2,
    rowHeight: 50,
    scaleColumnClass: "Gnt.column.Scale",
    scaleColumnConfigs: ["scalePoints", "scaleStep", "scaleLabelStep", "scaleMin", "scaleMax", "scaleLabelStep", "scaleStep"],
    normalViewConfigs: ["barCls", "barTpl", "barRenderer", "lineRenderer", "limitLineRenderer", "lineTpl", "lineCls", "limitLineTpl", "limitLineCls", "limitLineWidth", "labelMode", "labelPercentFormat", "labelUnitsFormat", "scaleMin", "scaleMax", "scaleStep", "scaleLabelStep", "scalePoints", "scaleUnit", "loadMask", "showLimitLinesThreshold", "showVerticalLimitLines", "calendar"],
    cacheUpdateSuspended: false,
    suspendedCacheUpdatesCount: 0,
    initComponent: function () {
        var c = new Date();
        this.cacheLimitDurationMS = Sch.util.Date.add(c, this.cacheLimitDurationUnit, 1) - c;
        this.resetAllocationDataCache();
        this.initStores();
        this.lockedGridConfig = Ext.applyIf(this.lockedGridConfig || {}, {
            reserveScrollbar: false,
            width: 300,
            forceFit: true
        });
        this.normalViewConfig = Ext.apply(this.normalViewConfig || {}, {
            histogram: this,
            trackOver: false,
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        this.lockedViewConfig = Ext.apply(this.lockedViewConfig || {}, {
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        if (this.scalePoints) {
            this.scalePoints.sort(function (e, d) {
                return e.value > d.value ? 1 : -1
            });
            this.scaleMin = this.scalePoints[0].value;
            this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
            this.scaleStep = (this.scaleMax - this.scaleMin) / 10
        }
        this.initColumns();
        Ext.Array.forEach(this.normalViewConfigs, function (d) {
            if (d in this) {
                this.normalViewConfig[d] = this[d]
            }
        }, this);
        if (this.highlightWeekends) {
            this.initWeekendsHightlight()
        }
        this.callParent(arguments);
        var b = "gnt-resourcehistogram sch-horizontal ";
        if (this.highlightWeekends) {
            b += " gnt-resourcehistogram-highlightweekends "
        }
        this.addCls(b);
        this.registerRenderer(this.columnRenderer, this);
        var a = this.getSchedulingView();
        this.relayEvents(a, ["barclick", "bardblclick", "barcontextmenu"]);
        if (!this.syncRowHeight) {
            this.enableRowHeightInjection(this.lockedGrid.getView(), a)
        }
    },
    initStores: function () {
        var a = false;
        if (this.crudManager) {
            this.setCrudManager(this.crudManager);
            a = true
        }
        this.store = this.resourceStore;
        this.taskStore = this.taskStore || this.store.getTaskStore();
        this.calendar = this.calendar || this.taskStore && this.taskStore.getCalendar();
        if (!this.calendar) {
            throw'Cannot get project calendar instance: please specify either "calendar" or "taskStore" option'
        }
        this.assignmentStore = this.assignmentStore || this.store.getAssignmentStore() || this.taskStore && this.taskStore.getAssignmentStore();
        if (!a) {
            this.bindStores()
        }
    },
    getCrudManager: function () {
        return this.crudManager
    },
    setCrudManager: function (a) {
        this.unbindStores();
        this.crudManagerListeners && this.crudManagerListeners.destroy();
        this.crudManager = a;
        this.taskStore = this.crudManager.getTaskStore();
        this.store = this.resourceStore = this.crudManager.getResourceStore();
        this.assignmentStore = this.crudManager.getAssignmentStore();
        this.crudManagerListeners = this.mon(this.crudManager, {
            beforeloadapply: {
                fn: this.beforeCrudManagerLoad,
                priority: -999
            }, load: this.afterCrudManagerLoad, destroyable: true, scope: this
        });
        this.bindStores()
    },
    beforeCrudManagerLoad: function () {
        this.suspendStoreListeners()
    },
    afterCrudManagerLoad: function () {
        this.beforeCrudOperationStart(this.crudManager, null, "load");
        this.resumeStoreListeners(true);
        this.onCrudOperationComplete()
    },
    bindStores: function () {
        if (this.taskStore) {
            this.mon(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdate,
                nodeappend: this.onTaskUpdate,
                scope: this
            })
        }
        if (this.assignmentStore) {
            this.mon(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            })
        }
        this.calendar && this.mon(this.calendar, {calendarchange: this.onProjectCalendarChange, scope: this});
        this.bindCalendarListeners();
        this.store && this.mon(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        })
    },
    unbindStores: function () {
        if (this.taskStore) {
            this.mun(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdate,
                nodeappend: this.onTaskUpdate,
                scope: this
            })
        }
        if (this.assignmentStore) {
            this.mun(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            })
        }
        this.calendar && this.mun(this.calendar, {calendarchange: this.onProjectCalendarChange, scope: this});
        this.unbindCalendarListeners();
        this.store && this.mun(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        })
    },
    suspendStoreListeners: function () {
        this.cacheUpdateSuspended = true;
        this.suspendedCacheUpdatesCount = 0;
        this.unbindStores()
    },
    resumeStoreListeners: function (a) {
        this.cacheUpdateSuspended = false;
        this.bindStores();
        if (a && this.suspendedCacheUpdatesCount) {
            this.clearCacheAndRefresh()
        }
    },
    clearCacheAndRefresh: function (a) {
        this.resetAllocationDataCache(a);
        this.refreshIfRendered(a)
    },
    createDefaultColumns: function () {
        var b = [], c, a;
        c = this.resourceNameCol = new Ext.grid.column.Column({
            flex: 1,
            resizable: false,
            header: this.resourceText || this.L("resourceText"),
            dataIndex: this.resourceStore.model.prototype.nameField
        });
        b.push(c);
        a = {width: 40, resizable: false};
        Ext.copyTo(a, this, this.scaleColumnConfigs, true);
        a = this.scaleCol = Ext.create(this.scaleColumnClass, a);
        this.mon(a, {
            beforerender: function () {
                a.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
                if (this.scalePoints) {
                    this.scalePoints = a.scalePoints
                }
            }, scope: this, single: true
        });
        b.push(a);
        return b
    },
    initColumns: function () {
        if (!this.columns) {
            this.columns = this.createDefaultColumns();
            var a = this.scaleCol;
            if (this.scalePoints) {
                this.scaleMin = a.scaleMin;
                this.scaleMax = a.scaleMax;
                this.scaleStep = a.scaleStep
            }
        } else {
            var d = !Ext.isArray(this.columns) ? [this.columns] : this.columns;
            for (var c = 0; c < d.length; c++) {
                var b = d[c];
                if (this.isScaleColumn(b)) {
                    Ext.copyToIf(b, this, this.scaleColumnConfigs);
                    if (!(b instanceof Gnt.column.Scale)) {
                        b = d[c] = Ext.ComponentManager.create(b, b.xtype)
                    }
                    this.mon(b, {
                        beforerender: function () {
                            b.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight())
                        }, scope: this, single: true
                    })
                }
            }
        }
    },
    isScaleColumn: function (a) {
        var b = a.xtype && (Ext.ClassManager.getByAlias(a.xtype));
        b = b && b.prototype;
        return (a instanceof Gnt.column.Scale || (b && b instanceof Gnt.column.Scale))
    },
    initWeekendsHightlight: function () {
        this.workingTimePlugin = new Gnt.feature.WorkingTime({calendar: this.calendar});
        this.plugins = [].concat(this.plugins || []);
        this.plugins.push(this.workingTimePlugin)
    },
    destroy: function () {
        this.unbindStores();
        this.callParent(arguments)
    },
    getEventStore: function () {
        return this.taskStore
    },
    getTimeSpanDefiningStore: function () {
        return this.taskStore
    },
    unbindResourceCalendarListener: function (b, a) {
        var c = this.calendarResources[a];
        if (c) {
            Ext.Array.remove(c, b);
            if (!c.length) {
                this.calendarListenersHash[a].destroy();
                delete this.calendarListenersHash[a];
                delete this.calendarResources[a]
            }
        }
    },
    bindResourceCalendarListener: function (c) {
        var b = this, d = c.getOwnCalendar(), a = d.getCalendarId();
        if (!b.calendarListenersHash[a]) {
            b.calendarListenersHash[a] = b.mon(d, {
                load: b.onCalendarChange,
                calendarchange: b.onCalendarChange,
                scope: b,
                destroyable: true
            })
        }
        if (!b.calendarResources[a]) {
            b.calendarResources[a] = [c]
        } else {
            if (Ext.Array.indexOf(b.calendarResources, c) === -1) {
                b.calendarResources[a].push(c)
            }
        }
    },
    bindCalendarListeners: function () {
        var a = this;
        a.unbindCalendarListeners();
        a.store.each(function (b) {
            var c = b.getOwnCalendar();
            if (c && c !== a.calendar) {
                a.bindResourceCalendarListener(b)
            }
        })
    },
    unbindCalendarListeners: function () {
        for (var a in this.calendarListenersHash) {
            this.calendarListenersHash[a].destroy()
        }
        this.calendarResources = [];
        this.calendarListenersHash = {}
    },
    onTaskStoreRefresh: function () {
        this.clearCacheAndRefresh()
    },
    onCalendarChange: function (c) {
        var b = this.calendarResources[c.getCalendarId()];
        if (b) {
            for (var a = 0; a < b.length; a++) {
                this.clearCacheAndRefresh(b[a])
            }
        }
    },
    onProjectCalendarChange: function () {
        this.clearCacheAndRefresh()
    },
    onTaskUpdate: function (c, b) {
        var a;
        if (this.assignmentStore && b.getAssignmentStore() != this.assignmentStore) {
            a = this.assignmentStore.getAssignmentsForTask(b.getId())
        } else {
            a = b.getAssignments()
        }
        this.onAssignmentsChange(this.assignmentStore, a)
    },
    onAssignmentsRefresh: function (a) {
        this.onAssignmentsChange(a, a.getRange())
    },
    onAssignmentUpdate: function (g, h, b, d) {
        var c = this, f = c.assignmentStore.model.prototype.resourceIdField, e;
        if (b == Ext.data.Model.EDIT) {
            if (d && Ext.Array.contains(d, f)) {
                var a = h.previous[f];
                e = this.resourceStore.getModelById(a);
                if (e) {
                    this.clearCacheAndRefresh(e)
                }
            }
            c.onAssignmentsChange(g, [h])
        }
    },
    onAssignmentsChange: function (f, b) {
        var d = this, e;
        if (!Ext.isArray(b)) {
            b = [b]
        }
        for (var c = 0, a = b.length; c < a; c++) {
            e = d.resourceStore.getModelById(b[c].getResourceId());
            if (e && !e.inOnCalendarChange) {
                d.clearCacheAndRefresh(e)
            }
        }
    },
    enableRowHeightInjection: function (a, c) {
        var b = new Ext.XTemplate("{%", "this.processCellValues(values);", "this.nextTpl.applyOut(values, out, parent);", "%}", {
            priority: 1,
            processCellValues: function (e) {
                if (c.orientation == "horizontal") {
                    var d = c.getAvailableRowHeight();
                    e.style = (e.style || "") + ";height:" + d + "px;"
                }
            }
        });
        a.addCellTpl(b);
        c.addCellTpl(b)
    },
    findEndIndex: function (d, c) {
        c = c || this.getEndDate();
        var a = d.length - 1;
        for (var b = a; b >= 0; b--) {
            if (d[b].startDate < c) {
                a = b;
                break
            }
        }
        return a
    },
    findStartIndex: function (e, b) {
        b = b || this.getStartDate();
        var a = 0;
        for (var d = 0, c = e.length; d < c; d++) {
            if (e[d].endDate > b) {
                a = d;
                break
            }
        }
        return a
    },
    resetAllocationDataCache: function (b) {
        var a = this;
        if (!b) {
            a.allocationData = {}
        } else {
            a.allocationData = a.allocationData || {};
            a.allocationData[b.getId()] = null
        }
    },
    constrainAllocationDataCache: function (b) {
        var e = this, f = new Date(e.timeAxis.getStart() - this.cacheLimitDurationMS), h = new Date(e.timeAxis.getEnd() - 0 + this.cacheLimitDurationMS), i = b.maxBars.length - 1, a = 0, c = b.bars.length - 1, d = 0, g = false;
        if (b.cacheEnd > h) {
            i = e.findEndIndex(b.maxBars, h);
            c = e.findEndIndex(b.bars, h);
            b.cacheEnd = h;
            g = true
        }
        if (b.cacheStart < f) {
            a = e.findStartIndex(b.maxBars, f);
            d = e.findStartIndex(b.bars, f);
            b.cacheStart = f;
            g = true
        }
        if (g) {
            b.maxBars = Ext.Array.splice(b.maxBars, a, i + 1 - a);
            b.bars = Ext.Array.splice(b.bars, d, c + 1 - d)
        }
        return g
    },
    updateAllocationDataCache: function (f, a, h) {
        var c = Sch.util.Date, k = this, j, g, b, e, m;
        if (k.cacheUpdateSuspended) {
            k.suspendedCacheUpdatesCount++;
            return
        }
        a = a || k.getStartDate();
        h = h || k.getEndDate();
        if (!f) {
            k.resourceStore.each(function (p) {
                k.updateAllocationDataCache(p, a, h)
            })
        } else {
            j = k.allocationData[f.getId()] || {};
            g = j.cacheStart;
            b = j.cacheEnd;
            if (g != a || b != h) {
                if (g && b && c.intersectSpans(g, b, a, h)) {
                    if (g > a) {
                        e = k.processAllocationData(f.getAllocationInfo({
                            startDate: a,
                            endDate: g,
                            includeResCalIntervals: true
                        }));
                        if (e.maxBars.length) {
                            if (e.maxBars[e.maxBars.length - 1].startDate.getTime() === g.getTime()) {
                                e.maxBars.pop()
                            }
                        }
                        if (e.bars.length && j.bars.length) {
                            var d = e.bars[e.bars.length - 1];
                            var i = j.bars[0];
                            if (d.startDate >= i.startDate && d.endDate <= i.endDate) {
                                e.bars.pop()
                            }
                        }
                        e.maxBars.length && (e.maxBars[e.maxBars.length - 1].endDate = g);
                        j.maxBars.length && (j.maxBars[0].startDate = g);
                        j.bars = e.bars.concat(j.bars);
                        j.maxBars = e.maxBars.concat(j.maxBars);
                        j.maxBarsStartIndex = 0;
                        j.barsStartIndex = 0;
                        j.cacheStart = a
                    }
                    if (b < h) {
                        m = k.processAllocationData(f.getAllocationInfo({
                            startDate: b,
                            endDate: h,
                            includeResCalIntervals: true
                        }));
                        if (m.maxBars.length) {
                            var o = m.maxBars[0];
                            if (o.endDate.getTime() === b.getTime()) {
                                m.maxBars.shift()
                            } else {
                                o.startDate = b
                            }
                        }
                        if (m.bars.length && j.bars.length) {
                            var l = m.bars[0];
                            var n = j.bars[j.bars.length - 1];
                            if (l.startDate >= n.startDate && l.endDate <= n.endDate) {
                                m.bars.shift()
                            }
                        }
                        m.maxBars.length && (m.maxBars[m.maxBars.length - 1].endDate = h);
                        j.maxBars.length && (j.maxBars[j.maxBars.length - 1].endDate = b);
                        j.bars = j.bars.concat(m.bars);
                        j.maxBars = j.maxBars.concat(m.maxBars);
                        j.maxBarsEndIndex = j.maxBars.length - 1;
                        j.barsEndIndex = j.bars.length - 1;
                        j.cacheEnd = h
                    }
                    if (k.cacheLimitDuration > 0) {
                        k.constrainAllocationDataCache(j)
                    }
                    j.maxBarsStartIndex = k.findStartIndex(j.maxBars, a);
                    j.barsStartIndex = k.findStartIndex(j.bars, a);
                    j.maxBarsEndIndex = k.findEndIndex(j.maxBars, h);
                    j.barsEndIndex = k.findEndIndex(j.bars, h)
                } else {
                    j = k.processAllocationData(f.getAllocationInfo({
                        startDate: a,
                        endDate: h,
                        includeResCalIntervals: true
                    }));
                    j.maxBarsStartIndex = 0;
                    j.maxBarsEndIndex = j.maxBars.length - 1;
                    j.barsStartIndex = 0;
                    j.barsEndIndex = j.bars.length - 1;
                    j.cacheStart = a;
                    j.cacheEnd = h
                }
            }
            k.allocationData[f.getId()] = j
        }
    },
    isBarAssignmentsChanged: function (c) {
        var d = c.bar, e = c.period;
        if (!d.assignments || !e.inResourceCalendar || !e.totalAllocation || !e.inTasksCalendar) {
            return false
        }
        for (var b = 0, a = d.assignments.length; b < a; b++) {
            if (e.assignmentsHash[d.assignments[b].getTaskId()]) {
                return false
            }
        }
        return true
    },
    openBar: function (b, a) {
        a.bar = {
            startDate: b,
            totalAllocation: a.period.totalAllocation,
            allocationMS: a.allocationMS,
            assignments: a.period.assignments,
            totalOverAllocationMS: a.totalOverAllocationMS
        };
        a.barOpened = true;
        return a.bar
    },
    closeBar: function (b, a) {
        if (!a.barOpened) {
            return false
        }
        if (b) {
            a.bar.endDate = b
        }
        a.bars.push(a.bar);
        a.barOpened = false
    },
    appendZeroMaxBars: function (c, a, b) {
        if (!c) {
            return false
        }
        var d = this, h = Sch.util.Date.getDurationInDays(c, a);
        if (h < 2) {
            return false
        }
        var g = true, e = b.maxBar, f = b.maxBars;
        if (e) {
            if (!e.allocationMS) {
                g = false
            } else {
                e.endDate = Sch.util.Date.getStartOfNextDay(c, true);
                f.push(e)
            }
        }
        if (g) {
            b.maxBar = {startDate: e && e.endDate || d.getStart(), allocationMS: 0}
        }
        b.maxAllocationMS = 0;
        return b.maxBar
    },
    processAllocationData: function (x) {
        var u, v, k, s, n, b, a, m, c, y, f, g, p = [], h = [], w = this, e = {bars: p, maxBars: h};
        var o = Ext.Date.clearTime(x[0].startDate, true);
        if (o > this.getStartDate()) {
            h.push({startDate: this.getStartDate(), endDate: o, allocationMS: 0})
        }
        for (var t = 0, q = x.length; t < q; t++) {
            u = e.period = x[t];
            o = Ext.Date.clearTime(u.startDate, true);
            if (o - s !== 0) {
                if (this.showLimitLines) {
                    if (w.appendZeroMaxBars(s, o, e)) {
                        k = e.maxBar
                    }
                }
                s = o;
                m = e.allocationMS;
                g = e.totalOverAllocationMS;
                y = e.maxAllocationMS;
                a = 0;
                f = 0;
                c = 0;
                var r = t;
                while (x[r] && Ext.Date.clearTime(x[r].startDate, true) - o === 0) {
                    if (x[r].inResourceCalendar) {
                        c += x[r].endDate - x[r].startDate;
                        if (x[r].totalAllocation && x[r].inTasksCalendar) {
                            a += x[r].totalAllocationMS || (x[r].endDate - x[r].startDate) * x[r].totalAllocation / 100;
                            f += x[r].totalOverAllocationMS || 0
                        }
                    }
                    r++
                }
                e.allocationMS = a;
                e.totalOverAllocationMS = f;
                e.maxAllocationMS = c
            } else {
                o = false
            }
            if (w.showLimitLines) {
                if (o && c != y) {
                    if (k) {
                        k.endDate = o;
                        h.push(k)
                    }
                    k = e.maxBar = {startDate: o, allocationMS: c}
                }
                k.endDate = u.endDate
            }
            if (!e.barOpened) {
                if (u.inTask) {
                    v = w.openBar(new Date(u.startDate), e)
                }
            } else {
                if (!u.inTask) {
                    w.closeBar(null, e)
                } else {
                    var d = false;
                    if (w.isBarAssignmentsChanged(e)) {
                        n = v.endDate;
                        b = new Date(u.startDate);
                        d = true
                    } else {
                        if (o && v.endDate <= Sch.util.Date.add(o, Sch.util.Date.DAY, -1)) {
                            n = Ext.Date.clearTime(v.endDate, true);
                            if (n < v.endDate) {
                                n = Sch.util.Date.add(n, Sch.util.Date.DAY, 1)
                            }
                            b = Ext.Date.clearTime(u.startDate, true);
                            d = true
                        } else {
                            if (o && a !== m && u.totalAllocation && u.totalAllocation == v.totalAllocation) {
                                n = b = u.startDate;
                                d = true
                            } else {
                                if (u.totalAllocation && u.totalAllocation != v.totalAllocation) {
                                    n = b = u.totalAllocation > v.totalAllocation ? new Date(u.startDate) : v.endDate;
                                    d = true
                                }
                            }
                        }
                    }
                    if (d) {
                        w.closeBar(n, e);
                        v = w.openBar(b, e)
                    }
                }
            }
            if (e.barOpened) {
                v.endDate = u.endDate
            }
        }
        w.closeBar(null, e);
        if (w.showLimitLines) {
            if (w.appendZeroMaxBars(s || w.getStart(), w.getEnd(), e)) {
                k = e.maxBar
            }
            if (k) {
                h.push(k)
            }
        }
        return {bars: p, maxBars: h}
    },
    onResourceUpdate: function (b, e, a, c) {
        if (Ext.Array.indexOf(c, e.calendarIdField) > -1) {
            this.resetAllocationDataCache(e);
            var d = e.previous[e.calendarIdField];
            this.unbindResourceCalendarListener(e, d);
            var f = e.getOwnCalendar();
            if (f && f !== this.calendar) {
                this.bindResourceCalendarListener(e)
            }
        }
    },
    onResourceStoreRefresh: function () {
        var a = this;
        a.clearCacheAndRefresh();
        a.bindCalendarListeners()
    },
    refreshIfRendered: function (b) {
        var a = this;
        if (a.rendered && a.resourceStore && b) {
            a.getView().refreshNode(a.resourceStore.indexOf(b))
        } else {
            if (a.rendered) {
                a.getView().refresh()
            }
        }
    },
    columnRenderer: function (a, k, b, g, j) {
        var f = this, d = b.getId(), h = this.normalGrid.getView(), c, i, e;
        f.updateAllocationDataCache(b);
        c = f.allocationData[d];
        i = c && c.bars;
        e = c && c.maxBars;
        if (i && (c.barsStartIndex > 0 || c.barsEndIndex < i.length - 1)) {
            i = Ext.Array.slice(i, c.barsStartIndex, c.barsEndIndex + 1)
        }
        if (e && (c.maxBarsStartIndex > 0 || c.maxBarsEndIndex < e.length - 1)) {
            e = Ext.Array.slice(e, c.maxBarsStartIndex, c.maxBarsEndIndex + 1)
        }
        return (f.showScaleLines ? h.renderLines() : "") + h.renderBars(i, d) + (f.showLimitLines ? h.renderLimitLines(e) : "")
    }
});
if (false && !window.location.href.match("bryntum.com|ext-scheduler.com")) {
    var log = function (a) {
        if (window.console) {
            console.log(a)
        }
    };
    log("BRYNTUM TRIAL LICENSE, for purchasing and licensing options please visit: www.bryntum.com/store (btw, we're hiring: www.bryntum.com/company/careers )");
    function newRefresh() {
        this.callOverridden(arguments);
        if (this.__injected || !this.rendered) {
            return
        }
        this.__injected = true;
        Ext.Function.defer(function () {
            this.el && this.el.select(this.eventSelector).setOpacity(0.15);
            log("TRIAL VERSION: PRODUCT DEACTIVATED")
        }, 10 * 60 * 1000, this);
        var a = this.el.parent().createChild({
            tag: "a",
            cls: "bryntum-trial",
            href: "http://www.bryntum.com/store",
            title: "Click here to purchase a license",
            style: "display:block;height:54px;width:230px;background: #fff url(http://www.bryntum.com/site-images/bryntum-trial.png) no-repeat;z-index:10000;border:1px solid #ddd;-webkit-box-shadow: 2px 2px 2px rgba(100, 100, 100, 0.5);-moz-box-shadow: 2px 2px 2px rgba(100, 100, 100, 0.5);-moz-border-radius:5px;-webkit-border-radius:5px;position:absolute;bottom:10px;right:15px;"
        });
        try {
            if (!Ext.util.Cookies.get("bmeval")) {
                Ext.util.Cookies.set("bmeval", new Date().getTime(), Ext.Date.add(new Date(), Ext.Date.YEAR, 2))
            } else {
                var d = Ext.util.Cookies.get("bmeval"), b = new Date(parseInt(d, 10));
                if (Ext.Date.add(b, Ext.Date.DAY, 45) < new Date()) {
                    this.el.select(this.eventSelector).hide();
                    this.el.mask("Trial Period Expired!").setStyle("z-index", 10000);
                    log("TRIAL PERIOD EXPIRED, PURCHASE A LICENSE HERE http://bryntum.com/");
                    this.refresh = Ext.emptyFn
                }
            }
        } catch (c) {
            log(c);
        }
    }

    if (Sch && Sch.view && Sch.view.TimelineGridView) {
        Sch.view.TimelineGridView.override({refresh: Ext.Function.clone(newRefresh)})
    }
    if (Sch && Sch.view && Sch.view.TimelineTreeView) {
        Sch.view.TimelineTreeView.override({refresh: Ext.Function.clone(newRefresh)})
    }
}
Ext.data.Connection.override({
    parseStatus: function (b) {
        var a = this.callOverridden(arguments);
        if (b === 0) {
            a.success = true
        }
        return a
    }
});
(function () {
    var a = {
        eventChain: [], init: function () {
            //this.setupAnalytics();
            if (document.addEventListener) {
                //this.initEventRecording()
            }
            //this.initErrorLogging()
        }, setupAnalytics: function () {
            window._gaq = window._gaq || [];
            window._gaq.push(["_setAccount", "UA-11046863-1"]);
            window._gaq.push(["_setDomainName", "none"]);
            window._gaq.push(["_setAllowLinker", true]);
            window._gaq.push(["_trackPageview"]);
            var c = document.createElement("script");
            c.type = "text/javascript";
            c.async = true;
            c.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var b = document.getElementsByTagName("script")[0];
            b.parentNode.insertBefore(c, b)
        }, initEventRecording: function () {
            var f = ["-focus$", "-over$", "-selected$", "-active$", "x-body", "x-box-item", "x-btn-wrap", "x-component", "x-datepicker-cell", "x-fit-item", "x-form-field", "x-form-empty-field", "x-form-required-field", "x-grid-cell-inner", "x-grid-view", "x-grid-row-focused", "x-grid-resize-marker", "x-layout", "x-menu-item-link", "x-noicon", "x-resizable-overlay", "x-tab-noicon", "x-tab-default-noicon", "x-tab-default", "x-tree-icon", "x-trigger-index-", "x-unselectable", "sch-gantt-terminal$", "sch-gantt-task-handle$", "sch-gantt-item", "sch-resizable-handle$", "null", "undefined"];
            var b = new RegExp(f.join("|"));
            var d = function (i) {
                if (!i) {
                    return ""
                }
                var h = "", g = Ext.String.trim(i.className || "");
                if (i.id) {
                    return "#" + i.id
                } else {
                    if (g) {
                        g.split(" ").forEach(function (j) {
                            if (j && !b.test(j)) {
                                h += "." + j
                            }
                        })
                    }
                }
                return d(i.parentNode && i.parentNode !== document.body && i.parentNode) + " " + h
            };
            var c = this;
            var e = function (j) {
                try {
                    j = j || window.event;
                    var i = j.target;
                    if (i && i.nodeType == 3) {
                        i = i.parentNode
                    }
                    if (!i) {
                        return
                    }
                    var h = j.type == "contextmenu" || j.which == 3 || j.button == 2 ? "rightclick" : j.type;
                    var g = {desc: h + ' "' + d(i) + '"'};
                    g[h] = [j.pageX, j.pageY];
                    c.eventChain.push(g)
                } catch (j) {
                    console.log(j);
                    c.eventChain.push({error: j.name, message: (j.message || j.description), stack: j.stack})
                }
            };
            document.addEventListener("click", e, true);
            document.addEventListener("dblclick", e, true);
            document.addEventListener("contextmenu", e, true)
        }, initErrorLogging: function () {
            var b = this, c = window, e = document;
            c.onerror = function (n, g, o, h, k) {
                if (!n || n.match("chrome://") || n.match("Script error") || (g && (g.match("localhost") || g.match("fiesta")))) {
                    return
                }
                if (!c.__reported && n && (o || g)) {
                    c.__reported = true;
                    try {
                        var f = c.innerWidth || e.documentElement.clientWidth || e.body.clientWidth, d = c.innerHeight || e.documentElement.clientHeight || e.body.clientHeight, l = "";
                        if (b.eventChain.length) {
                            if (f && d) {
                                l += "t.setWindowSize(" + f + ", " + d + ");"
                            }
                        }
                        if (Ext.JSON) {
                            l += "t.chain(" + Ext.JSON.encode(b.eventChain).replace(/^\[|\]$/g, "") + ");"
                        }
                        var m = {
                            msg: n,
                            url: g,
                            line: o,
                            href: c.location.href,
                            windowWidth: f,
                            windowHeight: d,
                            extVersion: Ext.versions && Ext.versions.extjs && Ext.versions.extjs.version,
                            prodVersion: Sch.VERSION || "-",
                            localDate: new Date().toString(),
                            browser: (Ext.ieVersion && "IE" + Ext.ieVersion) || (Ext.chromeVersion && "Chrome" + Ext.chromeVersion) || (Ext.firefoxVersion && "FF" + Ext.firefoxVersion) || (Ext.safariVersion && "Safari" + Ext.safariVersion) || (Ext.operaVersion && "Opera" + Ext.operaVersion) || navigator.userAgent,
                            column: h || "",
                            stack: (k && k.stack) || "",
                            chain: l
                        };
                        var i = "";
                        Ext.Object.each(m, function (p, q) {
                            i += (p + "=" + encodeURIComponent(q) + "&")
                        });
                        //new Image().src = "http://bryntum.com/errlog.php?" + i
                    } catch (j) {
                        console.log(j)
                    }
                }
            };
            c.onbeforeunload = function () {
                c.onerror = null
            }
        }
    };
    Ext.onReady(a.init, a)
})();