Ext.data.JsonP.crud_manager({"guide":"<h1 id='crud_manager-section-crud-manager-general-information'>CRUD manager general information</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/crud_manager-section-intro'>Intro</a></li>\n<li><a href='#!/guide/crud_manager-section-architecture'>Architecture</a></li>\n<li><a href='#!/guide/crud_manager-section-server-communication-steps'>Server communication steps</a></li>\n<li><a href='#!/guide/crud_manager-section-data-loading'>Data loading</a></li>\n<li><a href='#!/guide/crud_manager-section-changes-persisting'>Changes persisting</a></li>\n<li><a href='#!/guide/crud_manager-section-error-handling'>Error handling</a></li>\n</ol>\n</div>\n\n<h2 id='crud_manager-section-intro'>Intro</h2>\n\n<p>The general idea of <em>CRUD manager</em> development was <em>simplicity</em>.\nWe wanted to create a central class combining all the project stores into a single object.\nSo that object could simplify an interaction with a server-side providing following features:</p>\n\n<ul>\n<li>retrieving of all stores data by a single server request</li>\n<li>persisting all data changes by a single server request</li>\n<li>more clear and concise configuration setup (by avoiding to configure each individual store proxy)</li>\n<li>also we wanted to make new classes in parallel with classic proxies to be independent of <em>ExtJS</em> upgrades</li>\n</ul>\n\n\n<p>All above targets were achieved by implementing <em>CRUD manager</em> classes.</p>\n\n<h2 id='crud_manager-section-architecture'>Architecture</h2>\n\n<p>Basically <em>CRUD manager</em> is a collection of stores.\nThe core of any <em>CRUD manager</em> implementation is <a href=\"#!/api/Sch.crud.AbstractManager\" rel=\"Sch.crud.AbstractManager\" class=\"docClass\">Sch.crud.AbstractManager</a> class.\nBut to turn the abstract class into a final implementation it should be mixed in with two more classes:</p>\n\n<ul>\n<li>encoding system mixin</li>\n<li>transport system mixin</li>\n</ul>\n\n\n<p>For example the given <a href=\"#!/api/Sch.data.CrudManager\" rel=\"Sch.data.CrudManager\" class=\"docClass\">Sch.data.CrudManager</a> class uses <em>JSON</em> as an encoding system (mixed by <a href=\"#!/api/Sch.crud.encoder.Json\" rel=\"Sch.crud.encoder.Json\" class=\"docClass\">Sch.crud.encoder.Json</a> class)\nand <em>AJAX</em> as a transport system (mixed by <a href=\"#!/api/Sch.crud.transport.Ajax\" rel=\"Sch.crud.transport.Ajax\" class=\"docClass\">Sch.crud.transport.Ajax</a> class).</p>\n\n<pre><code>var crudManager = Ext.create('<a href=\"#!/api/Sch.data.CrudManager\" rel=\"Sch.data.CrudManager\" class=\"docClass\">Sch.data.CrudManager</a>', {\n    autoLoad    : true,\n    stores      : [\n        store1, store2, store3\n    ],\n    transport   : {\n        load    : {\n            url     : 'php/read.php'\n        },\n        sync    : {\n            url     : 'php/save.php'\n        }\n    }\n});\n</code></pre>\n\n<p>The above <a href=\"#!/api/Sch.data.CrudManager\" rel=\"Sch.data.CrudManager\" class=\"docClass\">Sch.data.CrudManager</a> instance will load all the registered stores data from the server by a single <em>AJAX</em> request.\nAnd further changes made to those stores will be sent to the server by one bulk request as well (more details <a href=\"#!/api/Sch.data.CrudManager-method-sync\" rel=\"Sch.data.CrudManager-method-sync\" class=\"docClass\">here</a>).</p>\n\n<h3 id='crud_manager-section-implementing-custom-crud-manager'>Implementing custom CRUD manager</h3>\n\n<p>Let's say that we want to implement own <em>CRUD manager</em>.\nFor example to have another encoding system (like <em>XML</em> or any other format) or another transport system.\nThen we have to implement own mixins supporting corresponding systems.</p>\n\n<p>There are some requirements for content of mixins.\nAn encoding system mixin must have two methods:</p>\n\n<ul>\n<li><code>encode</code> - encodes packages before they are sent to a server (from <code>Object</code> to a <code>String</code>)</li>\n<li><code>decode</code> - decodes server responses (from <code>String</code> to an <code>Object</code>)</li>\n</ul>\n\n\n<p>And a transport system mixin must have following methods:</p>\n\n<ul>\n<li><code>sendRequest</code> - send request to a server</li>\n<li><code>cancelRequest</code> - cancels request</li>\n</ul>\n\n\n<p>So we extend abstract <a href=\"#!/api/Sch.crud.AbstractManager\" rel=\"Sch.crud.AbstractManager\" class=\"docClass\">Sch.crud.AbstractManager</a> class and mixin it with a custom encoder:</p>\n\n<pre><code>Ext.define('MyEncoder', {\n    encode : function (request) {\n        ...\n    },\n    decode : function (response) {\n        ...\n    }\n});\n\nExt.define('MyCrudManager', {\n    extend          : '<a href=\"#!/api/Sch.crud.AbstractManager\" rel=\"Sch.crud.AbstractManager\" class=\"docClass\">Sch.crud.AbstractManager</a>',\n    // we gonna use AJAX for requests transporting and our own encoding MyEncoder class\n    mixins          : ['MyEncoder', '<a href=\"#!/api/Sch.crud.transport.Ajax\" rel=\"Sch.crud.transport.Ajax\" class=\"docClass\">Sch.crud.transport.Ajax</a>']\n});\n</code></pre>\n\n<h3 id='crud_manager-section-data-revisions'>Data revisions</h3>\n\n<p>Server interaction protocol supports <em>server revision stamp</em> (basically it's a number incrementing after every data change on the server).\nBased on this value server may decline request holding likely outdated data.\nIt might be useful in case of highly concurrent system implementation since it allows to have additional control on data integrity and consistency.</p>\n\n<p>Yet this capability is optional and might be easily turned off depending on user requirements.</p>\n\n<h2 id='crud_manager-section-server-communication-steps'>Server communication steps</h2>\n\n<p>All server communications can be divided into two types:</p>\n\n<ul>\n<li>data loading (normally initial state of data provided by server)</li>\n<li>changes persisting (incremental update sent from client to server)</li>\n</ul>\n\n\n<p>See the following sections for detailed description.</p>\n\n<h2 id='crud_manager-section-data-loading'>Data loading</h2>\n\n<p>Data loading can be started by <a href=\"#!/api/Sch.crud.AbstractManager-method-load\" rel=\"Sch.crud.AbstractManager-method-load\" class=\"docClass\">load</a> call or invoked automatically upon <em>CRUD manager</em> creation\nif <a href=\"#!/api/Sch.crud.AbstractManager-cfg-autoLoad\" rel=\"Sch.crud.AbstractManager-cfg-autoLoad\" class=\"docClass\">autoLoad</a> config is set to <code>true</code>.\nA load request is performed asynchronously so user can specify a callback to be started on completion or listen to <a href=\"#!/api/Sch.crud.AbstractManager-event-load\" rel=\"Sch.crud.AbstractManager-event-load\" class=\"docClass\">load</a> event.</p>\n\n<p>Loading of acquired data occurs in the same order corresponding stores are registered in a <em>CRUD manager</em>.\nPlease take a look at <a href=\"#!/api/Sch.crud.AbstractManager-method-addStore\" rel=\"Sch.crud.AbstractManager-method-addStore\" class=\"docClass\">addStore</a> method for more details on how to register stores in a particular order.</p>\n\n<h3 id='crud_manager-section-load-request-structure'>Load request structure</h3>\n\n<p>Let's take a closer look at <em>load request</em> structure. Load request object have the following view:</p>\n\n<pre><code>{\n    requestId   : 123890,\n    type        : \"load\",\n    stores      : [\n        {\n            storeId     : \"store1\",\n            page        : 1,\n            pageSize    : 2,\n            someParam   : \"abc\"\n        },\n        \"store2\",\n        \"store3\"\n    ]\n}\n</code></pre>\n\n<p>Here is:</p>\n\n<ul>\n<li><code>requestId</code> - unique request identifier shipped with any request</li>\n<li><code>type</code> - request type ('load' - for load requests)</li>\n</ul>\n\n\n<p>The <code>stores</code> section holds list of stores that must be loaded. As a bare minimum each store can be described by its identifier (as its done for <code>store2</code> and <code>store3</code>)\nbut normally they are presented with an object holding store identifier plus several parameters.\nThese parameters can be provided in the <a href=\"#!/api/Sch.crud.AbstractManager-method-load\" rel=\"Sch.crud.AbstractManager-method-load\" class=\"docClass\">load</a> method.</p>\n\n<pre><code>crudManager.load({\n    // specify request params for store1\n    store1 : {\n        page        : 2,\n        someParam   : 'abc'\n    }\n});\n</code></pre>\n\n<h4 id='crud_manager-section-pagination-support'>Pagination support</h4>\n\n<p>Pagination support is provided with <code>page</code> and <code>pageSize</code> parameters for store loading.\nThey are taken from a corresponding store and ignored in cases they do not make sense (like for <code>Ext.data.TreeStore</code>).</p>\n\n<p><strong>Note:</strong> There is a special <a href=\"#!/api/Sch.widget.PagingToolbar\" rel=\"Sch.widget.PagingToolbar\" class=\"docClass\">Sch.widget.PagingToolbar</a> widget implementing paging toolbar.\nIt should be used instead of standard <code>Ext.toolbar.Paging</code> when dealing with a CRUD manager.</p>\n\n<h3 id='crud_manager-section-load-response-structure'>Load response structure</h3>\n\n<p>And response for such packet will look like this:</p>\n\n<pre><code>{\n    requestId   : 123890,\n    revision    : 123,\n    success     : true,\n\n    store1      : {\n        rows : [\n            { Id : 9000, SomeField : 'xxxx', ... },\n            { Id : 123, SomeField : 'yyyy', ... }\n        ],\n        metaData : {\n            someProp : 789,\n            anotherProp : \"foo\"\n        },\n        total : 5\n    },\n\n    store2      : {\n        rows : [\n            { Id : 1, Field1 : 'aaa', ... },\n            { Id : 2, Field1 : 'bbb', ... }\n        ],\n        total : 2\n    },\n\n    store3      : {\n        rows : [\n            { Id : 1, Field2 : 'aaa', ... },\n            { Id : 2, Field2 : 'bbb', ... }\n        ],\n        total : 2\n    }\n}\n</code></pre>\n\n<p>Here is:</p>\n\n<ul>\n<li><code>requestId</code> - responded request identifier</li>\n<li><code>revision</code> - <em>server revision stamp</em> from client</li>\n<li><code>success</code> - <code>true</code> for successful response, <code>false</code> if some server error occurred</li>\n</ul>\n\n\n<p>Each store data is transfered under corresponding identifier. Each store data section has:</p>\n\n<ul>\n<li><code>rows</code> - array of records</li>\n<li><code>total</code> - total number of records (may not be equal to the number of records in <code>rows</code> array in case of pagination)</li>\n<li><code>metaData</code> - an optional object containing meta data for the store. This object will be assigned to the store's <code>metaData</code> property after loading.</li>\n</ul>\n\n\n<h2 id='crud_manager-section-changes-persisting'>Changes persisting</h2>\n\n<p>Changes persisting can be started by <a href=\"#!/api/Sch.crud.AbstractManager-method-sync\" rel=\"Sch.crud.AbstractManager-method-sync\" class=\"docClass\">sync</a> call or invoked automatically after any change\nif <a href=\"#!/api/Sch.crud.AbstractManager-cfg-autoSync\" rel=\"Sch.crud.AbstractManager-cfg-autoSync\" class=\"docClass\">autoSync</a> config is set to <code>true</code>.\nA sync request is performed asynchronously but user can specify a callback to be started on its completion or listen to <a href=\"#!/api/Sch.crud.AbstractManager-event-sync\" rel=\"Sch.crud.AbstractManager-event-sync\" class=\"docClass\">sync</a> event.</p>\n\n<p>After request completion CRUD manager applies server-side changes returned in response to each individual store.</p>\n\n<p><strong>Note: It's highly recommended to prevent stores data changing while sync request is processing.\nThe <em>CRUD manager</em> tries to queue sync requests if user calls sync before prior request completion.\nThough data changing in parallel with ongoing request still may lead to unwanted data overriding.\nSo please use GUI masking technique (like <code>loadMask</code> for grids) to prevent such cases.</strong></p>\n\n<h3 id='crud_manager-section-sync-request-structure'>Sync request structure</h3>\n\n<p>Here is an example of <em>sync request</em> object:</p>\n\n<pre><code>{\n    requestId   : 123890,\n    type        : 'sync',\n    revision    : 123,\n\n    store1      : {\n        added : [\n            { $PhantomId : 'q1w2e3r4t5', SomeField : 'smth', ... },\n            ...\n        ],\n        updated : [\n            { Id : 123, SomeField : 'new value' },\n            ...\n        ],\n        removed : [\n            { Id : 345 },\n            ...\n        ]\n    },\n\n    store2      : {\n        added : [...],\n        updated :  [...],\n        removed :  [...]\n    }\n}\n</code></pre>\n\n<p>Here is:</p>\n\n<ul>\n<li><code>requestId</code> - unique request identifier shipped with any request</li>\n<li><code>type</code> - request type ('sync' - for sync requests)</li>\n<li><code>revision</code> - <em>server revision stamp</em> from client</li>\n</ul>\n\n\n<p>For each store request has three sections <code>added</code>, <code>updated</code> and <code>removed</code> under which we transfer corresponding records.\nThe presence of each section is optional depending on having corresponding type of changes.</p>\n\n<p>Each added record comes with its phantom identifier (<a href=\"#!/api/Sch.crud.AbstractManager-cfg-phantomIdField\" rel=\"Sch.crud.AbstractManager-cfg-phantomIdField\" class=\"docClass\">by default</a> <code>$PhantomId</code> field name is used for it).\nAnd each updated record includes its identifier plus updated field values only.\nAnd finally for removed records only their identifiers are transfered.</p>\n\n<h3 id='crud_manager-section-sync-response-structure'>Sync response structure</h3>\n\n<p>Example of <em>sync response</em> object:</p>\n\n<pre><code>{\n    requestId   : 123890,\n    success     : true,\n    revision    : 124,\n    store1      : {\n        rows : [\n            // processed phantom record initially sent from client\n            { $PhantomId : 'q1w2e3r4t5', Id : 9000 },\n            // processed updated record initially sent from client\n            { Id : 123, SomeField2 : '2013-08-01' },\n            // record added/updated by server logic (not sent from client)\n            { Id : 124, SomeField : 'server generated', SomeField2 : '2013-08-01' }\n            ...\n        ],\n        removed : [\n            // processed removed record initially sent from client\n            { Id : 345 },\n            // record removed by server logic (not sent from client)\n            { Id : 145 },\n            ...\n        ]\n    },\n\n    store2      : {\n        rows : [...],\n        removed : [...]\n    }\n}\n</code></pre>\n\n<p>Here is:</p>\n\n<ul>\n<li><code>requestId</code> - responded request identifier</li>\n<li><code>success</code> - <code>true</code> for successful response, <code>false</code> if some server error occurred</li>\n<li><code>revision</code> - new <em>server revision stamp</em> from server</li>\n</ul>\n\n\n<p>For each store we have two sections <code>rows</code> and <code>removed</code> where:</p>\n\n<ul>\n<li><code>rows</code> holds all records added or updated <em>by server</em>.\nAs a bare minimum, for phantom records sent from client, server returns a combination of phantom Id and real Id (Id assigned by server).\nIf server decides to update some record (either phantom or persisted one) or create a new one\nit should return an object holding a combination of real Id and those field values.\nThe field values will be applied to the corresponding store record on the client (or new record will be created).</li>\n<li><code>removed</code> holds Ids of records removed <em>by server</em> whether initially sent from client or removed due to some server logic.</li>\n</ul>\n\n\n<h2 id='crud_manager-section-error-handling'>Error handling</h2>\n\n<p>In case of server-side error response object will have a following look:</p>\n\n<pre><code>{\n    requestId : 123890,\n    success   : false,\n    message   : 'Error description goes here',\n    code      : 13\n}\n</code></pre>\n\n<p>Here is:</p>\n\n<ul>\n<li><code>requestId</code> - responded request identifier</li>\n<li><code>success</code> - <code>false</code> says that server error occurred</li>\n<li><code>message</code> - error text message</li>\n<li><code>code</code> - optionally may contain the occurred error code</li>\n</ul>\n\n\n<p>The <a href=\"#!/api/Sch.crud.AbstractManager-method-load\" rel=\"Sch.crud.AbstractManager-method-load\" class=\"docClass\">load</a> and <a href=\"#!/api/Sch.crud.AbstractManager-method-sync\" rel=\"Sch.crud.AbstractManager-method-sync\" class=\"docClass\">sync</a> methods has <code>errback</code> argument where\nuser can specify a function to be called if error faced.</p>\n\n<pre><code>var crudManager = Ext.create('<a href=\"#!/api/Sch.data.CrudManager\" rel=\"Sch.data.CrudManager\" class=\"docClass\">Sch.data.CrudManager</a>', {\n    resourceStore   : resourceStore,\n    eventStore      : eventStore,\n    transport       : {\n        load : {\n            url : 'php/read.php'\n        },\n        sync : {\n            url : 'php/save.php'\n        }\n    }\n});\n\ncrudManager.load(null, function (response, rawResponse) {\n    // let's show message box with error text\n    Ext.Msg.show({\n        title    : 'Error',\n        msg      : response &amp;&amp; response.message || 'Unknown error occurred',\n        icon     : Ext.Msg.ERROR,\n        buttons  : Ext.Msg.OK,\n        minWidth : Ext.Msg.minWidth\n    });\n});\n</code></pre>\n\n<p>Another option allowing to centralize handling of errors is <a href=\"#!/api/Sch.crud.AbstractManager-event-loadfail\" rel=\"Sch.crud.AbstractManager-event-loadfail\" class=\"docClass\">loadfail</a> and <a href=\"#!/api/Sch.crud.AbstractManager-event-syncfail\" rel=\"Sch.crud.AbstractManager-event-syncfail\" class=\"docClass\">syncfail</a> events\nlistening:</p>\n\n<pre><code>// some central method to handle CRUD errors\nvar processError = function (crud, response) {\n    // error code\n    var code = response &amp;&amp; response.code;\n\n    // here we can define some specific reaction on a particular error\n    if (code == 13) {\n        // for example re-load crudManager\n        crudManager.load();\n\n    // and for all other case we just display an error message box\n    } else {\n        Ext.Msg.show({\n            title    : 'Error',\n            msg      : response &amp;&amp; response.message || 'Unknown error occurred',\n            icon     : Ext.Msg.ERROR,\n            buttons  : Ext.Msg.OK,\n            minWidth : Ext.Msg.minWidth\n        });\n    }\n};\n\nvar crudManager     = Ext.create('<a href=\"#!/api/Sch.data.CrudManager\" rel=\"Sch.data.CrudManager\" class=\"docClass\">Sch.data.CrudManager</a>', {\n    autoLoad        : true,\n    resourceStore   : resourceStore,\n    eventStore      : eventStore,\n    transport       : {\n        load : {\n            url : 'php/read.php'\n        },\n        sync : {\n            url : 'php/save.php'\n        }\n    },\n    listeners       : {\n        // listen to load request errors\n        loadfail : processError,\n        // listen to sync request errors\n        syncfail : processError\n    }\n});\n</code></pre>\n","title":"CRUD manager general information"});